// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "stdafx.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpg_character_XML_tree.h"

// RPG_Character_Gender_XMLTree_Type
// 

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_Gender_XMLTree_Type_literals_[v])
{
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const RPG_Character_Gender_XMLTree_Type& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_Gender_XMLTree_Type& RPG_Character_Gender_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_Gender_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Race_XMLTree_Type
// 

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_Race_XMLTree_Type_literals_[v])
{
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const RPG_Character_Race_XMLTree_Type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_Race_XMLTree_Type& RPG_Character_Race_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_Race_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_MetaClass_XMLTree_Type
// 

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[v])
{
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const RPG_Character_MetaClass_XMLTree_Type& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_MetaClass_XMLTree_Type& RPG_Character_MetaClass_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_ClassXML_XMLTree_Type
// 

const RPG_Character_ClassXML_XMLTree_Type::metaClass_type& RPG_Character_ClassXML_XMLTree_Type::
metaClass () const
{
  return this->metaClass_.get ();
}

RPG_Character_ClassXML_XMLTree_Type::metaClass_type& RPG_Character_ClassXML_XMLTree_Type::
metaClass ()
{
  return this->metaClass_.get ();
}

void RPG_Character_ClassXML_XMLTree_Type::
metaClass (const metaClass_type& x)
{
  this->metaClass_.set (x);
}

void RPG_Character_ClassXML_XMLTree_Type::
metaClass (::std::auto_ptr< metaClass_type > x)
{
  this->metaClass_.set (x);
}

const RPG_Character_ClassXML_XMLTree_Type::subClass_sequence& RPG_Character_ClassXML_XMLTree_Type::
subClass () const
{
  return this->subClass_;
}

RPG_Character_ClassXML_XMLTree_Type::subClass_sequence& RPG_Character_ClassXML_XMLTree_Type::
subClass ()
{
  return this->subClass_;
}

void RPG_Character_ClassXML_XMLTree_Type::
subClass (const subClass_sequence& s)
{
  this->subClass_ = s;
}


// RPG_Character_Attributes_XMLTree_Type
// 

const RPG_Character_Attributes_XMLTree_Type::strength_type& RPG_Character_Attributes_XMLTree_Type::
strength () const
{
  return this->strength_.get ();
}

RPG_Character_Attributes_XMLTree_Type::strength_type& RPG_Character_Attributes_XMLTree_Type::
strength ()
{
  return this->strength_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
strength (const strength_type& x)
{
  this->strength_.set (x);
}

const RPG_Character_Attributes_XMLTree_Type::dexterity_type& RPG_Character_Attributes_XMLTree_Type::
dexterity () const
{
  return this->dexterity_.get ();
}

RPG_Character_Attributes_XMLTree_Type::dexterity_type& RPG_Character_Attributes_XMLTree_Type::
dexterity ()
{
  return this->dexterity_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
dexterity (const dexterity_type& x)
{
  this->dexterity_.set (x);
}

const RPG_Character_Attributes_XMLTree_Type::constitution_type& RPG_Character_Attributes_XMLTree_Type::
constitution () const
{
  return this->constitution_.get ();
}

RPG_Character_Attributes_XMLTree_Type::constitution_type& RPG_Character_Attributes_XMLTree_Type::
constitution ()
{
  return this->constitution_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
constitution (const constitution_type& x)
{
  this->constitution_.set (x);
}

const RPG_Character_Attributes_XMLTree_Type::intelligence_type& RPG_Character_Attributes_XMLTree_Type::
intelligence () const
{
  return this->intelligence_.get ();
}

RPG_Character_Attributes_XMLTree_Type::intelligence_type& RPG_Character_Attributes_XMLTree_Type::
intelligence ()
{
  return this->intelligence_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
intelligence (const intelligence_type& x)
{
  this->intelligence_.set (x);
}

const RPG_Character_Attributes_XMLTree_Type::wisdom_type& RPG_Character_Attributes_XMLTree_Type::
wisdom () const
{
  return this->wisdom_.get ();
}

RPG_Character_Attributes_XMLTree_Type::wisdom_type& RPG_Character_Attributes_XMLTree_Type::
wisdom ()
{
  return this->wisdom_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
wisdom (const wisdom_type& x)
{
  this->wisdom_.set (x);
}

const RPG_Character_Attributes_XMLTree_Type::charisma_type& RPG_Character_Attributes_XMLTree_Type::
charisma () const
{
  return this->charisma_.get ();
}

RPG_Character_Attributes_XMLTree_Type::charisma_type& RPG_Character_Attributes_XMLTree_Type::
charisma ()
{
  return this->charisma_.get ();
}

void RPG_Character_Attributes_XMLTree_Type::
charisma (const charisma_type& x)
{
  this->charisma_.set (x);
}


// RPG_Character_SkillValue_XMLTree_Type
// 

const RPG_Character_SkillValue_XMLTree_Type::skill_type& RPG_Character_SkillValue_XMLTree_Type::
skill () const
{
  return this->skill_.get ();
}

RPG_Character_SkillValue_XMLTree_Type::skill_type& RPG_Character_SkillValue_XMLTree_Type::
skill ()
{
  return this->skill_.get ();
}

void RPG_Character_SkillValue_XMLTree_Type::
skill (const skill_type& x)
{
  this->skill_.set (x);
}

void RPG_Character_SkillValue_XMLTree_Type::
skill (::std::auto_ptr< skill_type > x)
{
  this->skill_.set (x);
}

const RPG_Character_SkillValue_XMLTree_Type::rank_type& RPG_Character_SkillValue_XMLTree_Type::
rank () const
{
  return this->rank_.get ();
}

RPG_Character_SkillValue_XMLTree_Type::rank_type& RPG_Character_SkillValue_XMLTree_Type::
rank ()
{
  return this->rank_.get ();
}

void RPG_Character_SkillValue_XMLTree_Type::
rank (const rank_type& x)
{
  this->rank_.set (x);
}


// RPG_Character_Skills_XMLTree_Type
// 

const RPG_Character_Skills_XMLTree_Type::skill_sequence& RPG_Character_Skills_XMLTree_Type::
skill () const
{
  return this->skill_;
}

RPG_Character_Skills_XMLTree_Type::skill_sequence& RPG_Character_Skills_XMLTree_Type::
skill ()
{
  return this->skill_;
}

void RPG_Character_Skills_XMLTree_Type::
skill (const skill_sequence& s)
{
  this->skill_ = s;
}


// RPG_Character_Ability_XMLTree_Type
// 

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_Ability_XMLTree_Type_literals_[v])
{
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const RPG_Character_Ability_XMLTree_Type& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_Ability_XMLTree_Type& RPG_Character_Ability_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_Ability_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Feat_XMLTree_Type
// 

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_Feat_XMLTree_Type_literals_[v])
{
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const RPG_Character_Feat_XMLTree_Type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_Feat_XMLTree_Type& RPG_Character_Feat_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_Feat_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Feats_XMLTree_Type
// 

const RPG_Character_Feats_XMLTree_Type::feat_sequence& RPG_Character_Feats_XMLTree_Type::
feat () const
{
  return this->feat_;
}

RPG_Character_Feats_XMLTree_Type::feat_sequence& RPG_Character_Feats_XMLTree_Type::
feat ()
{
  return this->feat_;
}

void RPG_Character_Feats_XMLTree_Type::
feat (const feat_sequence& s)
{
  this->feat_ = s;
}


// RPG_Character_AlignmentCivic_XMLTree_Type
// 

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[v])
{
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const RPG_Character_AlignmentCivic_XMLTree_Type& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_AlignmentCivic_XMLTree_Type& RPG_Character_AlignmentCivic_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_AlignmentEthic_XMLTree_Type
// 

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[v])
{
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const RPG_Character_AlignmentEthic_XMLTree_Type& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_AlignmentEthic_XMLTree_Type& RPG_Character_AlignmentEthic_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Alignment_XMLTree_Type
// 

const RPG_Character_Alignment_XMLTree_Type::civic_type& RPG_Character_Alignment_XMLTree_Type::
civic () const
{
  return this->civic_.get ();
}

RPG_Character_Alignment_XMLTree_Type::civic_type& RPG_Character_Alignment_XMLTree_Type::
civic ()
{
  return this->civic_.get ();
}

void RPG_Character_Alignment_XMLTree_Type::
civic (const civic_type& x)
{
  this->civic_.set (x);
}

void RPG_Character_Alignment_XMLTree_Type::
civic (::std::auto_ptr< civic_type > x)
{
  this->civic_.set (x);
}

const RPG_Character_Alignment_XMLTree_Type::ethic_type& RPG_Character_Alignment_XMLTree_Type::
ethic () const
{
  return this->ethic_.get ();
}

RPG_Character_Alignment_XMLTree_Type::ethic_type& RPG_Character_Alignment_XMLTree_Type::
ethic ()
{
  return this->ethic_.get ();
}

void RPG_Character_Alignment_XMLTree_Type::
ethic (const ethic_type& x)
{
  this->ethic_.set (x);
}

void RPG_Character_Alignment_XMLTree_Type::
ethic (::std::auto_ptr< ethic_type > x)
{
  this->ethic_.set (x);
}


// RPG_Character_EquipmentSlot_XMLTree_Type
// 

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[v])
{
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const RPG_Character_EquipmentSlot_XMLTree_Type& v,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_EquipmentSlot_XMLTree_Type& RPG_Character_EquipmentSlot_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_OffHand_XMLTree_Type
// 

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_OffHand_XMLTree_Type_literals_[v])
{
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const RPG_Character_OffHand_XMLTree_Type& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_OffHand_XMLTree_Type& RPG_Character_OffHand_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_OffHand_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Encumbrance_XMLTree_Type
// 

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_[v])
{
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const RPG_Character_Encumbrance_XMLTree_Type& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_Encumbrance_XMLTree_Type& RPG_Character_Encumbrance_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_CheckTypeUnion_XMLTree_Type
// 

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_[v])
{
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const RPG_Character_CheckTypeUnion_XMLTree_Type& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Character_CheckTypeUnion_XMLTree_Type& RPG_Character_CheckTypeUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Character_Check_XMLTree_Type
// 

const RPG_Character_Check_XMLTree_Type::type_type& RPG_Character_Check_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Character_Check_XMLTree_Type::type_type& RPG_Character_Check_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Character_Check_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Character_Check_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Character_Check_XMLTree_Type::difficultyClass_type& RPG_Character_Check_XMLTree_Type::
difficultyClass () const
{
  return this->difficultyClass_.get ();
}

RPG_Character_Check_XMLTree_Type::difficultyClass_type& RPG_Character_Check_XMLTree_Type::
difficultyClass ()
{
  return this->difficultyClass_.get ();
}

void RPG_Character_Check_XMLTree_Type::
difficultyClass (const difficultyClass_type& x)
{
  this->difficultyClass_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RPG_Character_Gender_XMLTree_Type
//

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_Gender_XMLTree_Type_convert ();
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_Gender_XMLTree_Type_convert ();
}

RPG_Character_Gender_XMLTree_Type::
RPG_Character_Gender_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_Gender_XMLTree_Type_convert ();
}

RPG_Character_Gender_XMLTree_Type* RPG_Character_Gender_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Gender_XMLTree_Type (*this, f, c);
}

RPG_Character_Gender_XMLTree_Type::value RPG_Character_Gender_XMLTree_Type::
_xsd_RPG_Character_Gender_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_Gender_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_Gender_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_Gender_XMLTree_Type_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_Gender_XMLTree_Type_indexes_ + 4 || _xsd_RPG_Character_Gender_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_Gender_XMLTree_Type::
_xsd_RPG_Character_Gender_XMLTree_Type_literals_[4] =
{
  "GENDER_NONE",
  "GENDER_FEMALE",
  "GENDER_MALE",
  "GENDER_ANY"
};

const RPG_Character_Gender_XMLTree_Type::value RPG_Character_Gender_XMLTree_Type::
_xsd_RPG_Character_Gender_XMLTree_Type_indexes_[4] =
{
  ::RPG_Character_Gender_XMLTree_Type::GENDER_ANY,
  ::RPG_Character_Gender_XMLTree_Type::GENDER_FEMALE,
  ::RPG_Character_Gender_XMLTree_Type::GENDER_MALE,
  ::RPG_Character_Gender_XMLTree_Type::GENDER_NONE
};

// RPG_Character_Race_XMLTree_Type
//

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_Race_XMLTree_Type_convert ();
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_Race_XMLTree_Type_convert ();
}

RPG_Character_Race_XMLTree_Type::
RPG_Character_Race_XMLTree_Type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_Race_XMLTree_Type_convert ();
}

RPG_Character_Race_XMLTree_Type* RPG_Character_Race_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Race_XMLTree_Type (*this, f, c);
}

RPG_Character_Race_XMLTree_Type::value RPG_Character_Race_XMLTree_Type::
_xsd_RPG_Character_Race_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_Race_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_Race_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_Race_XMLTree_Type_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_Race_XMLTree_Type_indexes_ + 7 || _xsd_RPG_Character_Race_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_Race_XMLTree_Type::
_xsd_RPG_Character_Race_XMLTree_Type_literals_[7] =
{
  "RACE_NONE",
  "RACE_DWARF",
  "RACE_ELF",
  "RACE_GNOME",
  "RACE_HALFLING",
  "RACE_HUMAN",
  "RACE_ORC"
};

const RPG_Character_Race_XMLTree_Type::value RPG_Character_Race_XMLTree_Type::
_xsd_RPG_Character_Race_XMLTree_Type_indexes_[7] =
{
  ::RPG_Character_Race_XMLTree_Type::RACE_DWARF,
  ::RPG_Character_Race_XMLTree_Type::RACE_ELF,
  ::RPG_Character_Race_XMLTree_Type::RACE_GNOME,
  ::RPG_Character_Race_XMLTree_Type::RACE_HALFLING,
  ::RPG_Character_Race_XMLTree_Type::RACE_HUMAN,
  ::RPG_Character_Race_XMLTree_Type::RACE_NONE,
  ::RPG_Character_Race_XMLTree_Type::RACE_ORC
};

// RPG_Character_MetaClass_XMLTree_Type
//

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_MetaClass_XMLTree_Type_convert ();
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_MetaClass_XMLTree_Type_convert ();
}

RPG_Character_MetaClass_XMLTree_Type::
RPG_Character_MetaClass_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_MetaClass_XMLTree_Type_convert ();
}

RPG_Character_MetaClass_XMLTree_Type* RPG_Character_MetaClass_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_MetaClass_XMLTree_Type (*this, f, c);
}

RPG_Character_MetaClass_XMLTree_Type::value RPG_Character_MetaClass_XMLTree_Type::
_xsd_RPG_Character_MetaClass_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_MetaClass_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_MetaClass_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_MetaClass_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_MetaClass_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_MetaClass_XMLTree_Type::
_xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[5] =
{
  "METACLASS_NONE",
  "METACLASS_PRIEST",
  "METACLASS_ROGUE",
  "METACLASS_WARRIOR",
  "METACLASS_WIZARD"
};

const RPG_Character_MetaClass_XMLTree_Type::value RPG_Character_MetaClass_XMLTree_Type::
_xsd_RPG_Character_MetaClass_XMLTree_Type_indexes_[5] =
{
  ::RPG_Character_MetaClass_XMLTree_Type::METACLASS_NONE,
  ::RPG_Character_MetaClass_XMLTree_Type::METACLASS_PRIEST,
  ::RPG_Character_MetaClass_XMLTree_Type::METACLASS_ROGUE,
  ::RPG_Character_MetaClass_XMLTree_Type::METACLASS_WARRIOR,
  ::RPG_Character_MetaClass_XMLTree_Type::METACLASS_WIZARD
};

// RPG_Character_ClassXML_XMLTree_Type
//

RPG_Character_ClassXML_XMLTree_Type::
RPG_Character_ClassXML_XMLTree_Type (const metaClass_type& metaClass)
: ::xml_schema::type (),
  metaClass_ (metaClass, this),
  subClass_ (this)
{
}

RPG_Character_ClassXML_XMLTree_Type::
RPG_Character_ClassXML_XMLTree_Type (const RPG_Character_ClassXML_XMLTree_Type& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  metaClass_ (x.metaClass_, f, this),
  subClass_ (x.subClass_, f, this)
{
}

RPG_Character_ClassXML_XMLTree_Type::
RPG_Character_ClassXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  metaClass_ (this),
  subClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_ClassXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // metaClass
    //
    if (n.name () == "metaClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< metaClass_type > r (
        metaClass_traits::create (i, f, this));

      if (!metaClass_.present ())
      {
        this->metaClass_.set (r);
        continue;
      }
    }

    // subClass
    //
    if (n.name () == "subClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< subClass_type > r (
        subClass_traits::create (i, f, this));

      this->subClass_.push_back (r);
      continue;
    }

    break;
  }

  if (!metaClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "metaClass",
      "urn:rpg");
  }
}

RPG_Character_ClassXML_XMLTree_Type* RPG_Character_ClassXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_ClassXML_XMLTree_Type (*this, f, c);
}

RPG_Character_ClassXML_XMLTree_Type& RPG_Character_ClassXML_XMLTree_Type::
operator= (const RPG_Character_ClassXML_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->metaClass_ = x.metaClass_;
    this->subClass_ = x.subClass_;
  }

  return *this;
}

RPG_Character_ClassXML_XMLTree_Type::
~RPG_Character_ClassXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_ClassXML_XMLTree_Type& x, const RPG_Character_ClassXML_XMLTree_Type& y)
{
  if (!(x.metaClass () == y.metaClass ()))
    return false;

  if (!(x.subClass () == y.subClass ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_ClassXML_XMLTree_Type& x, const RPG_Character_ClassXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_Attributes_XMLTree_Type
//

RPG_Character_Attributes_XMLTree_Type::
RPG_Character_Attributes_XMLTree_Type (const strength_type& strength,
                                       const dexterity_type& dexterity,
                                       const constitution_type& constitution,
                                       const intelligence_type& intelligence,
                                       const wisdom_type& wisdom,
                                       const charisma_type& charisma)
: ::xml_schema::type (),
  strength_ (strength, this),
  dexterity_ (dexterity, this),
  constitution_ (constitution, this),
  intelligence_ (intelligence, this),
  wisdom_ (wisdom, this),
  charisma_ (charisma, this)
{
}

RPG_Character_Attributes_XMLTree_Type::
RPG_Character_Attributes_XMLTree_Type (const RPG_Character_Attributes_XMLTree_Type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  strength_ (x.strength_, f, this),
  dexterity_ (x.dexterity_, f, this),
  constitution_ (x.constitution_, f, this),
  intelligence_ (x.intelligence_, f, this),
  wisdom_ (x.wisdom_, f, this),
  charisma_ (x.charisma_, f, this)
{
}

RPG_Character_Attributes_XMLTree_Type::
RPG_Character_Attributes_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  strength_ (this),
  dexterity_ (this),
  constitution_ (this),
  intelligence_ (this),
  wisdom_ (this),
  charisma_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_Attributes_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // strength
    //
    if (n.name () == "strength" && n.namespace_ () == "urn:rpg")
    {
      if (!strength_.present ())
      {
        this->strength_.set (strength_traits::create (i, f, this));
        continue;
      }
    }

    // dexterity
    //
    if (n.name () == "dexterity" && n.namespace_ () == "urn:rpg")
    {
      if (!dexterity_.present ())
      {
        this->dexterity_.set (dexterity_traits::create (i, f, this));
        continue;
      }
    }

    // constitution
    //
    if (n.name () == "constitution" && n.namespace_ () == "urn:rpg")
    {
      if (!constitution_.present ())
      {
        this->constitution_.set (constitution_traits::create (i, f, this));
        continue;
      }
    }

    // intelligence
    //
    if (n.name () == "intelligence" && n.namespace_ () == "urn:rpg")
    {
      if (!intelligence_.present ())
      {
        this->intelligence_.set (intelligence_traits::create (i, f, this));
        continue;
      }
    }

    // wisdom
    //
    if (n.name () == "wisdom" && n.namespace_ () == "urn:rpg")
    {
      if (!wisdom_.present ())
      {
        this->wisdom_.set (wisdom_traits::create (i, f, this));
        continue;
      }
    }

    // charisma
    //
    if (n.name () == "charisma" && n.namespace_ () == "urn:rpg")
    {
      if (!charisma_.present ())
      {
        this->charisma_.set (charisma_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!strength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "strength",
      "urn:rpg");
  }

  if (!dexterity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dexterity",
      "urn:rpg");
  }

  if (!constitution_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "constitution",
      "urn:rpg");
  }

  if (!intelligence_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "intelligence",
      "urn:rpg");
  }

  if (!wisdom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "wisdom",
      "urn:rpg");
  }

  if (!charisma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "charisma",
      "urn:rpg");
  }
}

RPG_Character_Attributes_XMLTree_Type* RPG_Character_Attributes_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Attributes_XMLTree_Type (*this, f, c);
}

RPG_Character_Attributes_XMLTree_Type& RPG_Character_Attributes_XMLTree_Type::
operator= (const RPG_Character_Attributes_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->strength_ = x.strength_;
    this->dexterity_ = x.dexterity_;
    this->constitution_ = x.constitution_;
    this->intelligence_ = x.intelligence_;
    this->wisdom_ = x.wisdom_;
    this->charisma_ = x.charisma_;
  }

  return *this;
}

RPG_Character_Attributes_XMLTree_Type::
~RPG_Character_Attributes_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_Attributes_XMLTree_Type& x, const RPG_Character_Attributes_XMLTree_Type& y)
{
  if (!(x.strength () == y.strength ()))
    return false;

  if (!(x.dexterity () == y.dexterity ()))
    return false;

  if (!(x.constitution () == y.constitution ()))
    return false;

  if (!(x.intelligence () == y.intelligence ()))
    return false;

  if (!(x.wisdom () == y.wisdom ()))
    return false;

  if (!(x.charisma () == y.charisma ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_Attributes_XMLTree_Type& x, const RPG_Character_Attributes_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_SkillValue_XMLTree_Type
//

RPG_Character_SkillValue_XMLTree_Type::
RPG_Character_SkillValue_XMLTree_Type (const skill_type& skill,
                                       const rank_type& rank)
: ::xml_schema::type (),
  skill_ (skill, this),
  rank_ (rank, this)
{
}

RPG_Character_SkillValue_XMLTree_Type::
RPG_Character_SkillValue_XMLTree_Type (const RPG_Character_SkillValue_XMLTree_Type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  skill_ (x.skill_, f, this),
  rank_ (x.rank_, f, this)
{
}

RPG_Character_SkillValue_XMLTree_Type::
RPG_Character_SkillValue_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  skill_ (this),
  rank_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_SkillValue_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // skill
    //
    if (n.name () == "skill" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< skill_type > r (
        skill_traits::create (i, f, this));

      if (!skill_.present ())
      {
        this->skill_.set (r);
        continue;
      }
    }

    // rank
    //
    if (n.name () == "rank" && n.namespace_ () == "urn:rpg")
    {
      if (!rank_.present ())
      {
        this->rank_.set (rank_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!skill_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "skill",
      "urn:rpg");
  }

  if (!rank_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rank",
      "urn:rpg");
  }
}

RPG_Character_SkillValue_XMLTree_Type* RPG_Character_SkillValue_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_SkillValue_XMLTree_Type (*this, f, c);
}

RPG_Character_SkillValue_XMLTree_Type& RPG_Character_SkillValue_XMLTree_Type::
operator= (const RPG_Character_SkillValue_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->skill_ = x.skill_;
    this->rank_ = x.rank_;
  }

  return *this;
}

RPG_Character_SkillValue_XMLTree_Type::
~RPG_Character_SkillValue_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_SkillValue_XMLTree_Type& x, const RPG_Character_SkillValue_XMLTree_Type& y)
{
  if (!(x.skill () == y.skill ()))
    return false;

  if (!(x.rank () == y.rank ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_SkillValue_XMLTree_Type& x, const RPG_Character_SkillValue_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_Skills_XMLTree_Type
//

RPG_Character_Skills_XMLTree_Type::
RPG_Character_Skills_XMLTree_Type ()
: ::xml_schema::type (),
  skill_ (this)
{
}

RPG_Character_Skills_XMLTree_Type::
RPG_Character_Skills_XMLTree_Type (const RPG_Character_Skills_XMLTree_Type& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  skill_ (x.skill_, f, this)
{
}

RPG_Character_Skills_XMLTree_Type::
RPG_Character_Skills_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  skill_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_Skills_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // skill
    //
    if (n.name () == "skill" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< skill_type > r (
        skill_traits::create (i, f, this));

      this->skill_.push_back (r);
      continue;
    }

    break;
  }
}

RPG_Character_Skills_XMLTree_Type* RPG_Character_Skills_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Skills_XMLTree_Type (*this, f, c);
}

RPG_Character_Skills_XMLTree_Type& RPG_Character_Skills_XMLTree_Type::
operator= (const RPG_Character_Skills_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->skill_ = x.skill_;
  }

  return *this;
}

RPG_Character_Skills_XMLTree_Type::
~RPG_Character_Skills_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_Skills_XMLTree_Type& x, const RPG_Character_Skills_XMLTree_Type& y)
{
  if (!(x.skill () == y.skill ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_Skills_XMLTree_Type& x, const RPG_Character_Skills_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_Ability_XMLTree_Type
//

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_Ability_XMLTree_Type_convert ();
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_Ability_XMLTree_Type_convert ();
}

RPG_Character_Ability_XMLTree_Type::
RPG_Character_Ability_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_Ability_XMLTree_Type_convert ();
}

RPG_Character_Ability_XMLTree_Type* RPG_Character_Ability_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Ability_XMLTree_Type (*this, f, c);
}

RPG_Character_Ability_XMLTree_Type::value RPG_Character_Ability_XMLTree_Type::
_xsd_RPG_Character_Ability_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_Ability_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_Ability_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_Ability_XMLTree_Type_indexes_ + 79,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_Ability_XMLTree_Type_indexes_ + 79 || _xsd_RPG_Character_Ability_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_Ability_XMLTree_Type::
_xsd_RPG_Character_Ability_XMLTree_Type_literals_[79] =
{
  "ABILITY_ACID_ATTACK",
  "ABILITY_CORROSIVE_SLIME",
  "ABILITY_DEATH_THROES",
  "ABILITY_ENTANGLE",
  "ABILITY_FLAMING_BODY",
  "ABILITY_LEAP_ATTACK",
  "ABILITY_REND_ARMOR",
  "ABILITY_SCORE_LOSS",
  "ABILITY_SNEAK_ATTACK",
  "ABILITY_SPORES",
  "ABILITY_STENCH",
  "ABILITY_THROW_WEB",
  "ABILITY_ALTERNATE_FORM",
  "ABILITY_ANTIMAGIC",
  "ABILITY_BLINDSIGHT",
  "ABILITY_BLINDSENSE",
  "ABILITY_BREATH_WEAPON",
  "ABILITY_CHANGE_SHAPE",
  "ABILITY_CHARM",
  "ABILITY_COMPULSION",
  "ABILITY_IMMUNITY_COLD",
  "ABILITY_CONSTRICT",
  "ABILITY_RESISTANCE_TO_DAMAGE",
  "ABILITY_DARKVISION",
  "ABILITY_DEATH_ATTACK",
  "ABILITY_DISEASE",
  "ABILITY_ENERGY_DRAIN",
  "ABILITY_ETHEREALNESS",
  "ABILITY_EVASION",
  "ABILITY_IMPROVED_EVASION",
  "ABILITY_FAST_HEALING",
  "ABILITY_FEAR",
  "ABILITY_IMMUNITY_FIRE",
  "ABILITY_GASEOUS_FORM",
  "ABILITY_GAZE_ATTACK",
  "ABILITY_IMPROVED_GRAB",
  "ABILITY_INCORPOREALITY",
  "ABILITY_INVISIBILITY",
  "ABILITY_LEVEL_LOSS",
  "ABILITY_LOWLIGHT_VISION",
  "ABILITY_MANUFACTURED_WEAPONS",
  "ABILITY_MOVEMENT_MODES",
  "ABILITY_NATURAL_WEAPONS",
  "ABILITY_NONABILITIES",
  "ABILITY_PARALYZE_ATTACK",
  "ABILITY_POISON_ATTACK",
  "ABILITY_IMMUNITY_POISON",
  "ABILITY_POLYMORPH",
  "ABILITY_POUNCE",
  "ABILITY_POWERFUL_CHARGE",
  "ABILITY_PSIONICS",
  "ABILITY_RAKE",
  "ABILITY_RAY_ATTACK",
  "ABILITY_REGENERATION",
  "ABILITY_RESISTANCE_TO_ENERGY",
  "ABILITY_SCENT",
  "ABILITY_SONIC_ATTACK",
  "ABILITY_IMMUNITY_SPELL",
  "ABILITY_RESISTANCE_TO_SPELL",
  "ABILITY_SPELLS",
  "ABILITY_SUMMON",
  "ABILITY_SWALLOW_WHOLE",
  "ABILITY_TELEPATHY",
  "ABILITY_TRAMPLE",
  "ABILITY_TREMOR_SENSE",
  "ABILITY_RESISTANCE_TO_TURNING",
  "ABILITY_VULNERABILITY_TO_ENERGY",
  "ABILITY_IMMUNITY_DISEASE",
  "ABILITY_ANIMAL_COMPANION",
  "ABILITY_WOODLAND_STRIDE",
  "ABILITY_SENSE_TRAPS",
  "ABILITY_UNCANNY_DODGE",
  "ABILITY_IMPROVED_UNCANNY_DODGE",
  "ABILITY_CRIPPLING_STRIKE",
  "ABILITY_DEFENSIVE_ROLL",
  "ABILITY_OPPORTUNIST",
  "ABILITY_SKILL_MASTERY",
  "ABILITY_SLIPPERY_MIND",
  "ABILITY_BONUS_FEAT"
};

const RPG_Character_Ability_XMLTree_Type::value RPG_Character_Ability_XMLTree_Type::
_xsd_RPG_Character_Ability_XMLTree_Type_indexes_[79] =
{
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ACID_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ALTERNATE_FORM,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ANIMAL_COMPANION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ANTIMAGIC,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_BLINDSENSE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_BLINDSIGHT,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_BONUS_FEAT,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_BREATH_WEAPON,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_CHANGE_SHAPE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_CHARM,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_COMPULSION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_CONSTRICT,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_CORROSIVE_SLIME,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_CRIPPLING_STRIKE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_DARKVISION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_DEATH_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_DEATH_THROES,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_DEFENSIVE_ROLL,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_DISEASE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ENERGY_DRAIN,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ENTANGLE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_ETHEREALNESS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_EVASION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_FAST_HEALING,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_FEAR,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_FLAMING_BODY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_GASEOUS_FORM,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_GAZE_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMMUNITY_COLD,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMMUNITY_DISEASE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMMUNITY_FIRE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMMUNITY_POISON,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMMUNITY_SPELL,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMPROVED_EVASION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMPROVED_GRAB,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_IMPROVED_UNCANNY_DODGE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_INCORPOREALITY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_INVISIBILITY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_LEAP_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_LEVEL_LOSS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_LOWLIGHT_VISION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_MANUFACTURED_WEAPONS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_MOVEMENT_MODES,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_NATURAL_WEAPONS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_NONABILITIES,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_OPPORTUNIST,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_PARALYZE_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_POISON_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_POLYMORPH,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_POUNCE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_POWERFUL_CHARGE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_PSIONICS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RAKE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RAY_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_REGENERATION,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_REND_ARMOR,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RESISTANCE_TO_DAMAGE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RESISTANCE_TO_ENERGY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RESISTANCE_TO_SPELL,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_RESISTANCE_TO_TURNING,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SCENT,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SCORE_LOSS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SENSE_TRAPS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SKILL_MASTERY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SLIPPERY_MIND,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SNEAK_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SONIC_ATTACK,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SPELLS,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SPORES,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_STENCH,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SUMMON,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_SWALLOW_WHOLE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_TELEPATHY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_THROW_WEB,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_TRAMPLE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_TREMOR_SENSE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_UNCANNY_DODGE,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_VULNERABILITY_TO_ENERGY,
  ::RPG_Character_Ability_XMLTree_Type::ABILITY_WOODLAND_STRIDE
};

// RPG_Character_Feat_XMLTree_Type
//

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_Feat_XMLTree_Type_convert ();
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_Feat_XMLTree_Type_convert ();
}

RPG_Character_Feat_XMLTree_Type::
RPG_Character_Feat_XMLTree_Type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_Feat_XMLTree_Type_convert ();
}

RPG_Character_Feat_XMLTree_Type* RPG_Character_Feat_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Feat_XMLTree_Type (*this, f, c);
}

RPG_Character_Feat_XMLTree_Type::value RPG_Character_Feat_XMLTree_Type::
_xsd_RPG_Character_Feat_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_Feat_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_Feat_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_Feat_XMLTree_Type_indexes_ + 122,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_Feat_XMLTree_Type_indexes_ + 122 || _xsd_RPG_Character_Feat_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_Feat_XMLTree_Type::
_xsd_RPG_Character_Feat_XMLTree_Type_literals_[122] =
{
  "FEAT_BLIND_FIGHT",
  "FEAT_COMBAT_EXPERTISE",
  "FEAT_IMPROVED_DISARM",
  "FEAT_IMPROVED_FEINT",
  "FEAT_IMPROVED_TRIP",
  "FEAT_WHIRLWIND_ATTACK",
  "FEAT_COMBAT_REFLEXES",
  "FEAT_DODGE",
  "FEAT_MOBILITY",
  "FEAT_SPRING_ATTACK",
  "FEAT_PROFICIENCY_EXOTIC_WEAPONS",
  "FEAT_IMPROVED_CRITICAL",
  "FEAT_IMPROVED_INITIATIVE",
  "FEAT_IMPROVED_SHIELD_BASH",
  "FEAT_IMPROVED_UNARMED_STRIKE",
  "FEAT_DEFLECT_ARROWS",
  "FEAT_IMPROVED_GRAPPLE",
  "FEAT_SNATCH_ARROWS",
  "FEAT_STUNNING_FIST",
  "FEAT_MOUNTED_COMBAT",
  "FEAT_MOUNTED_ARCHERY",
  "FEAT_RIDE_BY_ATTACK",
  "FEAT_SPIRITED_CHARGE",
  "FEAT_TRAMPLE",
  "FEAT_POINT_BLANK_SHOT",
  "FEAT_FAR_SHOT",
  "FEAT_PRECISE_SHOT",
  "FEAT_RAPID_SHOT",
  "FEAT_MANY_SHOT",
  "FEAT_SHOT_ON_THE_RUN",
  "FEAT_IMPROVED_PRECISE_SHOT",
  "FEAT_POWER_ATTACK",
  "FEAT_CLEAVE",
  "FEAT_GREAT_CLEAVE",
  "FEAT_IMPROVED_BULL_RUSH",
  "FEAT_IMPROVED_OVERRUN",
  "FEAT_IMPROVED_SUNDER",
  "FEAT_QUICK_DRAW",
  "FEAT_RAPID_RELOAD",
  "FEAT_TWO_WEAPON_FIGHTING",
  "FEAT_TWO_WEAPON_DEFENSE",
  "FEAT_IMPROVED_TWO_WEAPON_FIGHTING",
  "FEAT_GREATER_TWO_WEAPON_FIGHTING",
  "FEAT_WEAPON_FINESSE",
  "FEAT_WEAPON_FOCUS",
  "FEAT_WEAPON_SPECIALIZATION",
  "FEAT_GREATER_WEAPON_FOCUS",
  "FEAT_GREATER_WEAPON_SPECIALIZATION",
  "FEAT_BREW_POTION",
  "FEAT_CRAFT_MAGIC_ARMS_AND_ARMOR",
  "FEAT_CRAFT_ROD",
  "FEAT_CRAFT_STAFF",
  "FEAT_CRAFT_WAND",
  "FEAT_CRAFT_WONDROUS_ITEM",
  "FEAT_FORGE_RING",
  "FEAT_SCRIBE_SCROLL",
  "FEAT_EMPOWER_SPELL",
  "FEAT_ENLARGE_SPELL",
  "FEAT_EXTEND_SPELL",
  "FEAT_HEIGHTEN_SPELL",
  "FEAT_MAXIMIZE_SPELL",
  "FEAT_QUICKEN_SPELL",
  "FEAT_SILENT_SPELL",
  "FEAT_WIDEN_SPELL",
  "FEAT_ACROBATIC",
  "FEAT_AGILE",
  "FEAT_ALERTNESS",
  "FEAT_ANIMAL_AFFINITY",
  "FEAT_PROFICIENCY_ARMOR_LIGHT",
  "FEAT_PROFICIENCY_ARMOR_MEDIUM",
  "FEAT_PROFICIENCY_ARMOR_HEAVY",
  "FEAT_ATHLETIC",
  "FEAT_AUGMENT_SUMMONING",
  "FEAT_COMBAT_CASTING",
  "FEAT_DECEITFUL",
  "FEAT_DEFT_HANDS",
  "FEAT_DILIGENT",
  "FEAT_ENDURANCE",
  "FEAT_DIE_HARD",
  "FEAT_ESCHEW_MATERIALS",
  "FEAT_EXTRA_TURNING",
  "FEAT_GREAT_FORTITUDE",
  "FEAT_IMPROVED_COUNTERSPELL",
  "FEAT_IMPROVED_FAMILIAR",
  "FEAT_IMPROVED_TURNING",
  "FEAT_INVESTIGATOR",
  "FEAT_IRON_WILL",
  "FEAT_LEADERSHIP",
  "FEAT_LIGHTNING_REFLEXES",
  "FEAT_MAGICAL_APTITUDE",
  "FEAT_PROFICIENCY_MARTIAL_WEAPONS",
  "FEAT_NATURAL_SPELL",
  "FEAT_NEGOTIATOR",
  "FEAT_NIMBLE_FINGERS",
  "FEAT_PERSUASIVE",
  "FEAT_RUN",
  "FEAT_SELF_SUFFICIENT",
  "FEAT_PROFICIENCY_SHIELD",
  "FEAT_PROFICIENCY_TOWER_SHIELD",
  "FEAT_PROFICIENCY_SIMPLE_WEAPONS",
  "FEAT_SKILL_FOCUS",
  "FEAT_SPELL_FOCUS",
  "FEAT_GREATER_SPELL_FOCUS",
  "FEAT_SPELL_MASTERY",
  "FEAT_SPELL_PENETRATION",
  "FEAT_GREATER_SPELL_PENETRATION",
  "FEAT_STEALTHY",
  "FEAT_TOUGHNESS",
  "FEAT_TRACK",
  "FEAT_ABILITY_FOCUS",
  "FEAT_AWESOME_BLOW",
  "FEAT_CRAFT_CONSTRUCT",
  "FEAT_EMPOWER_SPELLLIKE_ABILITY",
  "FEAT_FLYBY_ATTACK",
  "FEAT_HOVER",
  "FEAT_IMPROVED_NATURAL_ARMOR",
  "FEAT_IMPROVED_NATURAL_ATTACK",
  "FEAT_MULTI_ATTACK",
  "FEAT_MULTIWEAPON_FIGHTING",
  "FEAT_QUICKEN_SPELLLIKE_ABILITY",
  "FEAT_SNATCH",
  "FEAT_WINGOVER"
};

const RPG_Character_Feat_XMLTree_Type::value RPG_Character_Feat_XMLTree_Type::
_xsd_RPG_Character_Feat_XMLTree_Type_indexes_[122] =
{
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ABILITY_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ACROBATIC,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_AGILE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ALERTNESS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ANIMAL_AFFINITY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ATHLETIC,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_AUGMENT_SUMMONING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_AWESOME_BLOW,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_BLIND_FIGHT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_BREW_POTION,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CLEAVE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_COMBAT_CASTING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_COMBAT_EXPERTISE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_COMBAT_REFLEXES,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_CONSTRUCT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_MAGIC_ARMS_AND_ARMOR,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_ROD,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_STAFF,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_WAND,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_CRAFT_WONDROUS_ITEM,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DECEITFUL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DEFLECT_ARROWS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DEFT_HANDS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DIE_HARD,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DILIGENT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_DODGE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_EMPOWER_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_EMPOWER_SPELLLIKE_ABILITY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ENDURANCE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ENLARGE_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_ESCHEW_MATERIALS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_EXTEND_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_EXTRA_TURNING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_FAR_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_FLYBY_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_FORGE_RING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREATER_SPELL_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREATER_SPELL_PENETRATION,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREATER_TWO_WEAPON_FIGHTING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREATER_WEAPON_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREATER_WEAPON_SPECIALIZATION,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREAT_CLEAVE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_GREAT_FORTITUDE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_HEIGHTEN_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_HOVER,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_BULL_RUSH,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_COUNTERSPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_CRITICAL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_DISARM,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_FAMILIAR,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_FEINT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_GRAPPLE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_INITIATIVE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_NATURAL_ARMOR,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_NATURAL_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_OVERRUN,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_PRECISE_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_SHIELD_BASH,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_SUNDER,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_TRIP,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_TURNING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_TWO_WEAPON_FIGHTING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IMPROVED_UNARMED_STRIKE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_INVESTIGATOR,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_IRON_WILL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_LEADERSHIP,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_LIGHTNING_REFLEXES,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MAGICAL_APTITUDE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MANY_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MAXIMIZE_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MOBILITY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MOUNTED_ARCHERY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MOUNTED_COMBAT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MULTIWEAPON_FIGHTING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_MULTI_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_NATURAL_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_NEGOTIATOR,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_NIMBLE_FINGERS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PERSUASIVE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_POINT_BLANK_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_POWER_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PRECISE_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_ARMOR_HEAVY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_ARMOR_LIGHT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_ARMOR_MEDIUM,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_EXOTIC_WEAPONS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_MARTIAL_WEAPONS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_SHIELD,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_SIMPLE_WEAPONS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_PROFICIENCY_TOWER_SHIELD,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_QUICKEN_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_QUICKEN_SPELLLIKE_ABILITY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_QUICK_DRAW,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_RAPID_RELOAD,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_RAPID_SHOT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_RIDE_BY_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_RUN,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SCRIBE_SCROLL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SELF_SUFFICIENT,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SHOT_ON_THE_RUN,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SILENT_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SKILL_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SNATCH,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SNATCH_ARROWS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SPELL_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SPELL_MASTERY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SPELL_PENETRATION,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SPIRITED_CHARGE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_SPRING_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_STEALTHY,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_STUNNING_FIST,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_TOUGHNESS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_TRACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_TRAMPLE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_TWO_WEAPON_DEFENSE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_TWO_WEAPON_FIGHTING,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WEAPON_FINESSE,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WEAPON_FOCUS,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WEAPON_SPECIALIZATION,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WHIRLWIND_ATTACK,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WIDEN_SPELL,
  ::RPG_Character_Feat_XMLTree_Type::FEAT_WINGOVER
};

// RPG_Character_Feats_XMLTree_Type
//

RPG_Character_Feats_XMLTree_Type::
RPG_Character_Feats_XMLTree_Type ()
: ::xml_schema::type (),
  feat_ (this)
{
}

RPG_Character_Feats_XMLTree_Type::
RPG_Character_Feats_XMLTree_Type (const RPG_Character_Feats_XMLTree_Type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  feat_ (x.feat_, f, this)
{
}

RPG_Character_Feats_XMLTree_Type::
RPG_Character_Feats_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  feat_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_Feats_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // feat
    //
    if (n.name () == "feat" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< feat_type > r (
        feat_traits::create (i, f, this));

      this->feat_.push_back (r);
      continue;
    }

    break;
  }
}

RPG_Character_Feats_XMLTree_Type* RPG_Character_Feats_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Feats_XMLTree_Type (*this, f, c);
}

RPG_Character_Feats_XMLTree_Type& RPG_Character_Feats_XMLTree_Type::
operator= (const RPG_Character_Feats_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->feat_ = x.feat_;
  }

  return *this;
}

RPG_Character_Feats_XMLTree_Type::
~RPG_Character_Feats_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_Feats_XMLTree_Type& x, const RPG_Character_Feats_XMLTree_Type& y)
{
  if (!(x.feat () == y.feat ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_Feats_XMLTree_Type& x, const RPG_Character_Feats_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_AlignmentCivic_XMLTree_Type
//

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentCivic_XMLTree_Type::
RPG_Character_AlignmentCivic_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentCivic_XMLTree_Type* RPG_Character_AlignmentCivic_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_AlignmentCivic_XMLTree_Type (*this, f, c);
}

RPG_Character_AlignmentCivic_XMLTree_Type::value RPG_Character_AlignmentCivic_XMLTree_Type::
_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_indexes_ + 4 || _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_AlignmentCivic_XMLTree_Type::
_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[4] =
{
  "ALIGNMENTCIVIC_CHAOTIC",
  "ALIGNMENTCIVIC_LAWFUL",
  "ALIGNMENTCIVIC_NEUTRAL",
  "ALIGNMENTCIVIC_ANY"
};

const RPG_Character_AlignmentCivic_XMLTree_Type::value RPG_Character_AlignmentCivic_XMLTree_Type::
_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_indexes_[4] =
{
  ::RPG_Character_AlignmentCivic_XMLTree_Type::ALIGNMENTCIVIC_ANY,
  ::RPG_Character_AlignmentCivic_XMLTree_Type::ALIGNMENTCIVIC_CHAOTIC,
  ::RPG_Character_AlignmentCivic_XMLTree_Type::ALIGNMENTCIVIC_LAWFUL,
  ::RPG_Character_AlignmentCivic_XMLTree_Type::ALIGNMENTCIVIC_NEUTRAL
};

// RPG_Character_AlignmentEthic_XMLTree_Type
//

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentEthic_XMLTree_Type::
RPG_Character_AlignmentEthic_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert ();
}

RPG_Character_AlignmentEthic_XMLTree_Type* RPG_Character_AlignmentEthic_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_AlignmentEthic_XMLTree_Type (*this, f, c);
}

RPG_Character_AlignmentEthic_XMLTree_Type::value RPG_Character_AlignmentEthic_XMLTree_Type::
_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_indexes_ + 4 || _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_AlignmentEthic_XMLTree_Type::
_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[4] =
{
  "ALIGNMENTETHIC_EVIL",
  "ALIGNMENTETHIC_GOOD",
  "ALIGNMENTETHIC_NEUTRAL",
  "ALIGNMENTETHIC_ANY"
};

const RPG_Character_AlignmentEthic_XMLTree_Type::value RPG_Character_AlignmentEthic_XMLTree_Type::
_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_indexes_[4] =
{
  ::RPG_Character_AlignmentEthic_XMLTree_Type::ALIGNMENTETHIC_ANY,
  ::RPG_Character_AlignmentEthic_XMLTree_Type::ALIGNMENTETHIC_EVIL,
  ::RPG_Character_AlignmentEthic_XMLTree_Type::ALIGNMENTETHIC_GOOD,
  ::RPG_Character_AlignmentEthic_XMLTree_Type::ALIGNMENTETHIC_NEUTRAL
};

// RPG_Character_Alignment_XMLTree_Type
//

RPG_Character_Alignment_XMLTree_Type::
RPG_Character_Alignment_XMLTree_Type (const civic_type& civic,
                                      const ethic_type& ethic)
: ::xml_schema::type (),
  civic_ (civic, this),
  ethic_ (ethic, this)
{
}

RPG_Character_Alignment_XMLTree_Type::
RPG_Character_Alignment_XMLTree_Type (const RPG_Character_Alignment_XMLTree_Type& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  civic_ (x.civic_, f, this),
  ethic_ (x.ethic_, f, this)
{
}

RPG_Character_Alignment_XMLTree_Type::
RPG_Character_Alignment_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  civic_ (this),
  ethic_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_Alignment_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // civic
    //
    if (n.name () == "civic" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< civic_type > r (
        civic_traits::create (i, f, this));

      if (!civic_.present ())
      {
        this->civic_.set (r);
        continue;
      }
    }

    // ethic
    //
    if (n.name () == "ethic" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< ethic_type > r (
        ethic_traits::create (i, f, this));

      if (!ethic_.present ())
      {
        this->ethic_.set (r);
        continue;
      }
    }

    break;
  }

  if (!civic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "civic",
      "urn:rpg");
  }

  if (!ethic_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ethic",
      "urn:rpg");
  }
}

RPG_Character_Alignment_XMLTree_Type* RPG_Character_Alignment_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Alignment_XMLTree_Type (*this, f, c);
}

RPG_Character_Alignment_XMLTree_Type& RPG_Character_Alignment_XMLTree_Type::
operator= (const RPG_Character_Alignment_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->civic_ = x.civic_;
    this->ethic_ = x.ethic_;
  }

  return *this;
}

RPG_Character_Alignment_XMLTree_Type::
~RPG_Character_Alignment_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_Alignment_XMLTree_Type& x, const RPG_Character_Alignment_XMLTree_Type& y)
{
  if (!(x.civic () == y.civic ()))
    return false;

  if (!(x.ethic () == y.ethic ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_Alignment_XMLTree_Type& x, const RPG_Character_Alignment_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Character_EquipmentSlot_XMLTree_Type
//

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert ();
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert ();
}

RPG_Character_EquipmentSlot_XMLTree_Type::
RPG_Character_EquipmentSlot_XMLTree_Type (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert ();
}

RPG_Character_EquipmentSlot_XMLTree_Type* RPG_Character_EquipmentSlot_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_EquipmentSlot_XMLTree_Type (*this, f, c);
}

RPG_Character_EquipmentSlot_XMLTree_Type::value RPG_Character_EquipmentSlot_XMLTree_Type::
_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_indexes_ + 16,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_indexes_ + 16 || _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_EquipmentSlot_XMLTree_Type::
_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[16] =
{
  "EQUIPMENTSLOT_BODY",
  "EQUIPMENTSLOT_EYES",
  "EQUIPMENTSLOT_FEET",
  "EQUIPMENTSLOT_FINGER",
  "EQUIPMENTSLOT_HAND_LEFT",
  "EQUIPMENTSLOT_HAND_RIGHT",
  "EQUIPMENTSLOT_HANDS",
  "EQUIPMENTSLOT_HEAD",
  "EQUIPMENTSLOT_NECK",
  "EQUIPMENTSLOT_SHOULDERS",
  "EQUIPMENTSLOT_TORSO",
  "EQUIPMENTSLOT_WAIST",
  "EQUIPMENTSLOT_WRIST_LEFT",
  "EQUIPMENTSLOT_WRIST_RIGHT",
  "EQUIPMENTSLOT_WRISTS",
  "EQUIPMENTSLOT_ANY"
};

const RPG_Character_EquipmentSlot_XMLTree_Type::value RPG_Character_EquipmentSlot_XMLTree_Type::
_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_indexes_[16] =
{
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_ANY,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_BODY,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_EYES,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_FEET,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_FINGER,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_HANDS,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_HAND_LEFT,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_HAND_RIGHT,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_HEAD,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_NECK,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_SHOULDERS,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_TORSO,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_WAIST,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_WRISTS,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_WRIST_LEFT,
  ::RPG_Character_EquipmentSlot_XMLTree_Type::EQUIPMENTSLOT_WRIST_RIGHT
};

// RPG_Character_OffHand_XMLTree_Type
//

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_OffHand_XMLTree_Type_convert ();
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_OffHand_XMLTree_Type_convert ();
}

RPG_Character_OffHand_XMLTree_Type::
RPG_Character_OffHand_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_OffHand_XMLTree_Type_convert ();
}

RPG_Character_OffHand_XMLTree_Type* RPG_Character_OffHand_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_OffHand_XMLTree_Type (*this, f, c);
}

RPG_Character_OffHand_XMLTree_Type::value RPG_Character_OffHand_XMLTree_Type::
_xsd_RPG_Character_OffHand_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_OffHand_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_OffHand_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_OffHand_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_OffHand_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Character_OffHand_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_OffHand_XMLTree_Type::
_xsd_RPG_Character_OffHand_XMLTree_Type_literals_[3] =
{
  "OFFHAND_NONE",
  "OFFHAND_LEFT",
  "OFFHAND_RIGHT"
};

const RPG_Character_OffHand_XMLTree_Type::value RPG_Character_OffHand_XMLTree_Type::
_xsd_RPG_Character_OffHand_XMLTree_Type_indexes_[3] =
{
  ::RPG_Character_OffHand_XMLTree_Type::OFFHAND_LEFT,
  ::RPG_Character_OffHand_XMLTree_Type::OFFHAND_NONE,
  ::RPG_Character_OffHand_XMLTree_Type::OFFHAND_RIGHT
};

// RPG_Character_Encumbrance_XMLTree_Type
//

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_Encumbrance_XMLTree_Type_convert ();
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_Encumbrance_XMLTree_Type_convert ();
}

RPG_Character_Encumbrance_XMLTree_Type::
RPG_Character_Encumbrance_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_Encumbrance_XMLTree_Type_convert ();
}

RPG_Character_Encumbrance_XMLTree_Type* RPG_Character_Encumbrance_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Encumbrance_XMLTree_Type (*this, f, c);
}

RPG_Character_Encumbrance_XMLTree_Type::value RPG_Character_Encumbrance_XMLTree_Type::
_xsd_RPG_Character_Encumbrance_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_Encumbrance_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_Encumbrance_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_Encumbrance_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_Encumbrance_XMLTree_Type::
_xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_[3] =
{
  "LOAD_LIGHT",
  "LOAD_MEDIUM",
  "LOAD_HEAVY"
};

const RPG_Character_Encumbrance_XMLTree_Type::value RPG_Character_Encumbrance_XMLTree_Type::
_xsd_RPG_Character_Encumbrance_XMLTree_Type_indexes_[3] =
{
  ::RPG_Character_Encumbrance_XMLTree_Type::LOAD_HEAVY,
  ::RPG_Character_Encumbrance_XMLTree_Type::LOAD_LIGHT,
  ::RPG_Character_Encumbrance_XMLTree_Type::LOAD_MEDIUM
};

// RPG_Character_CheckTypeUnion_XMLTree_Type
//

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Character_CheckTypeUnion_XMLTree_Type::
RPG_Character_CheckTypeUnion_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Character_CheckTypeUnion_XMLTree_Type* RPG_Character_CheckTypeUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_CheckTypeUnion_XMLTree_Type (*this, f, c);
}

RPG_Character_CheckTypeUnion_XMLTree_Type::value RPG_Character_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_indexes_ + 63,
                    *this,
                    c));

  if (i == _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_indexes_ + 63 || _xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Character_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_[63] =
{
  "ATTRIBUTE_CHARISMA",
  "ATTRIBUTE_CONSTITUTION",
  "ATTRIBUTE_DEXTERITY",
  "ATTRIBUTE_INTELLIGENCE",
  "ATTRIBUTE_STRENGTH",
  "ATTRIBUTE_WISDOM",
  "ATTRIBUTE_ANY",
  "SKILL_APPRAISE",
  "SKILL_BALANCE",
  "SKILL_BLUFF",
  "SKILL_CLIMB",
  "SKILL_CONCENTRATION",
  "SKILL_CRAFT_ANY",
  "SKILL_CRAFT_ALL",
  "SKILL_CRAFT_ALCHEMY",
  "SKILL_CRAFT_FLETCHER",
  "SKILL_CRAFT_BOWYER",
  "SKILL_CRAFT_SMITH_ARMOR",
  "SKILL_CRAFT_SMITH_BLACK",
  "SKILL_CRAFT_SMITH_WEAPON",
  "SKILL_CRAFT_TRAP",
  "SKILL_CRAFT_OTHER",
  "SKILL_DECIPHER_SCRIPT",
  "SKILL_DIPLOMACY",
  "SKILL_DISABLE_DEVICE",
  "SKILL_DISGUISE",
  "SKILL_ESCAPE_ARTIST",
  "SKILL_FORGERY",
  "SKILL_GATHER_INFORMATION",
  "SKILL_HANDLE_ANIMAL",
  "SKILL_HEAL",
  "SKILL_HIDE",
  "SKILL_INTIMIDATE",
  "SKILL_JUMP",
  "SKILL_KNOWLEDGE_ANY",
  "SKILL_KNOWLEDGE_ALL",
  "SKILL_KNOWLEDGE_ARCANA",
  "SKILL_KNOWLEDGE_ARCHITECTURE_ENGINEERING",
  "SKILL_KNOWLEDGE_DUNGEONS",
  "SKILL_KNOWLEDGE_GEOGRAPHY",
  "SKILL_KNOWLEDGE_HISTORY",
  "SKILL_KNOWLEDGE_LOCAL",
  "SKILL_KNOWLEDGE_NATURE",
  "SKILL_KNOWLEDGE_NOBILITY_ROYALTY",
  "SKILL_KNOWLEDGE_RELIGION",
  "SKILL_KNOWLEDGE_PLANES",
  "SKILL_LISTEN",
  "SKILL_MOVE_SILENTLY",
  "SKILL_OPEN_LOCK",
  "SKILL_PERFORM",
  "SKILL_PROFESSION",
  "SKILL_RIDE",
  "SKILL_SEARCH",
  "SKILL_SENSE_MOTIVE",
  "SKILL_SLEIGHT_OF_HAND",
  "SKILL_SPEAK_LANGUAGE",
  "SKILL_SPELLCRAFT",
  "SKILL_SPOT",
  "SKILL_SURVIVAL",
  "SKILL_SWIM",
  "SKILL_TUMBLE",
  "SKILL_USE_MAGIC_DEVICE",
  "SKILL_USE_ROPE"
};

const RPG_Character_CheckTypeUnion_XMLTree_Type::value RPG_Character_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_indexes_[63] =
{
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_ANY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_CHARISMA,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_CONSTITUTION,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_DEXTERITY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_INTELLIGENCE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_STRENGTH,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_WISDOM,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_APPRAISE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_BALANCE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_BLUFF,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CLIMB,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CONCENTRATION,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ALCHEMY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ALL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ANY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_BOWYER,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_FLETCHER,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_OTHER,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_ARMOR,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_BLACK,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_WEAPON,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_TRAP,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_DECIPHER_SCRIPT,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_DIPLOMACY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_DISABLE_DEVICE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_DISGUISE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_ESCAPE_ARTIST,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_FORGERY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_GATHER_INFORMATION,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_HANDLE_ANIMAL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_HEAL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_HIDE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_INTIMIDATE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_JUMP,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ALL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ANY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ARCANA,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ARCHITECTURE_ENGINEERING,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_DUNGEONS,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_GEOGRAPHY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_HISTORY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_LOCAL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_NATURE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_NOBILITY_ROYALTY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_PLANES,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_RELIGION,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_LISTEN,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_MOVE_SILENTLY,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_OPEN_LOCK,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_PERFORM,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_PROFESSION,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_RIDE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SEARCH,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SENSE_MOTIVE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SLEIGHT_OF_HAND,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SPEAK_LANGUAGE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SPELLCRAFT,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SPOT,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SURVIVAL,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_SWIM,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_TUMBLE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_USE_MAGIC_DEVICE,
  ::RPG_Character_CheckTypeUnion_XMLTree_Type::SKILL_USE_ROPE
};

// RPG_Character_Check_XMLTree_Type
//

RPG_Character_Check_XMLTree_Type::
RPG_Character_Check_XMLTree_Type (const type_type& type,
                                  const difficultyClass_type& difficultyClass)
: ::xml_schema::type (),
  type_ (type, this),
  difficultyClass_ (difficultyClass, this)
{
}

RPG_Character_Check_XMLTree_Type::
RPG_Character_Check_XMLTree_Type (const RPG_Character_Check_XMLTree_Type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  difficultyClass_ (x.difficultyClass_, f, this)
{
}

RPG_Character_Check_XMLTree_Type::
RPG_Character_Check_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  difficultyClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Character_Check_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // difficultyClass
    //
    if (n.name () == "difficultyClass" && n.namespace_ () == "urn:rpg")
    {
      if (!difficultyClass_.present ())
      {
        this->difficultyClass_.set (difficultyClass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!difficultyClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "difficultyClass",
      "urn:rpg");
  }
}

RPG_Character_Check_XMLTree_Type* RPG_Character_Check_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Character_Check_XMLTree_Type (*this, f, c);
}

RPG_Character_Check_XMLTree_Type& RPG_Character_Check_XMLTree_Type::
operator= (const RPG_Character_Check_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->difficultyClass_ = x.difficultyClass_;
  }

  return *this;
}

RPG_Character_Check_XMLTree_Type::
~RPG_Character_Check_XMLTree_Type ()
{
}

bool
operator== (const RPG_Character_Check_XMLTree_Type& x, const RPG_Character_Check_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.difficultyClass () == y.difficultyClass ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Character_Check_XMLTree_Type& x, const RPG_Character_Check_XMLTree_Type& y)
{
  return !(x == y);
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_Gender_XMLTree_Type::value i)
{
  return o << RPG_Character_Gender_XMLTree_Type::_xsd_RPG_Character_Gender_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Gender_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_Race_XMLTree_Type::value i)
{
  return o << RPG_Character_Race_XMLTree_Type::_xsd_RPG_Character_Race_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Race_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_MetaClass_XMLTree_Type::value i)
{
  return o << RPG_Character_MetaClass_XMLTree_Type::_xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_MetaClass_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_ClassXML_XMLTree_Type& i)
{
  o << ::std::endl << "metaClass: " << i.metaClass ();
  for (RPG_Character_ClassXML_XMLTree_Type::subClass_const_iterator
       b (i.subClass ().begin ()), e (i.subClass ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "subClass: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Attributes_XMLTree_Type& i)
{
  o << ::std::endl << "strength: " << i.strength ();
  o << ::std::endl << "dexterity: " << i.dexterity ();
  o << ::std::endl << "constitution: " << i.constitution ();
  o << ::std::endl << "intelligence: " << i.intelligence ();
  o << ::std::endl << "wisdom: " << i.wisdom ();
  o << ::std::endl << "charisma: " << i.charisma ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_SkillValue_XMLTree_Type& i)
{
  o << ::std::endl << "skill: " << i.skill ();
  o << ::std::endl << "rank: " << i.rank ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Skills_XMLTree_Type& i)
{
  for (RPG_Character_Skills_XMLTree_Type::skill_const_iterator
       b (i.skill ().begin ()), e (i.skill ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "skill: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_Ability_XMLTree_Type::value i)
{
  return o << RPG_Character_Ability_XMLTree_Type::_xsd_RPG_Character_Ability_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Ability_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_Feat_XMLTree_Type::value i)
{
  return o << RPG_Character_Feat_XMLTree_Type::_xsd_RPG_Character_Feat_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Feat_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Feats_XMLTree_Type& i)
{
  for (RPG_Character_Feats_XMLTree_Type::feat_const_iterator
       b (i.feat ().begin ()), e (i.feat ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "feat: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_AlignmentCivic_XMLTree_Type::value i)
{
  return o << RPG_Character_AlignmentCivic_XMLTree_Type::_xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_AlignmentCivic_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_AlignmentEthic_XMLTree_Type::value i)
{
  return o << RPG_Character_AlignmentEthic_XMLTree_Type::_xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_AlignmentEthic_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Alignment_XMLTree_Type& i)
{
  o << ::std::endl << "civic: " << i.civic ();
  o << ::std::endl << "ethic: " << i.ethic ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_EquipmentSlot_XMLTree_Type::value i)
{
  return o << RPG_Character_EquipmentSlot_XMLTree_Type::_xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_EquipmentSlot_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_OffHand_XMLTree_Type::value i)
{
  return o << RPG_Character_OffHand_XMLTree_Type::_xsd_RPG_Character_OffHand_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_OffHand_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_Encumbrance_XMLTree_Type::value i)
{
  return o << RPG_Character_Encumbrance_XMLTree_Type::_xsd_RPG_Character_Encumbrance_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Encumbrance_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Character_CheckTypeUnion_XMLTree_Type::value i)
{
  return o << RPG_Character_CheckTypeUnion_XMLTree_Type::_xsd_RPG_Character_CheckTypeUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_CheckTypeUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Character_Check_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "difficultyClass: " << i.difficultyClass ();
  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Gender_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_Gender_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_Gender_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Race_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_Race_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_Race_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_MetaClass_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_MetaClass_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_MetaClass_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_ClassXML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // metaClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "metaClass",
        "urn:rpg",
        e));

    s << i.metaClass ();
  }

  // subClass
  //
  for (RPG_Character_ClassXML_XMLTree_Type::subClass_const_iterator
       b (i.subClass ().begin ()), n (i.subClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subClass",
        "urn:rpg",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Attributes_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // strength
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "strength",
        "urn:rpg",
        e));

    s << i.strength ();
  }

  // dexterity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dexterity",
        "urn:rpg",
        e));

    s << i.dexterity ();
  }

  // constitution
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "constitution",
        "urn:rpg",
        e));

    s << i.constitution ();
  }

  // intelligence
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "intelligence",
        "urn:rpg",
        e));

    s << i.intelligence ();
  }

  // wisdom
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "wisdom",
        "urn:rpg",
        e));

    s << i.wisdom ();
  }

  // charisma
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "charisma",
        "urn:rpg",
        e));

    s << i.charisma ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_SkillValue_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // skill
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "skill",
        "urn:rpg",
        e));

    s << i.skill ();
  }

  // rank
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rank",
        "urn:rpg",
        e));

    s << i.rank ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Skills_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // skill
  //
  for (RPG_Character_Skills_XMLTree_Type::skill_const_iterator
       b (i.skill ().begin ()), n (i.skill ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "skill",
        "urn:rpg",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Ability_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_Ability_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_Ability_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Feat_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_Feat_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_Feat_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Feats_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // feat
  //
  for (RPG_Character_Feats_XMLTree_Type::feat_const_iterator
       b (i.feat ().begin ()), n (i.feat ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "feat",
        "urn:rpg",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_AlignmentCivic_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_AlignmentCivic_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_AlignmentCivic_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_AlignmentEthic_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_AlignmentEthic_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_AlignmentEthic_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Alignment_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // civic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "civic",
        "urn:rpg",
        e));

    s << i.civic ();
  }

  // ethic
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ethic",
        "urn:rpg",
        e));

    s << i.ethic ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_EquipmentSlot_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_EquipmentSlot_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_EquipmentSlot_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_OffHand_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_OffHand_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_OffHand_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Encumbrance_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_Encumbrance_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_Encumbrance_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_CheckTypeUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Character_CheckTypeUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Character_CheckTypeUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Character_Check_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // difficultyClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "difficultyClass",
        "urn:rpg",
        e));

    s << i.difficultyClass ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

