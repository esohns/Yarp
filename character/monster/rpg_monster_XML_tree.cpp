// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
#include "stdafx.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpg_monster_XML_tree.h"

// RPG_Monster_Size_XMLTree_Type
//

const RPG_Monster_Size_XMLTree_Type::size_type& RPG_Monster_Size_XMLTree_Type::
size () const
{
  return this->size_.get ();
}

RPG_Monster_Size_XMLTree_Type::size_type& RPG_Monster_Size_XMLTree_Type::
size ()
{
  return this->size_.get ();
}

void RPG_Monster_Size_XMLTree_Type::
size (const size_type& x)
{
  this->size_.set (x);
}

void RPG_Monster_Size_XMLTree_Type::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const RPG_Monster_Size_XMLTree_Type::isTall_type& RPG_Monster_Size_XMLTree_Type::
isTall () const
{
  return this->isTall_.get ();
}

RPG_Monster_Size_XMLTree_Type::isTall_type& RPG_Monster_Size_XMLTree_Type::
isTall ()
{
  return this->isTall_.get ();
}

void RPG_Monster_Size_XMLTree_Type::
isTall (const isTall_type& x)
{
  this->isTall_.set (x);
}

RPG_Monster_Size_XMLTree_Type::isTall_type RPG_Monster_Size_XMLTree_Type::
isTall_default_value ()
{
  return isTall_type (true);
}


// RPG_Monster_NaturalArmorClass_XMLTree_Type
//

const RPG_Monster_NaturalArmorClass_XMLTree_Type::normal_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
normal () const
{
  return this->normal_.get ();
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::normal_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
normal ()
{
  return this->normal_.get ();
}

void RPG_Monster_NaturalArmorClass_XMLTree_Type::
normal (const normal_type& x)
{
  this->normal_.set (x);
}

const RPG_Monster_NaturalArmorClass_XMLTree_Type::touch_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
touch () const
{
  return this->touch_.get ();
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::touch_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
touch ()
{
  return this->touch_.get ();
}

void RPG_Monster_NaturalArmorClass_XMLTree_Type::
touch (const touch_type& x)
{
  this->touch_.set (x);
}

const RPG_Monster_NaturalArmorClass_XMLTree_Type::flatFooted_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
flatFooted () const
{
  return this->flatFooted_.get ();
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::flatFooted_type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
flatFooted ()
{
  return this->flatFooted_.get ();
}

void RPG_Monster_NaturalArmorClass_XMLTree_Type::
flatFooted (const flatFooted_type& x)
{
  this->flatFooted_.set (x);
}


// RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type
//

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_[v])
{
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& v,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Monster_SpecialBaseProperties_XMLTree_Type
//

const RPG_Monster_SpecialBaseProperties_XMLTree_Type::abilityClass_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
abilityClass () const
{
  return this->abilityClass_.get ();
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::abilityClass_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
abilityClass ()
{
  return this->abilityClass_.get ();
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
abilityClass (const abilityClass_type& x)
{
  this->abilityClass_.set (x);
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
abilityClass (::std::unique_ptr< abilityClass_type > x)
{
  this->abilityClass_.set (std::move (x));
}

const RPG_Monster_SpecialBaseProperties_XMLTree_Type::type_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::type_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const RPG_Monster_SpecialBaseProperties_XMLTree_Type::actionType_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
actionType () const
{
  return this->actionType_.get ();
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::actionType_type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
actionType ()
{
  return this->actionType_.get ();
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
actionType (const actionType_type& x)
{
  this->actionType_.set (x);
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
actionType (::std::unique_ptr< actionType_type > x)
{
  this->actionType_.set (std::move (x));
}

const RPG_Monster_SpecialBaseProperties_XMLTree_Type::usage_optional& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
usage () const
{
  return this->usage_;
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::usage_optional& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
usage ()
{
  return this->usage_;
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
usage (const usage_type& x)
{
  this->usage_.set (x);
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
usage (const usage_optional& x)
{
  this->usage_ = x;
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
usage (::std::unique_ptr< usage_type > x)
{
  this->usage_.set (std::move (x));
}


// RPG_Monster_NaturalWeapon_XMLTree_Type
//

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_[v])
{
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const RPG_Monster_NaturalWeapon_XMLTree_Type& v,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Monster_NaturalWeapon_XMLTree_Type& RPG_Monster_NaturalWeapon_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Monster_WeaponTypeUnion_XMLTree_Type
//

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_[v])
{
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const RPG_Monster_WeaponTypeUnion_XMLTree_Type& v,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type& RPG_Monster_WeaponTypeUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Monster_SpecialDefensePreCondition_XMLTree_Type
//

const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::weaponType_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
weaponType () const
{
  return this->weaponType_;
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::weaponType_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
weaponType ()
{
  return this->weaponType_;
}

void RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
weaponType (const weaponType_sequence& s)
{
  this->weaponType_ = s;
}

const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::ownCondition_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
ownCondition () const
{
  return this->ownCondition_;
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::ownCondition_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
ownCondition ()
{
  return this->ownCondition_;
}

void RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
ownCondition (const ownCondition_sequence& s)
{
  this->ownCondition_ = s;
}

const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
targetCondition () const
{
  return this->targetCondition_;
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
targetCondition ()
{
  return this->targetCondition_;
}

void RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
targetCondition (const targetCondition_sequence& s)
{
  this->targetCondition_ = s;
}

const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::isMagicalWeapon_type& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
isMagicalWeapon () const
{
  return this->isMagicalWeapon_.get ();
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::isMagicalWeapon_type& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
isMagicalWeapon ()
{
  return this->isMagicalWeapon_.get ();
}

void RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
isMagicalWeapon (const isMagicalWeapon_type& x)
{
  this->isMagicalWeapon_.set (x);
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::isMagicalWeapon_type RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
isMagicalWeapon_default_value ()
{
  return isMagicalWeapon_type (false);
}


// RPG_Monster_DefenseAction_XMLTree_Type
//

const RPG_Monster_DefenseAction_XMLTree_Type::preCondition_sequence& RPG_Monster_DefenseAction_XMLTree_Type::
preCondition () const
{
  return this->preCondition_;
}

RPG_Monster_DefenseAction_XMLTree_Type::preCondition_sequence& RPG_Monster_DefenseAction_XMLTree_Type::
preCondition ()
{
  return this->preCondition_;
}

void RPG_Monster_DefenseAction_XMLTree_Type::
preCondition (const preCondition_sequence& s)
{
  this->preCondition_ = s;
}

const RPG_Monster_DefenseAction_XMLTree_Type::damage_optional& RPG_Monster_DefenseAction_XMLTree_Type::
damage () const
{
  return this->damage_;
}

RPG_Monster_DefenseAction_XMLTree_Type::damage_optional& RPG_Monster_DefenseAction_XMLTree_Type::
damage ()
{
  return this->damage_;
}

void RPG_Monster_DefenseAction_XMLTree_Type::
damage (const damage_type& x)
{
  this->damage_.set (x);
}

void RPG_Monster_DefenseAction_XMLTree_Type::
damage (const damage_optional& x)
{
  this->damage_ = x;
}

void RPG_Monster_DefenseAction_XMLTree_Type::
damage (::std::unique_ptr< damage_type > x)
{
  this->damage_.set (std::move (x));
}

const RPG_Monster_DefenseAction_XMLTree_Type::ranged_optional& RPG_Monster_DefenseAction_XMLTree_Type::
ranged () const
{
  return this->ranged_;
}

RPG_Monster_DefenseAction_XMLTree_Type::ranged_optional& RPG_Monster_DefenseAction_XMLTree_Type::
ranged ()
{
  return this->ranged_;
}

void RPG_Monster_DefenseAction_XMLTree_Type::
ranged (const ranged_type& x)
{
  this->ranged_.set (x);
}

void RPG_Monster_DefenseAction_XMLTree_Type::
ranged (const ranged_optional& x)
{
  this->ranged_ = x;
}

void RPG_Monster_DefenseAction_XMLTree_Type::
ranged (::std::unique_ptr< ranged_type > x)
{
  this->ranged_.set (std::move (x));
}


// RPG_Monster_SpecialDefenseProperties_XMLTree_Type
//

const RPG_Monster_SpecialDefenseProperties_XMLTree_Type::action_sequence& RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
action () const
{
  return this->action_;
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type::action_sequence& RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
action ()
{
  return this->action_;
}

void RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
action (const action_sequence& s)
{
  this->action_ = s;
}


// RPG_Monster_AttackAction_XMLTree_Type
//

const RPG_Monster_AttackAction_XMLTree_Type::weapon_type& RPG_Monster_AttackAction_XMLTree_Type::
weapon () const
{
  return this->weapon_.get ();
}

RPG_Monster_AttackAction_XMLTree_Type::weapon_type& RPG_Monster_AttackAction_XMLTree_Type::
weapon ()
{
  return this->weapon_.get ();
}

void RPG_Monster_AttackAction_XMLTree_Type::
weapon (const weapon_type& x)
{
  this->weapon_.set (x);
}

void RPG_Monster_AttackAction_XMLTree_Type::
weapon (::std::unique_ptr< weapon_type > x)
{
  this->weapon_.set (std::move (x));
}

const RPG_Monster_AttackAction_XMLTree_Type::attackBonus_sequence& RPG_Monster_AttackAction_XMLTree_Type::
attackBonus () const
{
  return this->attackBonus_;
}

RPG_Monster_AttackAction_XMLTree_Type::attackBonus_sequence& RPG_Monster_AttackAction_XMLTree_Type::
attackBonus ()
{
  return this->attackBonus_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
attackBonus (const attackBonus_sequence& s)
{
  this->attackBonus_ = s;
}

const RPG_Monster_AttackAction_XMLTree_Type::attackForm_sequence& RPG_Monster_AttackAction_XMLTree_Type::
attackForm () const
{
  return this->attackForm_;
}

RPG_Monster_AttackAction_XMLTree_Type::attackForm_sequence& RPG_Monster_AttackAction_XMLTree_Type::
attackForm ()
{
  return this->attackForm_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
attackForm (const attackForm_sequence& s)
{
  this->attackForm_ = s;
}

const RPG_Monster_AttackAction_XMLTree_Type::damage_optional& RPG_Monster_AttackAction_XMLTree_Type::
damage () const
{
  return this->damage_;
}

RPG_Monster_AttackAction_XMLTree_Type::damage_optional& RPG_Monster_AttackAction_XMLTree_Type::
damage ()
{
  return this->damage_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
damage (const damage_type& x)
{
  this->damage_.set (x);
}

void RPG_Monster_AttackAction_XMLTree_Type::
damage (const damage_optional& x)
{
  this->damage_ = x;
}

void RPG_Monster_AttackAction_XMLTree_Type::
damage (::std::unique_ptr< damage_type > x)
{
  this->damage_.set (std::move (x));
}

const RPG_Monster_AttackAction_XMLTree_Type::effect_optional& RPG_Monster_AttackAction_XMLTree_Type::
effect () const
{
  return this->effect_;
}

RPG_Monster_AttackAction_XMLTree_Type::effect_optional& RPG_Monster_AttackAction_XMLTree_Type::
effect ()
{
  return this->effect_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
effect (const effect_type& x)
{
  this->effect_.set (x);
}

void RPG_Monster_AttackAction_XMLTree_Type::
effect (const effect_optional& x)
{
  this->effect_ = x;
}

void RPG_Monster_AttackAction_XMLTree_Type::
effect (::std::unique_ptr< effect_type > x)
{
  this->effect_.set (std::move (x));
}

const RPG_Monster_AttackAction_XMLTree_Type::numAttacksPerRound_optional& RPG_Monster_AttackAction_XMLTree_Type::
numAttacksPerRound () const
{
  return this->numAttacksPerRound_;
}

RPG_Monster_AttackAction_XMLTree_Type::numAttacksPerRound_optional& RPG_Monster_AttackAction_XMLTree_Type::
numAttacksPerRound ()
{
  return this->numAttacksPerRound_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
numAttacksPerRound (const numAttacksPerRound_type& x)
{
  this->numAttacksPerRound_.set (x);
}

void RPG_Monster_AttackAction_XMLTree_Type::
numAttacksPerRound (const numAttacksPerRound_optional& x)
{
  this->numAttacksPerRound_ = x;
}

const RPG_Monster_AttackAction_XMLTree_Type::ranged_optional& RPG_Monster_AttackAction_XMLTree_Type::
ranged () const
{
  return this->ranged_;
}

RPG_Monster_AttackAction_XMLTree_Type::ranged_optional& RPG_Monster_AttackAction_XMLTree_Type::
ranged ()
{
  return this->ranged_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
ranged (const ranged_type& x)
{
  this->ranged_.set (x);
}

void RPG_Monster_AttackAction_XMLTree_Type::
ranged (const ranged_optional& x)
{
  this->ranged_ = x;
}

void RPG_Monster_AttackAction_XMLTree_Type::
ranged (::std::unique_ptr< ranged_type > x)
{
  this->ranged_.set (std::move (x));
}

const RPG_Monster_AttackAction_XMLTree_Type::trigger_sequence& RPG_Monster_AttackAction_XMLTree_Type::
trigger () const
{
  return this->trigger_;
}

RPG_Monster_AttackAction_XMLTree_Type::trigger_sequence& RPG_Monster_AttackAction_XMLTree_Type::
trigger ()
{
  return this->trigger_;
}

void RPG_Monster_AttackAction_XMLTree_Type::
trigger (const trigger_sequence& s)
{
  this->trigger_ = s;
}

const RPG_Monster_AttackAction_XMLTree_Type::allAdjacent_type& RPG_Monster_AttackAction_XMLTree_Type::
allAdjacent () const
{
  return this->allAdjacent_.get ();
}

RPG_Monster_AttackAction_XMLTree_Type::allAdjacent_type& RPG_Monster_AttackAction_XMLTree_Type::
allAdjacent ()
{
  return this->allAdjacent_.get ();
}

void RPG_Monster_AttackAction_XMLTree_Type::
allAdjacent (const allAdjacent_type& x)
{
  this->allAdjacent_.set (x);
}

RPG_Monster_AttackAction_XMLTree_Type::allAdjacent_type RPG_Monster_AttackAction_XMLTree_Type::
allAdjacent_default_value ()
{
  return allAdjacent_type (false);
}

const RPG_Monster_AttackAction_XMLTree_Type::fullAttackIncludesNextAction_type& RPG_Monster_AttackAction_XMLTree_Type::
fullAttackIncludesNextAction () const
{
  return this->fullAttackIncludesNextAction_.get ();
}

RPG_Monster_AttackAction_XMLTree_Type::fullAttackIncludesNextAction_type& RPG_Monster_AttackAction_XMLTree_Type::
fullAttackIncludesNextAction ()
{
  return this->fullAttackIncludesNextAction_.get ();
}

void RPG_Monster_AttackAction_XMLTree_Type::
fullAttackIncludesNextAction (const fullAttackIncludesNextAction_type& x)
{
  this->fullAttackIncludesNextAction_.set (x);
}

RPG_Monster_AttackAction_XMLTree_Type::fullAttackIncludesNextAction_type RPG_Monster_AttackAction_XMLTree_Type::
fullAttackIncludesNextAction_default_value ()
{
  return fullAttackIncludesNextAction_type (false);
}


// RPG_Monster_Attack_XMLTree_Type
//

const RPG_Monster_Attack_XMLTree_Type::baseAttackBonus_type& RPG_Monster_Attack_XMLTree_Type::
baseAttackBonus () const
{
  return this->baseAttackBonus_.get ();
}

RPG_Monster_Attack_XMLTree_Type::baseAttackBonus_type& RPG_Monster_Attack_XMLTree_Type::
baseAttackBonus ()
{
  return this->baseAttackBonus_.get ();
}

void RPG_Monster_Attack_XMLTree_Type::
baseAttackBonus (const baseAttackBonus_type& x)
{
  this->baseAttackBonus_.set (x);
}

const RPG_Monster_Attack_XMLTree_Type::grappleBonus_type& RPG_Monster_Attack_XMLTree_Type::
grappleBonus () const
{
  return this->grappleBonus_.get ();
}

RPG_Monster_Attack_XMLTree_Type::grappleBonus_type& RPG_Monster_Attack_XMLTree_Type::
grappleBonus ()
{
  return this->grappleBonus_.get ();
}

void RPG_Monster_Attack_XMLTree_Type::
grappleBonus (const grappleBonus_type& x)
{
  this->grappleBonus_.set (x);
}

const RPG_Monster_Attack_XMLTree_Type::standardAttackAction_sequence& RPG_Monster_Attack_XMLTree_Type::
standardAttackAction () const
{
  return this->standardAttackAction_;
}

RPG_Monster_Attack_XMLTree_Type::standardAttackAction_sequence& RPG_Monster_Attack_XMLTree_Type::
standardAttackAction ()
{
  return this->standardAttackAction_;
}

void RPG_Monster_Attack_XMLTree_Type::
standardAttackAction (const standardAttackAction_sequence& s)
{
  this->standardAttackAction_ = s;
}

const RPG_Monster_Attack_XMLTree_Type::fullAttackAction_sequence& RPG_Monster_Attack_XMLTree_Type::
fullAttackAction () const
{
  return this->fullAttackAction_;
}

RPG_Monster_Attack_XMLTree_Type::fullAttackAction_sequence& RPG_Monster_Attack_XMLTree_Type::
fullAttackAction ()
{
  return this->fullAttackAction_;
}

void RPG_Monster_Attack_XMLTree_Type::
fullAttackAction (const fullAttackAction_sequence& s)
{
  this->fullAttackAction_ = s;
}

const RPG_Monster_Attack_XMLTree_Type::actionsAreInclusive_type& RPG_Monster_Attack_XMLTree_Type::
actionsAreInclusive () const
{
  return this->actionsAreInclusive_.get ();
}

RPG_Monster_Attack_XMLTree_Type::actionsAreInclusive_type& RPG_Monster_Attack_XMLTree_Type::
actionsAreInclusive ()
{
  return this->actionsAreInclusive_.get ();
}

void RPG_Monster_Attack_XMLTree_Type::
actionsAreInclusive (const actionsAreInclusive_type& x)
{
  this->actionsAreInclusive_.set (x);
}

RPG_Monster_Attack_XMLTree_Type::actionsAreInclusive_type RPG_Monster_Attack_XMLTree_Type::
actionsAreInclusive_default_value ()
{
  return actionsAreInclusive_type (true);
}


// RPG_Monster_ActionTrigger_XMLTree_Type
//

const RPG_Monster_ActionTrigger_XMLTree_Type::weapon_type& RPG_Monster_ActionTrigger_XMLTree_Type::
weapon () const
{
  return this->weapon_.get ();
}

RPG_Monster_ActionTrigger_XMLTree_Type::weapon_type& RPG_Monster_ActionTrigger_XMLTree_Type::
weapon ()
{
  return this->weapon_.get ();
}

void RPG_Monster_ActionTrigger_XMLTree_Type::
weapon (const weapon_type& x)
{
  this->weapon_.set (x);
}

void RPG_Monster_ActionTrigger_XMLTree_Type::
weapon (::std::unique_ptr< weapon_type > x)
{
  this->weapon_.set (std::move (x));
}

const RPG_Monster_ActionTrigger_XMLTree_Type::numHits_type& RPG_Monster_ActionTrigger_XMLTree_Type::
numHits () const
{
  return this->numHits_.get ();
}

RPG_Monster_ActionTrigger_XMLTree_Type::numHits_type& RPG_Monster_ActionTrigger_XMLTree_Type::
numHits ()
{
  return this->numHits_.get ();
}

void RPG_Monster_ActionTrigger_XMLTree_Type::
numHits (const numHits_type& x)
{
  this->numHits_.set (x);
}


// RPG_Monster_SpecialAttackPreCondition_XMLTree_Type
//

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::action_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
action () const
{
  return this->action_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::action_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
action ()
{
  return this->action_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
action (const action_type& x)
{
  this->action_.set (x);
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
action (const action_optional& x)
{
  this->action_ = x;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
action (::std::unique_ptr< action_type > x)
{
  this->action_.set (std::move (x));
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetAlignment_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetAlignment () const
{
  return this->targetAlignment_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetAlignment_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetAlignment ()
{
  return this->targetAlignment_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetAlignment (const targetAlignment_type& x)
{
  this->targetAlignment_.set (x);
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetAlignment (const targetAlignment_optional& x)
{
  this->targetAlignment_ = x;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetAlignment (::std::unique_ptr< targetAlignment_type > x)
{
  this->targetAlignment_.set (std::move (x));
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::ownCondition_sequence& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
ownCondition () const
{
  return this->ownCondition_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::ownCondition_sequence& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
ownCondition ()
{
  return this->ownCondition_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
ownCondition (const ownCondition_sequence& s)
{
  this->ownCondition_ = s;
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetCondition () const
{
  return this->targetCondition_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetCondition ()
{
  return this->targetCondition_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
targetCondition (const targetCondition_sequence& s)
{
  this->targetCondition_ = s;
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::minTargetSize_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
minTargetSize () const
{
  return this->minTargetSize_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::minTargetSize_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
minTargetSize ()
{
  return this->minTargetSize_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
minTargetSize (const minTargetSize_type& x)
{
  this->minTargetSize_.set (x);
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
minTargetSize (const minTargetSize_optional& x)
{
  this->minTargetSize_ = x;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
minTargetSize (::std::unique_ptr< minTargetSize_type > x)
{
  this->minTargetSize_.set (std::move (x));
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::maxTargetSize_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
maxTargetSize () const
{
  return this->maxTargetSize_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::maxTargetSize_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
maxTargetSize ()
{
  return this->maxTargetSize_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
maxTargetSize (const maxTargetSize_type& x)
{
  this->maxTargetSize_.set (x);
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
maxTargetSize (const maxTargetSize_optional& x)
{
  this->maxTargetSize_ = x;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
maxTargetSize (::std::unique_ptr< maxTargetSize_type > x)
{
  this->maxTargetSize_.set (std::move (x));
}

const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::check_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
check () const
{
  return this->check_;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::check_optional& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
check ()
{
  return this->check_;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
check (const check_type& x)
{
  this->check_.set (x);
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
check (const check_optional& x)
{
  this->check_ = x;
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
check (::std::unique_ptr< check_type > x)
{
  this->check_.set (std::move (x));
}


// RPG_Monster_SpecialAttackProperties_XMLTree_Type
//

const RPG_Monster_SpecialAttackProperties_XMLTree_Type::preCondition_sequence& RPG_Monster_SpecialAttackProperties_XMLTree_Type::
preCondition () const
{
  return this->preCondition_;
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::preCondition_sequence& RPG_Monster_SpecialAttackProperties_XMLTree_Type::
preCondition ()
{
  return this->preCondition_;
}

void RPG_Monster_SpecialAttackProperties_XMLTree_Type::
preCondition (const preCondition_sequence& s)
{
  this->preCondition_ = s;
}

const RPG_Monster_SpecialAttackProperties_XMLTree_Type::action_type& RPG_Monster_SpecialAttackProperties_XMLTree_Type::
action () const
{
  return this->action_.get ();
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::action_type& RPG_Monster_SpecialAttackProperties_XMLTree_Type::
action ()
{
  return this->action_.get ();
}

void RPG_Monster_SpecialAttackProperties_XMLTree_Type::
action (const action_type& x)
{
  this->action_.set (x);
}

void RPG_Monster_SpecialAttackProperties_XMLTree_Type::
action (::std::unique_ptr< action_type > x)
{
  this->action_.set (std::move (x));
}


// RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type
//

const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
targetCondition () const
{
  return this->targetCondition_;
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::targetCondition_sequence& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
targetCondition ()
{
  return this->targetCondition_;
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
targetCondition (const targetCondition_sequence& s)
{
  this->targetCondition_ = s;
}

const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::maxTargetSize_optional& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
maxTargetSize () const
{
  return this->maxTargetSize_;
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::maxTargetSize_optional& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
maxTargetSize ()
{
  return this->maxTargetSize_;
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
maxTargetSize (const maxTargetSize_type& x)
{
  this->maxTargetSize_.set (x);
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
maxTargetSize (const maxTargetSize_optional& x)
{
  this->maxTargetSize_ = x;
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
maxTargetSize (::std::unique_ptr< maxTargetSize_type > x)
{
  this->maxTargetSize_.set (std::move (x));
}

const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::check_optional& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
check () const
{
  return this->check_;
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::check_optional& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
check ()
{
  return this->check_;
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
check (const check_type& x)
{
  this->check_.set (x);
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
check (const check_optional& x)
{
  this->check_ = x;
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
check (::std::unique_ptr< check_type > x)
{
  this->check_.set (std::move (x));
}


// RPG_Monster_SummonMonster_XMLTree_Type
//

const RPG_Monster_SummonMonster_XMLTree_Type::name_type& RPG_Monster_SummonMonster_XMLTree_Type::
name () const
{
  return this->name_.get ();
}

RPG_Monster_SummonMonster_XMLTree_Type::name_type& RPG_Monster_SummonMonster_XMLTree_Type::
name ()
{
  return this->name_.get ();
}

void RPG_Monster_SummonMonster_XMLTree_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void RPG_Monster_SummonMonster_XMLTree_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const RPG_Monster_SummonMonster_XMLTree_Type::amount_type& RPG_Monster_SummonMonster_XMLTree_Type::
amount () const
{
  return this->amount_.get ();
}

RPG_Monster_SummonMonster_XMLTree_Type::amount_type& RPG_Monster_SummonMonster_XMLTree_Type::
amount ()
{
  return this->amount_.get ();
}

void RPG_Monster_SummonMonster_XMLTree_Type::
amount (const amount_type& x)
{
  this->amount_.set (x);
}

void RPG_Monster_SummonMonster_XMLTree_Type::
amount (::std::unique_ptr< amount_type > x)
{
  this->amount_.set (std::move (x));
}

const RPG_Monster_SummonMonster_XMLTree_Type::successRate_type& RPG_Monster_SummonMonster_XMLTree_Type::
successRate () const
{
  return this->successRate_.get ();
}

RPG_Monster_SummonMonster_XMLTree_Type::successRate_type& RPG_Monster_SummonMonster_XMLTree_Type::
successRate ()
{
  return this->successRate_.get ();
}

void RPG_Monster_SummonMonster_XMLTree_Type::
successRate (const successRate_type& x)
{
  this->successRate_.set (x);
}

RPG_Monster_SummonMonster_XMLTree_Type::successRate_type RPG_Monster_SummonMonster_XMLTree_Type::
successRate_default_value ()
{
  return successRate_type (1.0F);
}

const RPG_Monster_SummonMonster_XMLTree_Type::actionsAreInclusive_type& RPG_Monster_SummonMonster_XMLTree_Type::
actionsAreInclusive () const
{
  return this->actionsAreInclusive_.get ();
}

RPG_Monster_SummonMonster_XMLTree_Type::actionsAreInclusive_type& RPG_Monster_SummonMonster_XMLTree_Type::
actionsAreInclusive ()
{
  return this->actionsAreInclusive_.get ();
}

void RPG_Monster_SummonMonster_XMLTree_Type::
actionsAreInclusive (const actionsAreInclusive_type& x)
{
  this->actionsAreInclusive_.set (x);
}

RPG_Monster_SummonMonster_XMLTree_Type::actionsAreInclusive_type RPG_Monster_SummonMonster_XMLTree_Type::
actionsAreInclusive_default_value ()
{
  return actionsAreInclusive_type (true);
}


// RPG_Monster_SpecialAbilityProperties_XMLTree_Type
//

const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::preCondition_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
preCondition () const
{
  return this->preCondition_;
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::preCondition_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
preCondition ()
{
  return this->preCondition_;
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
preCondition (const preCondition_sequence& s)
{
  this->preCondition_ = s;
}

const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::summon_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
summon () const
{
  return this->summon_;
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::summon_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
summon ()
{
  return this->summon_;
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
summon (const summon_sequence& s)
{
  this->summon_ = s;
}

const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::spell_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
spell () const
{
  return this->spell_;
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::spell_sequence& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
spell ()
{
  return this->spell_;
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
spell (const spell_sequence& s)
{
  this->spell_ = s;
}

const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::ranged_optional& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
ranged () const
{
  return this->ranged_;
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::ranged_optional& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
ranged ()
{
  return this->ranged_;
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
ranged (const ranged_type& x)
{
  this->ranged_.set (x);
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
ranged (const ranged_optional& x)
{
  this->ranged_ = x;
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
ranged (::std::unique_ptr< ranged_type > x)
{
  this->ranged_.set (std::move (x));
}


// RPG_Monster_SavingThrowModifiers_XMLTree_Type
//

const RPG_Monster_SavingThrowModifiers_XMLTree_Type::fortitude_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
fortitude () const
{
  return this->fortitude_.get ();
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::fortitude_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
fortitude ()
{
  return this->fortitude_.get ();
}

void RPG_Monster_SavingThrowModifiers_XMLTree_Type::
fortitude (const fortitude_type& x)
{
  this->fortitude_.set (x);
}

const RPG_Monster_SavingThrowModifiers_XMLTree_Type::reflex_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
reflex () const
{
  return this->reflex_.get ();
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::reflex_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
reflex ()
{
  return this->reflex_.get ();
}

void RPG_Monster_SavingThrowModifiers_XMLTree_Type::
reflex (const reflex_type& x)
{
  this->reflex_.set (x);
}

const RPG_Monster_SavingThrowModifiers_XMLTree_Type::will_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
will () const
{
  return this->will_.get ();
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::will_type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
will ()
{
  return this->will_.get ();
}

void RPG_Monster_SavingThrowModifiers_XMLTree_Type::
will (const will_type& x)
{
  this->will_.set (x);
}


// RPG_Monster_Organization_XMLTree_Type
//

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Monster_Organization_XMLTree_Type_literals_[v])
{
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const RPG_Monster_Organization_XMLTree_Type& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Monster_Organization_XMLTree_Type& RPG_Monster_Organization_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Monster_Organization_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Monster_OrganizationSlaverStep_XMLTree_Type
//

const RPG_Monster_OrganizationSlaverStep_XMLTree_Type::name_type& RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
name () const
{
  return this->name_.get ();
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::name_type& RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
name ()
{
  return this->name_.get ();
}

void RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const RPG_Monster_OrganizationSlaverStep_XMLTree_Type::range_type& RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
range () const
{
  return this->range_.get ();
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::range_type& RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
range ()
{
  return this->range_.get ();
}

void RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
range (const range_type& x)
{
  this->range_.set (x);
}

void RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
range (::std::unique_ptr< range_type > x)
{
  this->range_.set (std::move (x));
}


// RPG_Monster_OrganizationStep_XMLTree_Type
//

const RPG_Monster_OrganizationStep_XMLTree_Type::type_type& RPG_Monster_OrganizationStep_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Monster_OrganizationStep_XMLTree_Type::type_type& RPG_Monster_OrganizationStep_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const RPG_Monster_OrganizationStep_XMLTree_Type::range_optional& RPG_Monster_OrganizationStep_XMLTree_Type::
range () const
{
  return this->range_;
}

RPG_Monster_OrganizationStep_XMLTree_Type::range_optional& RPG_Monster_OrganizationStep_XMLTree_Type::
range ()
{
  return this->range_;
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
range (const range_type& x)
{
  this->range_.set (x);
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
range (const range_optional& x)
{
  this->range_ = x;
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
range (::std::unique_ptr< range_type > x)
{
  this->range_.set (std::move (x));
}

const RPG_Monster_OrganizationStep_XMLTree_Type::slaves_sequence& RPG_Monster_OrganizationStep_XMLTree_Type::
slaves () const
{
  return this->slaves_;
}

RPG_Monster_OrganizationStep_XMLTree_Type::slaves_sequence& RPG_Monster_OrganizationStep_XMLTree_Type::
slaves ()
{
  return this->slaves_;
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
slaves (const slaves_sequence& s)
{
  this->slaves_ = s;
}


// RPG_Monster_Organizations_XMLTree_Type
//

const RPG_Monster_Organizations_XMLTree_Type::step_sequence& RPG_Monster_Organizations_XMLTree_Type::
step () const
{
  return this->step_;
}

RPG_Monster_Organizations_XMLTree_Type::step_sequence& RPG_Monster_Organizations_XMLTree_Type::
step ()
{
  return this->step_;
}

void RPG_Monster_Organizations_XMLTree_Type::
step (const step_sequence& s)
{
  this->step_ = s;
}


// RPG_Monster_AdvancementStep_XMLTree_Type
//

const RPG_Monster_AdvancementStep_XMLTree_Type::size_type& RPG_Monster_AdvancementStep_XMLTree_Type::
size () const
{
  return this->size_.get ();
}

RPG_Monster_AdvancementStep_XMLTree_Type::size_type& RPG_Monster_AdvancementStep_XMLTree_Type::
size ()
{
  return this->size_.get ();
}

void RPG_Monster_AdvancementStep_XMLTree_Type::
size (const size_type& x)
{
  this->size_.set (x);
}

void RPG_Monster_AdvancementStep_XMLTree_Type::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const RPG_Monster_AdvancementStep_XMLTree_Type::range_type& RPG_Monster_AdvancementStep_XMLTree_Type::
range () const
{
  return this->range_.get ();
}

RPG_Monster_AdvancementStep_XMLTree_Type::range_type& RPG_Monster_AdvancementStep_XMLTree_Type::
range ()
{
  return this->range_.get ();
}

void RPG_Monster_AdvancementStep_XMLTree_Type::
range (const range_type& x)
{
  this->range_.set (x);
}

void RPG_Monster_AdvancementStep_XMLTree_Type::
range (::std::unique_ptr< range_type > x)
{
  this->range_.set (std::move (x));
}


// RPG_Monster_Advancement_XMLTree_Type
//

const RPG_Monster_Advancement_XMLTree_Type::step_sequence& RPG_Monster_Advancement_XMLTree_Type::
step () const
{
  return this->step_;
}

RPG_Monster_Advancement_XMLTree_Type::step_sequence& RPG_Monster_Advancement_XMLTree_Type::
step ()
{
  return this->step_;
}

void RPG_Monster_Advancement_XMLTree_Type::
step (const step_sequence& s)
{
  this->step_ = s;
}


// RPG_Monster_PropertiesXML_XMLTree_Type
//

const RPG_Monster_PropertiesXML_XMLTree_Type::name_type& RPG_Monster_PropertiesXML_XMLTree_Type::
name () const
{
  return this->name_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::name_type& RPG_Monster_PropertiesXML_XMLTree_Type::
name ()
{
  return this->name_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
name (::std::unique_ptr< name_type > x)
{
  this->name_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::size_type& RPG_Monster_PropertiesXML_XMLTree_Type::
size () const
{
  return this->size_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::size_type& RPG_Monster_PropertiesXML_XMLTree_Type::
size ()
{
  return this->size_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
size (const size_type& x)
{
  this->size_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::type_type& RPG_Monster_PropertiesXML_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::type_type& RPG_Monster_PropertiesXML_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::hitDice_type& RPG_Monster_PropertiesXML_XMLTree_Type::
hitDice () const
{
  return this->hitDice_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::hitDice_type& RPG_Monster_PropertiesXML_XMLTree_Type::
hitDice ()
{
  return this->hitDice_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
hitDice (const hitDice_type& x)
{
  this->hitDice_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
hitDice (::std::unique_ptr< hitDice_type > x)
{
  this->hitDice_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::initiative_type& RPG_Monster_PropertiesXML_XMLTree_Type::
initiative () const
{
  return this->initiative_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::initiative_type& RPG_Monster_PropertiesXML_XMLTree_Type::
initiative ()
{
  return this->initiative_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
initiative (const initiative_type& x)
{
  this->initiative_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::speed_type& RPG_Monster_PropertiesXML_XMLTree_Type::
speed () const
{
  return this->speed_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::speed_type& RPG_Monster_PropertiesXML_XMLTree_Type::
speed ()
{
  return this->speed_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::armorClass_type& RPG_Monster_PropertiesXML_XMLTree_Type::
armorClass () const
{
  return this->armorClass_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::armorClass_type& RPG_Monster_PropertiesXML_XMLTree_Type::
armorClass ()
{
  return this->armorClass_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
armorClass (const armorClass_type& x)
{
  this->armorClass_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
armorClass (::std::unique_ptr< armorClass_type > x)
{
  this->armorClass_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::specialDefense_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialDefense () const
{
  return this->specialDefense_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::specialDefense_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialDefense ()
{
  return this->specialDefense_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
specialDefense (const specialDefense_sequence& s)
{
  this->specialDefense_ = s;
}

const RPG_Monster_PropertiesXML_XMLTree_Type::attack_type& RPG_Monster_PropertiesXML_XMLTree_Type::
attack () const
{
  return this->attack_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::attack_type& RPG_Monster_PropertiesXML_XMLTree_Type::
attack ()
{
  return this->attack_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
attack (const attack_type& x)
{
  this->attack_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
attack (::std::unique_ptr< attack_type > x)
{
  this->attack_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::specialAttack_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialAttack () const
{
  return this->specialAttack_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::specialAttack_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialAttack ()
{
  return this->specialAttack_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
specialAttack (const specialAttack_sequence& s)
{
  this->specialAttack_ = s;
}

const RPG_Monster_PropertiesXML_XMLTree_Type::specialAbility_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialAbility () const
{
  return this->specialAbility_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::specialAbility_sequence& RPG_Monster_PropertiesXML_XMLTree_Type::
specialAbility ()
{
  return this->specialAbility_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
specialAbility (const specialAbility_sequence& s)
{
  this->specialAbility_ = s;
}

const RPG_Monster_PropertiesXML_XMLTree_Type::space_type& RPG_Monster_PropertiesXML_XMLTree_Type::
space () const
{
  return this->space_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::space_type& RPG_Monster_PropertiesXML_XMLTree_Type::
space ()
{
  return this->space_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
space (const space_type& x)
{
  this->space_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::reach_type& RPG_Monster_PropertiesXML_XMLTree_Type::
reach () const
{
  return this->reach_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::reach_type& RPG_Monster_PropertiesXML_XMLTree_Type::
reach ()
{
  return this->reach_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
reach (const reach_type& x)
{
  this->reach_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::saves_type& RPG_Monster_PropertiesXML_XMLTree_Type::
saves () const
{
  return this->saves_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::saves_type& RPG_Monster_PropertiesXML_XMLTree_Type::
saves ()
{
  return this->saves_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
saves (const saves_type& x)
{
  this->saves_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
saves (::std::unique_ptr< saves_type > x)
{
  this->saves_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::attributes_type& RPG_Monster_PropertiesXML_XMLTree_Type::
attributes () const
{
  return this->attributes_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::attributes_type& RPG_Monster_PropertiesXML_XMLTree_Type::
attributes ()
{
  return this->attributes_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
attributes (const attributes_type& x)
{
  this->attributes_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
attributes (::std::unique_ptr< attributes_type > x)
{
  this->attributes_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::skills_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
skills () const
{
  return this->skills_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::skills_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
skills ()
{
  return this->skills_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
skills (const skills_type& x)
{
  this->skills_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
skills (const skills_optional& x)
{
  this->skills_ = x;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
skills (::std::unique_ptr< skills_type > x)
{
  this->skills_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::feats_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
feats () const
{
  return this->feats_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::feats_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
feats ()
{
  return this->feats_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
feats (const feats_type& x)
{
  this->feats_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
feats (const feats_optional& x)
{
  this->feats_ = x;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
feats (::std::unique_ptr< feats_type > x)
{
  this->feats_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::environment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
environment () const
{
  return this->environment_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::environment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
environment ()
{
  return this->environment_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
environment (const environment_type& x)
{
  this->environment_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
environment (::std::unique_ptr< environment_type > x)
{
  this->environment_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::organizations_type& RPG_Monster_PropertiesXML_XMLTree_Type::
organizations () const
{
  return this->organizations_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::organizations_type& RPG_Monster_PropertiesXML_XMLTree_Type::
organizations ()
{
  return this->organizations_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
organizations (const organizations_type& x)
{
  this->organizations_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
organizations (::std::unique_ptr< organizations_type > x)
{
  this->organizations_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::challengeRating_type& RPG_Monster_PropertiesXML_XMLTree_Type::
challengeRating () const
{
  return this->challengeRating_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::challengeRating_type& RPG_Monster_PropertiesXML_XMLTree_Type::
challengeRating ()
{
  return this->challengeRating_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
challengeRating (const challengeRating_type& x)
{
  this->challengeRating_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::treasureModifier_type& RPG_Monster_PropertiesXML_XMLTree_Type::
treasureModifier () const
{
  return this->treasureModifier_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::treasureModifier_type& RPG_Monster_PropertiesXML_XMLTree_Type::
treasureModifier ()
{
  return this->treasureModifier_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
treasureModifier (const treasureModifier_type& x)
{
  this->treasureModifier_.set (x);
}

const RPG_Monster_PropertiesXML_XMLTree_Type::alignment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
alignment () const
{
  return this->alignment_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::alignment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
alignment ()
{
  return this->alignment_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
alignment (const alignment_type& x)
{
  this->alignment_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
alignment (::std::unique_ptr< alignment_type > x)
{
  this->alignment_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::advancements_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
advancements () const
{
  return this->advancements_;
}

RPG_Monster_PropertiesXML_XMLTree_Type::advancements_optional& RPG_Monster_PropertiesXML_XMLTree_Type::
advancements ()
{
  return this->advancements_;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
advancements (const advancements_type& x)
{
  this->advancements_.set (x);
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
advancements (const advancements_optional& x)
{
  this->advancements_ = x;
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
advancements (::std::unique_ptr< advancements_type > x)
{
  this->advancements_.set (std::move (x));
}

const RPG_Monster_PropertiesXML_XMLTree_Type::levelAdjustment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
levelAdjustment () const
{
  return this->levelAdjustment_.get ();
}

RPG_Monster_PropertiesXML_XMLTree_Type::levelAdjustment_type& RPG_Monster_PropertiesXML_XMLTree_Type::
levelAdjustment ()
{
  return this->levelAdjustment_.get ();
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
levelAdjustment (const levelAdjustment_type& x)
{
  this->levelAdjustment_.set (x);
}


// RPG_Monster_StateBase_XMLTree_Type
//

const RPG_Monster_StateBase_XMLTree_Type::gold_type& RPG_Monster_StateBase_XMLTree_Type::
gold () const
{
  return this->gold_.get ();
}

RPG_Monster_StateBase_XMLTree_Type::gold_type& RPG_Monster_StateBase_XMLTree_Type::
gold ()
{
  return this->gold_.get ();
}

void RPG_Monster_StateBase_XMLTree_Type::
gold (const gold_type& x)
{
  this->gold_.set (x);
}

const RPG_Monster_StateBase_XMLTree_Type::inventory_optional& RPG_Monster_StateBase_XMLTree_Type::
inventory () const
{
  return this->inventory_;
}

RPG_Monster_StateBase_XMLTree_Type::inventory_optional& RPG_Monster_StateBase_XMLTree_Type::
inventory ()
{
  return this->inventory_;
}

void RPG_Monster_StateBase_XMLTree_Type::
inventory (const inventory_type& x)
{
  this->inventory_.set (x);
}

void RPG_Monster_StateBase_XMLTree_Type::
inventory (const inventory_optional& x)
{
  this->inventory_ = x;
}

void RPG_Monster_StateBase_XMLTree_Type::
inventory (::std::unique_ptr< inventory_type > x)
{
  this->inventory_.set (std::move (x));
}

const RPG_Monster_StateBase_XMLTree_Type::maxHP_type& RPG_Monster_StateBase_XMLTree_Type::
maxHP () const
{
  return this->maxHP_.get ();
}

RPG_Monster_StateBase_XMLTree_Type::maxHP_type& RPG_Monster_StateBase_XMLTree_Type::
maxHP ()
{
  return this->maxHP_.get ();
}

void RPG_Monster_StateBase_XMLTree_Type::
maxHP (const maxHP_type& x)
{
  this->maxHP_.set (x);
}


// RPG_Monster_State_XMLTree_Type
//

const RPG_Monster_State_XMLTree_Type::type_type& RPG_Monster_State_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Monster_State_XMLTree_Type::type_type& RPG_Monster_State_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Monster_State_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Monster_State_XMLTree_Type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// RPG_Monster_Spawn_XMLTree_Type
//

const RPG_Monster_Spawn_XMLTree_Type::type_type& RPG_Monster_Spawn_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Monster_Spawn_XMLTree_Type::type_type& RPG_Monster_Spawn_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Monster_Spawn_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Monster_Spawn_XMLTree_Type::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}

const RPG_Monster_Spawn_XMLTree_Type::interval_type& RPG_Monster_Spawn_XMLTree_Type::
interval () const
{
  return this->interval_.get ();
}

RPG_Monster_Spawn_XMLTree_Type::interval_type& RPG_Monster_Spawn_XMLTree_Type::
interval ()
{
  return this->interval_.get ();
}

void RPG_Monster_Spawn_XMLTree_Type::
interval (const interval_type& x)
{
  this->interval_.set (x);
}

void RPG_Monster_Spawn_XMLTree_Type::
interval (::std::unique_ptr< interval_type > x)
{
  this->interval_.set (std::move (x));
}

const RPG_Monster_Spawn_XMLTree_Type::probability_type& RPG_Monster_Spawn_XMLTree_Type::
probability () const
{
  return this->probability_.get ();
}

RPG_Monster_Spawn_XMLTree_Type::probability_type& RPG_Monster_Spawn_XMLTree_Type::
probability ()
{
  return this->probability_.get ();
}

void RPG_Monster_Spawn_XMLTree_Type::
probability (const probability_type& x)
{
  this->probability_.set (x);
}

const RPG_Monster_Spawn_XMLTree_Type::max_num_spawned_type& RPG_Monster_Spawn_XMLTree_Type::
max_num_spawned () const
{
  return this->max_num_spawned_.get ();
}

RPG_Monster_Spawn_XMLTree_Type::max_num_spawned_type& RPG_Monster_Spawn_XMLTree_Type::
max_num_spawned ()
{
  return this->max_num_spawned_.get ();
}

void RPG_Monster_Spawn_XMLTree_Type::
max_num_spawned (const max_num_spawned_type& x)
{
  this->max_num_spawned_.set (x);
}

const RPG_Monster_Spawn_XMLTree_Type::amble_probability_type& RPG_Monster_Spawn_XMLTree_Type::
amble_probability () const
{
  return this->amble_probability_.get ();
}

RPG_Monster_Spawn_XMLTree_Type::amble_probability_type& RPG_Monster_Spawn_XMLTree_Type::
amble_probability ()
{
  return this->amble_probability_.get ();
}

void RPG_Monster_Spawn_XMLTree_Type::
amble_probability (const amble_probability_type& x)
{
  this->amble_probability_.set (x);
}


// RPG_Monster_Dictionary_XMLTree_Type
//

const RPG_Monster_Dictionary_XMLTree_Type::monster_sequence& RPG_Monster_Dictionary_XMLTree_Type::
monster () const
{
  return this->monster_;
}

RPG_Monster_Dictionary_XMLTree_Type::monster_sequence& RPG_Monster_Dictionary_XMLTree_Type::
monster ()
{
  return this->monster_;
}

void RPG_Monster_Dictionary_XMLTree_Type::
monster (const monster_sequence& s)
{
  this->monster_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RPG_Monster_Size_XMLTree_Type
//

RPG_Monster_Size_XMLTree_Type::
RPG_Monster_Size_XMLTree_Type (const size_type& size)
: ::xml_schema::type (),
  size_ (size, this),
  isTall_ (isTall_default_value (), this)
{
}

RPG_Monster_Size_XMLTree_Type::
RPG_Monster_Size_XMLTree_Type (const RPG_Monster_Size_XMLTree_Type& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  size_ (x.size_, f, this),
  isTall_ (x.isTall_, f, this)
{
}

RPG_Monster_Size_XMLTree_Type::
RPG_Monster_Size_XMLTree_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  size_ (this),
  isTall_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Monster_Size_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // size
    //
    if (n.name () == "size" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "isTall" && n.namespace_ ().empty ())
    {
      this->isTall_.set (isTall_traits::create (i, f, this));
      continue;
    }
  }

  if (!isTall_.present ())
  {
    this->isTall_.set (isTall_default_value ());
  }
}

RPG_Monster_Size_XMLTree_Type* RPG_Monster_Size_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Size_XMLTree_Type (*this, f, c);
}

RPG_Monster_Size_XMLTree_Type& RPG_Monster_Size_XMLTree_Type::
operator= (const RPG_Monster_Size_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->size_ = x.size_;
    this->isTall_ = x.isTall_;
  }

  return *this;
}

RPG_Monster_Size_XMLTree_Type::
~RPG_Monster_Size_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Size_XMLTree_Type& x, const RPG_Monster_Size_XMLTree_Type& y)
{
  if (!(x.size () == y.size ()))
    return false;

  if (!(x.isTall () == y.isTall ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Size_XMLTree_Type& x, const RPG_Monster_Size_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_NaturalArmorClass_XMLTree_Type
//

RPG_Monster_NaturalArmorClass_XMLTree_Type::
RPG_Monster_NaturalArmorClass_XMLTree_Type (const normal_type& normal,
                                            const touch_type& touch,
                                            const flatFooted_type& flatFooted)
: ::xml_schema::type (),
  normal_ (normal, this),
  touch_ (touch, this),
  flatFooted_ (flatFooted, this)
{
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::
RPG_Monster_NaturalArmorClass_XMLTree_Type (const RPG_Monster_NaturalArmorClass_XMLTree_Type& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  normal_ (x.normal_, f, this),
  touch_ (x.touch_, f, this),
  flatFooted_ (x.flatFooted_, f, this)
{
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::
RPG_Monster_NaturalArmorClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  normal_ (this),
  touch_ (this),
  flatFooted_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_NaturalArmorClass_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // normal
    //
    if (n.name () == "normal" && n.namespace_ () == "urn:rpg")
    {
      if (!normal_.present ())
      {
        this->normal_.set (normal_traits::create (i, f, this));
        continue;
      }
    }

    // touch
    //
    if (n.name () == "touch" && n.namespace_ () == "urn:rpg")
    {
      if (!touch_.present ())
      {
        this->touch_.set (touch_traits::create (i, f, this));
        continue;
      }
    }

    // flatFooted
    //
    if (n.name () == "flatFooted" && n.namespace_ () == "urn:rpg")
    {
      if (!flatFooted_.present ())
      {
        this->flatFooted_.set (flatFooted_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!normal_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "normal",
      "urn:rpg");
  }

  if (!touch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "touch",
      "urn:rpg");
  }

  if (!flatFooted_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "flatFooted",
      "urn:rpg");
  }
}

RPG_Monster_NaturalArmorClass_XMLTree_Type* RPG_Monster_NaturalArmorClass_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_NaturalArmorClass_XMLTree_Type (*this, f, c);
}

RPG_Monster_NaturalArmorClass_XMLTree_Type& RPG_Monster_NaturalArmorClass_XMLTree_Type::
operator= (const RPG_Monster_NaturalArmorClass_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->normal_ = x.normal_;
    this->touch_ = x.touch_;
    this->flatFooted_ = x.flatFooted_;
  }

  return *this;
}

RPG_Monster_NaturalArmorClass_XMLTree_Type::
~RPG_Monster_NaturalArmorClass_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_NaturalArmorClass_XMLTree_Type& x, const RPG_Monster_NaturalArmorClass_XMLTree_Type& y)
{
  if (!(x.normal () == y.normal ()))
    return false;

  if (!(x.touch () == y.touch ()))
    return false;

  if (!(x.flatFooted () == y.flatFooted ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_NaturalArmorClass_XMLTree_Type& x, const RPG_Monster_NaturalArmorClass_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type
//

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (const ::std::string& s,
                                                   const ::xercesc::DOMElement* e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type* RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::value RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_indexes_ + 82,
                    *this,
                    c));

  if (i == _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_indexes_ + 82 || _xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_[82] =
{
  "ABILITY_ACID_ATTACK",
  "ABILITY_CORROSIVE_SLIME",
  "ABILITY_DEATH_THROES",
  "ABILITY_ENTANGLE",
  "ABILITY_FLAMING_BODY",
  "ABILITY_LEAP_ATTACK",
  "ABILITY_REND_ARMOR",
  "ABILITY_SCORE_LOSS",
  "ABILITY_SNEAK_ATTACK",
  "ABILITY_SPORES",
  "ABILITY_STENCH",
  "ABILITY_THROW_WEB",
  "ABILITY_ALTERNATE_FORM",
  "ABILITY_ANTIMAGIC",
  "ABILITY_BLINDSIGHT",
  "ABILITY_BLINDSENSE",
  "ABILITY_BREATH_WEAPON",
  "ABILITY_CHANGE_SHAPE",
  "ABILITY_CHARM",
  "ABILITY_COMPULSION",
  "ABILITY_IMMUNITY_COLD",
  "ABILITY_CONSTRICT",
  "ABILITY_RESISTANCE_TO_DAMAGE",
  "ABILITY_DARKVISION",
  "ABILITY_DEATH_ATTACK",
  "ABILITY_DISEASE",
  "ABILITY_ENERGY_DRAIN",
  "ABILITY_ETHEREALNESS",
  "ABILITY_EVASION",
  "ABILITY_IMPROVED_EVASION",
  "ABILITY_FAST_HEALING",
  "ABILITY_FEAR",
  "ABILITY_IMMUNITY_FIRE",
  "ABILITY_GASEOUS_FORM",
  "ABILITY_GAZE_ATTACK",
  "ABILITY_IMPROVED_GRAB",
  "ABILITY_INCORPOREALITY",
  "ABILITY_INVISIBILITY",
  "ABILITY_LEVEL_LOSS",
  "ABILITY_LOWLIGHT_VISION",
  "ABILITY_MANUFACTURED_WEAPONS",
  "ABILITY_MOVEMENT_MODES",
  "ABILITY_NATURAL_WEAPONS",
  "ABILITY_NONABILITIES",
  "ABILITY_PARALYZE_ATTACK",
  "ABILITY_POISON_ATTACK",
  "ABILITY_IMMUNITY_POISON",
  "ABILITY_POLYMORPH",
  "ABILITY_POUNCE",
  "ABILITY_POWERFUL_CHARGE",
  "ABILITY_PSIONICS",
  "ABILITY_RAKE",
  "ABILITY_RAY_ATTACK",
  "ABILITY_REGENERATION",
  "ABILITY_RESISTANCE_TO_ENERGY",
  "ABILITY_SCENT",
  "ABILITY_SONIC_ATTACK",
  "ABILITY_IMMUNITY_SPELL",
  "ABILITY_RESISTANCE_TO_SPELL",
  "ABILITY_SPELLS",
  "ABILITY_SUMMON",
  "ABILITY_SWALLOW_WHOLE",
  "ABILITY_TELEPATHY",
  "ABILITY_TRAMPLE",
  "ABILITY_TREMOR_SENSE",
  "ABILITY_RESISTANCE_TO_TURNING",
  "ABILITY_VULNERABILITY_TO_ENERGY",
  "ABILITY_IMMUNITY_DISEASE",
  "ABILITY_ANIMAL_COMPANION",
  "ABILITY_WOODLAND_STRIDE",
  "ABILITY_SENSE_TRAPS",
  "ABILITY_UNCANNY_DODGE",
  "ABILITY_IMPROVED_UNCANNY_DODGE",
  "ABILITY_CRIPPLING_STRIKE",
  "ABILITY_DEFENSIVE_ROLL",
  "ABILITY_OPPORTUNIST",
  "ABILITY_SKILL_MASTERY",
  "ABILITY_SLIPPERY_MIND",
  "ABILITY_BONUS_FEAT",
  "ABILITYTYPE_SMITE",
  "ABILITYTYPE_SMOKE_CLAWS",
  "ABILITYTYPE_WHIRLWIND_BLAST"
};

const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::value RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_indexes_[82] =
{
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITYTYPE_SMITE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITYTYPE_SMOKE_CLAWS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITYTYPE_WHIRLWIND_BLAST,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ACID_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ALTERNATE_FORM,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ANIMAL_COMPANION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ANTIMAGIC,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_BLINDSENSE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_BLINDSIGHT,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_BONUS_FEAT,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_BREATH_WEAPON,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_CHANGE_SHAPE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_CHARM,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_COMPULSION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_CONSTRICT,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_CORROSIVE_SLIME,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_CRIPPLING_STRIKE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_DARKVISION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_DEATH_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_DEATH_THROES,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_DEFENSIVE_ROLL,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_DISEASE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ENERGY_DRAIN,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ENTANGLE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_ETHEREALNESS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_EVASION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_FAST_HEALING,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_FEAR,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_FLAMING_BODY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_GASEOUS_FORM,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_GAZE_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_COLD,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_DISEASE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_FIRE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_POISON,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_SPELL,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMPROVED_EVASION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMPROVED_GRAB,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_IMPROVED_UNCANNY_DODGE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_INCORPOREALITY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_INVISIBILITY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_LEAP_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_LEVEL_LOSS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_LOWLIGHT_VISION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_MANUFACTURED_WEAPONS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_MOVEMENT_MODES,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_NATURAL_WEAPONS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_NONABILITIES,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_OPPORTUNIST,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_PARALYZE_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_POISON_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_POLYMORPH,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_POUNCE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_POWERFUL_CHARGE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_PSIONICS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RAKE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RAY_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_REGENERATION,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_REND_ARMOR,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_DAMAGE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_ENERGY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_SPELL,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_TURNING,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SCENT,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SCORE_LOSS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SENSE_TRAPS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SKILL_MASTERY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SLIPPERY_MIND,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SNEAK_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SONIC_ATTACK,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SPELLS,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SPORES,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_STENCH,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SUMMON,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_SWALLOW_WHOLE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_TELEPATHY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_THROW_WEB,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_TRAMPLE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_TREMOR_SENSE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_UNCANNY_DODGE,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_VULNERABILITY_TO_ENERGY,
  ::RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::ABILITY_WOODLAND_STRIDE
};

// RPG_Monster_SpecialBaseProperties_XMLTree_Type
//

RPG_Monster_SpecialBaseProperties_XMLTree_Type::
RPG_Monster_SpecialBaseProperties_XMLTree_Type (const abilityClass_type& abilityClass,
                                                const type_type& type,
                                                const actionType_type& actionType)
: ::xml_schema::type (),
  abilityClass_ (abilityClass, this),
  type_ (type, this),
  actionType_ (actionType, this),
  usage_ (this)
{
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::
RPG_Monster_SpecialBaseProperties_XMLTree_Type (const RPG_Monster_SpecialBaseProperties_XMLTree_Type& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  abilityClass_ (x.abilityClass_, f, this),
  type_ (x.type_, f, this),
  actionType_ (x.actionType_, f, this),
  usage_ (x.usage_, f, this)
{
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::
RPG_Monster_SpecialBaseProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  abilityClass_ (this),
  type_ (this),
  actionType_ (this),
  usage_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialBaseProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // abilityClass
    //
    if (n.name () == "abilityClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< abilityClass_type > r (
        abilityClass_traits::create (i, f, this));

      if (!abilityClass_.present ())
      {
        this->abilityClass_.set (::std::move (r));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // actionType
    //
    if (n.name () == "actionType" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< actionType_type > r (
        actionType_traits::create (i, f, this));

      if (!actionType_.present ())
      {
        this->actionType_.set (::std::move (r));
        continue;
      }
    }

    // usage
    //
    if (n.name () == "usage" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< usage_type > r (
        usage_traits::create (i, f, this));

      if (!this->usage_)
      {
        this->usage_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!abilityClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "abilityClass",
      "urn:rpg");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!actionType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "actionType",
      "urn:rpg");
  }
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type* RPG_Monster_SpecialBaseProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialBaseProperties_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type& RPG_Monster_SpecialBaseProperties_XMLTree_Type::
operator= (const RPG_Monster_SpecialBaseProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->abilityClass_ = x.abilityClass_;
    this->type_ = x.type_;
    this->actionType_ = x.actionType_;
    this->usage_ = x.usage_;
  }

  return *this;
}

RPG_Monster_SpecialBaseProperties_XMLTree_Type::
~RPG_Monster_SpecialBaseProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialBaseProperties_XMLTree_Type& x, const RPG_Monster_SpecialBaseProperties_XMLTree_Type& y)
{
  if (!(x.abilityClass () == y.abilityClass ()))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.actionType () == y.actionType ()))
    return false;

  if (!(x.usage () == y.usage ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialBaseProperties_XMLTree_Type& x, const RPG_Monster_SpecialBaseProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_NaturalWeapon_XMLTree_Type
//

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_convert ();
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_convert ();
}

RPG_Monster_NaturalWeapon_XMLTree_Type::
RPG_Monster_NaturalWeapon_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_convert ();
}

RPG_Monster_NaturalWeapon_XMLTree_Type* RPG_Monster_NaturalWeapon_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_NaturalWeapon_XMLTree_Type (*this, f, c);
}

RPG_Monster_NaturalWeapon_XMLTree_Type::value RPG_Monster_NaturalWeapon_XMLTree_Type::
_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_indexes_,
                    _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_indexes_ + 15,
                    *this,
                    c));

  if (i == _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_indexes_ + 15 || _xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Monster_NaturalWeapon_XMLTree_Type::
_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_[15] =
{
  "NATURALWEAPON_ANY",
  "NATURALWEAPON_BITE",
  "NATURALWEAPON_BLAST",
  "NATURALWEAPON_CLAW_TALON",
  "NATURALWEAPON_CONSTRICT",
  "NATURALWEAPON_GORE",
  "NATURALWEAPON_HOOF",
  "NATURALWEAPON_PINCER",
  "NATURALWEAPON_ROCK_STONE",
  "NATURALWEAPON_SLAP_SLAM",
  "NATURALWEAPON_SPIT",
  "NATURALWEAPON_STING",
  "NATURALWEAPON_TAIL",
  "NATURALWEAPON_TENTACLE",
  "NATURALWEAPON_WEB"
};

const RPG_Monster_NaturalWeapon_XMLTree_Type::value RPG_Monster_NaturalWeapon_XMLTree_Type::
_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_indexes_[15] =
{
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_ANY,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_BITE,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_BLAST,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_CLAW_TALON,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_CONSTRICT,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_GORE,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_HOOF,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_PINCER,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_ROCK_STONE,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_SLAP_SLAM,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_SPIT,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_STING,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_TAIL,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_TENTACLE,
  ::RPG_Monster_NaturalWeapon_XMLTree_Type::NATURALWEAPON_WEB
};

// RPG_Monster_WeaponTypeUnion_XMLTree_Type
//

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::
RPG_Monster_WeaponTypeUnion_XMLTree_Type (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_convert ();
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type* RPG_Monster_WeaponTypeUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_WeaponTypeUnion_XMLTree_Type (*this, f, c);
}

RPG_Monster_WeaponTypeUnion_XMLTree_Type::value RPG_Monster_WeaponTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_indexes_ + 169,
                    *this,
                    c));

  if (i == _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_indexes_ + 169 || _xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Monster_WeaponTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_[169] =
{
  "NATURALWEAPON_ANY",
  "NATURALWEAPON_BITE",
  "NATURALWEAPON_BLAST",
  "NATURALWEAPON_CLAW_TALON",
  "NATURALWEAPON_CONSTRICT",
  "NATURALWEAPON_GORE",
  "NATURALWEAPON_HOOF",
  "NATURALWEAPON_PINCER",
  "NATURALWEAPON_ROCK_STONE",
  "NATURALWEAPON_SLAP_SLAM",
  "NATURALWEAPON_SPIT",
  "NATURALWEAPON_STING",
  "NATURALWEAPON_TAIL",
  "NATURALWEAPON_TENTACLE",
  "NATURALWEAPON_WEB",
  "ABILITY_ACID_ATTACK",
  "ABILITY_CORROSIVE_SLIME",
  "ABILITY_DEATH_THROES",
  "ABILITY_ENTANGLE",
  "ABILITY_FLAMING_BODY",
  "ABILITY_LEAP_ATTACK",
  "ABILITY_REND_ARMOR",
  "ABILITY_SCORE_LOSS",
  "ABILITY_SNEAK_ATTACK",
  "ABILITY_SPORES",
  "ABILITY_STENCH",
  "ABILITY_THROW_WEB",
  "ABILITY_ALTERNATE_FORM",
  "ABILITY_ANTIMAGIC",
  "ABILITY_BLINDSIGHT",
  "ABILITY_BLINDSENSE",
  "ABILITY_BREATH_WEAPON",
  "ABILITY_CHANGE_SHAPE",
  "ABILITY_CHARM",
  "ABILITY_COMPULSION",
  "ABILITY_IMMUNITY_COLD",
  "ABILITY_CONSTRICT",
  "ABILITY_RESISTANCE_TO_DAMAGE",
  "ABILITY_DARKVISION",
  "ABILITY_DEATH_ATTACK",
  "ABILITY_DISEASE",
  "ABILITY_ENERGY_DRAIN",
  "ABILITY_ETHEREALNESS",
  "ABILITY_EVASION",
  "ABILITY_IMPROVED_EVASION",
  "ABILITY_FAST_HEALING",
  "ABILITY_FEAR",
  "ABILITY_IMMUNITY_FIRE",
  "ABILITY_GASEOUS_FORM",
  "ABILITY_GAZE_ATTACK",
  "ABILITY_IMPROVED_GRAB",
  "ABILITY_INCORPOREALITY",
  "ABILITY_INVISIBILITY",
  "ABILITY_LEVEL_LOSS",
  "ABILITY_LOWLIGHT_VISION",
  "ABILITY_MANUFACTURED_WEAPONS",
  "ABILITY_MOVEMENT_MODES",
  "ABILITY_NATURAL_WEAPONS",
  "ABILITY_NONABILITIES",
  "ABILITY_PARALYZE_ATTACK",
  "ABILITY_POISON_ATTACK",
  "ABILITY_IMMUNITY_POISON",
  "ABILITY_POLYMORPH",
  "ABILITY_POUNCE",
  "ABILITY_POWERFUL_CHARGE",
  "ABILITY_PSIONICS",
  "ABILITY_RAKE",
  "ABILITY_RAY_ATTACK",
  "ABILITY_REGENERATION",
  "ABILITY_RESISTANCE_TO_ENERGY",
  "ABILITY_SCENT",
  "ABILITY_SONIC_ATTACK",
  "ABILITY_IMMUNITY_SPELL",
  "ABILITY_RESISTANCE_TO_SPELL",
  "ABILITY_SPELLS",
  "ABILITY_SUMMON",
  "ABILITY_SWALLOW_WHOLE",
  "ABILITY_TELEPATHY",
  "ABILITY_TRAMPLE",
  "ABILITY_TREMOR_SENSE",
  "ABILITY_RESISTANCE_TO_TURNING",
  "ABILITY_VULNERABILITY_TO_ENERGY",
  "ABILITY_IMMUNITY_DISEASE",
  "ABILITY_ANIMAL_COMPANION",
  "ABILITY_WOODLAND_STRIDE",
  "ABILITY_SENSE_TRAPS",
  "ABILITY_UNCANNY_DODGE",
  "ABILITY_IMPROVED_UNCANNY_DODGE",
  "ABILITY_CRIPPLING_STRIKE",
  "ABILITY_DEFENSIVE_ROLL",
  "ABILITY_OPPORTUNIST",
  "ABILITY_SKILL_MASTERY",
  "ABILITY_SLIPPERY_MIND",
  "ABILITY_BONUS_FEAT",
  "UNARMED_WEAPON_GAUNTLET",
  "UNARMED_WEAPON_STRIKE",
  "LIGHT_MELEE_WEAPON_DAGGER",
  "LIGHT_MELEE_WEAPON_DAGGER_PUNCHING",
  "LIGHT_MELEE_WEAPON_GAUNTLET_SPIKED",
  "LIGHT_MELEE_WEAPON_MACE_LIGHT",
  "LIGHT_MELEE_WEAPON_SICKLE",
  "ONE_HANDED_MELEE_WEAPON_CLUB",
  "ONE_HANDED_MELEE_WEAPON_MACE_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_MORNINGSTAR",
  "ONE_HANDED_MELEE_WEAPON_SHORTSPEAR",
  "TWO_HANDED_MELEE_WEAPON_LONGSPEAR",
  "TWO_HANDED_MELEE_WEAPON_QUARTERSTAFF",
  "TWO_HANDED_MELEE_WEAPON_SPEAR",
  "RANGED_WEAPON_CROSSBOW_LIGHT",
  "RANGED_WEAPON_CROSSBOW_HEAVY",
  "RANGED_WEAPON_DART",
  "RANGED_WEAPON_JAVELIN",
  "RANGED_WEAPON_SLING",
  "LIGHT_MELEE_WEAPON_AXE_THROWING",
  "LIGHT_MELEE_WEAPON_HAMMER_LIGHT",
  "LIGHT_MELEE_WEAPON_AXE_HAND",
  "LIGHT_MELEE_WEAPON_KUKRI",
  "LIGHT_MELEE_WEAPON_PICK_LIGHT",
  "LIGHT_MELEE_WEAPON_SAP",
  "LIGHT_MELEE_WEAPON_SHIELD_LIGHT",
  "LIGHT_MELEE_WEAPON_ARMOR_SPIKED",
  "LIGHT_MELEE_WEAPON_SHIELD_LIGHT_SPIKED",
  "LIGHT_MELEE_WEAPON_SWORD_SHORT",
  "ONE_HANDED_MELEE_WEAPON_AXE_BATTLE",
  "ONE_HANDED_MELEE_WEAPON_FLAIL_LIGHT",
  "ONE_HANDED_MELEE_WEAPON_SWORD_LONG",
  "ONE_HANDED_MELEE_WEAPON_PICK_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_RAPIER",
  "ONE_HANDED_MELEE_WEAPON_SCIMITAR",
  "ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY_SPIKED",
  "ONE_HANDED_MELEE_WEAPON_TRIDENT",
  "ONE_HANDED_MELEE_WEAPON_HAMMER_WAR",
  "TWO_HANDED_MELEE_WEAPON_FALCHION",
  "TWO_HANDED_MELEE_WEAPON_GLAIVE",
  "TWO_HANDED_MELEE_WEAPON_AXE_GREAT",
  "TWO_HANDED_MELEE_WEAPON_CLUB_GREAT",
  "TWO_HANDED_MELEE_WEAPON_FLAIL_HEAVY",
  "TWO_HANDED_MELEE_WEAPON_SWORD_GREAT",
  "TWO_HANDED_MELEE_WEAPON_GUISARME",
  "TWO_HANDED_MELEE_WEAPON_HALBERD",
  "TWO_HANDED_MELEE_WEAPON_LANCE",
  "TWO_HANDED_MELEE_WEAPON_RANSEUR",
  "TWO_HANDED_MELEE_WEAPON_SCYTHE",
  "RANGED_WEAPON_BOW_SHORT",
  "RANGED_WEAPON_BOW_SHORT_COMPOSITE",
  "RANGED_WEAPON_BOW_LONG",
  "RANGED_WEAPON_BOW_LONG_COMPOSITE",
  "LIGHT_MELEE_WEAPON_KAMA",
  "LIGHT_MELEE_WEAPON_NUNCHAKU",
  "LIGHT_MELEE_WEAPON_SAI",
  "LIGHT_MELEE_WEAPON_SIANGHAM",
  "ONE_HANDED_MELEE_WEAPON_SWORD_BASTARD",
  "ONE_HANDED_MELEE_WEAPON_AXE_WAR_DWARVEN",
  "ONE_HANDED_MELEE_WEAPON_WHIP",
  "TWO_HANDED_MELEE_WEAPON_AXE_ORC_DOUBLE",
  "TWO_HANDED_MELEE_WEAPON_CHAIN_SPIKED",
  "TWO_HANDED_MELEE_WEAPON_FLAIL_DIRE",
  "TWO_HANDED_MELEE_WEAPON_HAMMER_GNOME_HOOKED",
  "TWO_HANDED_MELEE_WEAPON_SWORD_TWO_BLADED",
  "TWO_HANDED_MELEE_WEAPON_URGROSH_DWARVEN",
  "RANGED_WEAPON_BOLAS",
  "RANGED_WEAPON_CROSSBOW_HAND",
  "RANGED_WEAPON_CROSSBOW_REPEATING_LIGHT",
  "RANGED_WEAPON_CROSSBOW_REPEATING_HEAVY",
  "RANGED_WEAPON_NET",
  "RANGED_WEAPON_SHURIKEN",
  "SPECIALATTACK_INCORPOREAL_TOUCH",
  "SPECIALATTACK_SMITE"
};

const RPG_Monster_WeaponTypeUnion_XMLTree_Type::value RPG_Monster_WeaponTypeUnion_XMLTree_Type::
_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_indexes_[169] =
{
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ACID_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ALTERNATE_FORM,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ANIMAL_COMPANION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ANTIMAGIC,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_BLINDSENSE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_BLINDSIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_BONUS_FEAT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_BREATH_WEAPON,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_CHANGE_SHAPE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_CHARM,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_COMPULSION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_CONSTRICT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_CORROSIVE_SLIME,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_CRIPPLING_STRIKE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_DARKVISION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_DEATH_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_DEATH_THROES,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_DEFENSIVE_ROLL,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_DISEASE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ENERGY_DRAIN,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ENTANGLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_ETHEREALNESS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_EVASION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_FAST_HEALING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_FEAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_FLAMING_BODY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_GASEOUS_FORM,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_GAZE_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_COLD,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_DISEASE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_FIRE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_POISON,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMMUNITY_SPELL,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMPROVED_EVASION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMPROVED_GRAB,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_IMPROVED_UNCANNY_DODGE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_INCORPOREALITY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_INVISIBILITY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_LEAP_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_LEVEL_LOSS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_LOWLIGHT_VISION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_MANUFACTURED_WEAPONS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_MOVEMENT_MODES,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_NATURAL_WEAPONS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_NONABILITIES,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_OPPORTUNIST,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_PARALYZE_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_POISON_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_POLYMORPH,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_POUNCE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_POWERFUL_CHARGE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_PSIONICS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RAKE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RAY_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_REGENERATION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_REND_ARMOR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_DAMAGE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_ENERGY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_SPELL,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_RESISTANCE_TO_TURNING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SCENT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SCORE_LOSS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SENSE_TRAPS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SKILL_MASTERY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SLIPPERY_MIND,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SNEAK_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SONIC_ATTACK,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SPELLS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SPORES,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_STENCH,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SUMMON,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_SWALLOW_WHOLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_TELEPATHY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_THROW_WEB,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_TRAMPLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_TREMOR_SENSE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_UNCANNY_DODGE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_VULNERABILITY_TO_ENERGY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ABILITY_WOODLAND_STRIDE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_ARMOR_SPIKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_AXE_HAND,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_AXE_THROWING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_DAGGER,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_DAGGER_PUNCHING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_GAUNTLET_SPIKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_HAMMER_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_KAMA,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_KUKRI,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_MACE_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_NUNCHAKU,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_PICK_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SAI,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SAP,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SHIELD_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SHIELD_LIGHT_SPIKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SIANGHAM,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SICKLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::LIGHT_MELEE_WEAPON_SWORD_SHORT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_ANY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_BITE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_BLAST,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_CLAW_TALON,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_CONSTRICT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_GORE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_HOOF,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_PINCER,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_ROCK_STONE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_SLAP_SLAM,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_SPIT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_STING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_TAIL,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_TENTACLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::NATURALWEAPON_WEB,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_AXE_BATTLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_AXE_WAR_DWARVEN,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_CLUB,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_FLAIL_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_HAMMER_WAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_MACE_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_MORNINGSTAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_PICK_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_RAPIER,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SCIMITAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY_SPIKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHORTSPEAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SWORD_BASTARD,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SWORD_LONG,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_TRIDENT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_WHIP,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_BOLAS,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_BOW_LONG,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_BOW_LONG_COMPOSITE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_BOW_SHORT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_BOW_SHORT_COMPOSITE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_CROSSBOW_HAND,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_CROSSBOW_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_CROSSBOW_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_CROSSBOW_REPEATING_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_CROSSBOW_REPEATING_LIGHT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_DART,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_JAVELIN,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_NET,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_SHURIKEN,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::RANGED_WEAPON_SLING,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::SPECIALATTACK_INCORPOREAL_TOUCH,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::SPECIALATTACK_SMITE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_AXE_GREAT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_AXE_ORC_DOUBLE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_CHAIN_SPIKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_CLUB_GREAT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FALCHION,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FLAIL_DIRE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FLAIL_HEAVY,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_GLAIVE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_GUISARME,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_HALBERD,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_HAMMER_GNOME_HOOKED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_LANCE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_LONGSPEAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_QUARTERSTAFF,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_RANSEUR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SCYTHE,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SPEAR,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SWORD_GREAT,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SWORD_TWO_BLADED,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_URGROSH_DWARVEN,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::UNARMED_WEAPON_GAUNTLET,
  ::RPG_Monster_WeaponTypeUnion_XMLTree_Type::UNARMED_WEAPON_STRIKE
};

// RPG_Monster_SpecialDefensePreCondition_XMLTree_Type
//

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
RPG_Monster_SpecialDefensePreCondition_XMLTree_Type ()
: ::xml_schema::type (),
  weaponType_ (this),
  ownCondition_ (this),
  targetCondition_ (this),
  isMagicalWeapon_ (isMagicalWeapon_default_value (), this)
{
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
RPG_Monster_SpecialDefensePreCondition_XMLTree_Type (const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  weaponType_ (x.weaponType_, f, this),
  ownCondition_ (x.ownCondition_, f, this),
  targetCondition_ (x.targetCondition_, f, this),
  isMagicalWeapon_ (x.isMagicalWeapon_, f, this)
{
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
RPG_Monster_SpecialDefensePreCondition_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  weaponType_ (this),
  ownCondition_ (this),
  targetCondition_ (this),
  isMagicalWeapon_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // weaponType
    //
    if (n.name () == "weaponType" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< weaponType_type > r (
        weaponType_traits::create (i, f, this));

      this->weaponType_.push_back (::std::move (r));
      continue;
    }

    // ownCondition
    //
    if (n.name () == "ownCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< ownCondition_type > r (
        ownCondition_traits::create (i, f, this));

      this->ownCondition_.push_back (::std::move (r));
      continue;
    }

    // targetCondition
    //
    if (n.name () == "targetCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< targetCondition_type > r (
        targetCondition_traits::create (i, f, this));

      this->targetCondition_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "isMagicalWeapon" && n.namespace_ ().empty ())
    {
      this->isMagicalWeapon_.set (isMagicalWeapon_traits::create (i, f, this));
      continue;
    }
  }

  if (!isMagicalWeapon_.present ())
  {
    this->isMagicalWeapon_.set (isMagicalWeapon_default_value ());
  }
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type* RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialDefensePreCondition_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
operator= (const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->weaponType_ = x.weaponType_;
    this->ownCondition_ = x.ownCondition_;
    this->targetCondition_ = x.targetCondition_;
    this->isMagicalWeapon_ = x.isMagicalWeapon_;
  }

  return *this;
}

RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::
~RPG_Monster_SpecialDefensePreCondition_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& x, const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& y)
{
  if (!(x.weaponType () == y.weaponType ()))
    return false;

  if (!(x.ownCondition () == y.ownCondition ()))
    return false;

  if (!(x.targetCondition () == y.targetCondition ()))
    return false;

  if (!(x.isMagicalWeapon () == y.isMagicalWeapon ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& x, const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_DefenseAction_XMLTree_Type
//

RPG_Monster_DefenseAction_XMLTree_Type::
RPG_Monster_DefenseAction_XMLTree_Type ()
: ::xml_schema::type (),
  preCondition_ (this),
  damage_ (this),
  ranged_ (this)
{
}

RPG_Monster_DefenseAction_XMLTree_Type::
RPG_Monster_DefenseAction_XMLTree_Type (const RPG_Monster_DefenseAction_XMLTree_Type& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  preCondition_ (x.preCondition_, f, this),
  damage_ (x.damage_, f, this),
  ranged_ (x.ranged_, f, this)
{
}

RPG_Monster_DefenseAction_XMLTree_Type::
RPG_Monster_DefenseAction_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  preCondition_ (this),
  damage_ (this),
  ranged_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_DefenseAction_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // preCondition
    //
    if (n.name () == "preCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< preCondition_type > r (
        preCondition_traits::create (i, f, this));

      this->preCondition_.push_back (::std::move (r));
      continue;
    }

    // damage
    //
    if (n.name () == "damage" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< damage_type > r (
        damage_traits::create (i, f, this));

      if (!this->damage_)
      {
        this->damage_.set (::std::move (r));
        continue;
      }
    }

    // ranged
    //
    if (n.name () == "ranged" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< ranged_type > r (
        ranged_traits::create (i, f, this));

      if (!this->ranged_)
      {
        this->ranged_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

RPG_Monster_DefenseAction_XMLTree_Type* RPG_Monster_DefenseAction_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_DefenseAction_XMLTree_Type (*this, f, c);
}

RPG_Monster_DefenseAction_XMLTree_Type& RPG_Monster_DefenseAction_XMLTree_Type::
operator= (const RPG_Monster_DefenseAction_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->preCondition_ = x.preCondition_;
    this->damage_ = x.damage_;
    this->ranged_ = x.ranged_;
  }

  return *this;
}

RPG_Monster_DefenseAction_XMLTree_Type::
~RPG_Monster_DefenseAction_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_DefenseAction_XMLTree_Type& x, const RPG_Monster_DefenseAction_XMLTree_Type& y)
{
  if (!(x.preCondition () == y.preCondition ()))
    return false;

  if (!(x.damage () == y.damage ()))
    return false;

  if (!(x.ranged () == y.ranged ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_DefenseAction_XMLTree_Type& x, const RPG_Monster_DefenseAction_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialDefenseProperties_XMLTree_Type
//

RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
RPG_Monster_SpecialDefenseProperties_XMLTree_Type (const abilityClass_type& abilityClass,
                                                   const type_type& type,
                                                   const actionType_type& actionType)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (abilityClass,
                                                    type,
                                                    actionType),
  action_ (this)
{
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
RPG_Monster_SpecialDefenseProperties_XMLTree_Type (const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (x, f, c),
  action_ (x.action_, f, this)
{
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
RPG_Monster_SpecialDefenseProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  action_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Monster_SpecialBaseProperties_XMLTree_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // action
    //
    if (n.name () == "action" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< action_type > r (
        action_traits::create (i, f, this));

      this->action_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type* RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialDefenseProperties_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type& RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
operator= (const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (*this) = x;
    this->action_ = x.action_;
  }

  return *this;
}

RPG_Monster_SpecialDefenseProperties_XMLTree_Type::
~RPG_Monster_SpecialDefenseProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& x, const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (y)))
    return false;

  if (!(x.action () == y.action ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& x, const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_AttackAction_XMLTree_Type
//

RPG_Monster_AttackAction_XMLTree_Type::
RPG_Monster_AttackAction_XMLTree_Type (const weapon_type& weapon)
: ::xml_schema::type (),
  weapon_ (weapon, this),
  attackBonus_ (this),
  attackForm_ (this),
  damage_ (this),
  effect_ (this),
  numAttacksPerRound_ (this),
  ranged_ (this),
  trigger_ (this),
  allAdjacent_ (allAdjacent_default_value (), this),
  fullAttackIncludesNextAction_ (fullAttackIncludesNextAction_default_value (), this)
{
}

RPG_Monster_AttackAction_XMLTree_Type::
RPG_Monster_AttackAction_XMLTree_Type (const RPG_Monster_AttackAction_XMLTree_Type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  weapon_ (x.weapon_, f, this),
  attackBonus_ (x.attackBonus_, f, this),
  attackForm_ (x.attackForm_, f, this),
  damage_ (x.damage_, f, this),
  effect_ (x.effect_, f, this),
  numAttacksPerRound_ (x.numAttacksPerRound_, f, this),
  ranged_ (x.ranged_, f, this),
  trigger_ (x.trigger_, f, this),
  allAdjacent_ (x.allAdjacent_, f, this),
  fullAttackIncludesNextAction_ (x.fullAttackIncludesNextAction_, f, this)
{
}

RPG_Monster_AttackAction_XMLTree_Type::
RPG_Monster_AttackAction_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  weapon_ (this),
  attackBonus_ (this),
  attackForm_ (this),
  damage_ (this),
  effect_ (this),
  numAttacksPerRound_ (this),
  ranged_ (this),
  trigger_ (this),
  allAdjacent_ (this),
  fullAttackIncludesNextAction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Monster_AttackAction_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // weapon
    //
    if (n.name () == "weapon" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< weapon_type > r (
        weapon_traits::create (i, f, this));

      if (!weapon_.present ())
      {
        this->weapon_.set (::std::move (r));
        continue;
      }
    }

    // attackBonus
    //
    if (n.name () == "attackBonus" && n.namespace_ () == "urn:rpg")
    {
      this->attackBonus_.push_back (attackBonus_traits::create (i, f, this));
      continue;
    }

    // attackForm
    //
    if (n.name () == "attackForm" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< attackForm_type > r (
        attackForm_traits::create (i, f, this));

      this->attackForm_.push_back (::std::move (r));
      continue;
    }

    // damage
    //
    if (n.name () == "damage" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< damage_type > r (
        damage_traits::create (i, f, this));

      if (!this->damage_)
      {
        this->damage_.set (::std::move (r));
        continue;
      }
    }

    // effect
    //
    if (n.name () == "effect" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< effect_type > r (
        effect_traits::create (i, f, this));

      if (!this->effect_)
      {
        this->effect_.set (::std::move (r));
        continue;
      }
    }

    // numAttacksPerRound
    //
    if (n.name () == "numAttacksPerRound" && n.namespace_ () == "urn:rpg")
    {
      if (!this->numAttacksPerRound_)
      {
        this->numAttacksPerRound_.set (numAttacksPerRound_traits::create (i, f, this));
        continue;
      }
    }

    // ranged
    //
    if (n.name () == "ranged" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< ranged_type > r (
        ranged_traits::create (i, f, this));

      if (!this->ranged_)
      {
        this->ranged_.set (::std::move (r));
        continue;
      }
    }

    // trigger
    //
    if (n.name () == "trigger" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< trigger_type > r (
        trigger_traits::create (i, f, this));

      this->trigger_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!weapon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "weapon",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "allAdjacent" && n.namespace_ ().empty ())
    {
      this->allAdjacent_.set (allAdjacent_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fullAttackIncludesNextAction" && n.namespace_ ().empty ())
    {
      this->fullAttackIncludesNextAction_.set (fullAttackIncludesNextAction_traits::create (i, f, this));
      continue;
    }
  }

  if (!allAdjacent_.present ())
  {
    this->allAdjacent_.set (allAdjacent_default_value ());
  }

  if (!fullAttackIncludesNextAction_.present ())
  {
    this->fullAttackIncludesNextAction_.set (fullAttackIncludesNextAction_default_value ());
  }
}

RPG_Monster_AttackAction_XMLTree_Type* RPG_Monster_AttackAction_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_AttackAction_XMLTree_Type (*this, f, c);
}

RPG_Monster_AttackAction_XMLTree_Type& RPG_Monster_AttackAction_XMLTree_Type::
operator= (const RPG_Monster_AttackAction_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->weapon_ = x.weapon_;
    this->attackBonus_ = x.attackBonus_;
    this->attackForm_ = x.attackForm_;
    this->damage_ = x.damage_;
    this->effect_ = x.effect_;
    this->numAttacksPerRound_ = x.numAttacksPerRound_;
    this->ranged_ = x.ranged_;
    this->trigger_ = x.trigger_;
    this->allAdjacent_ = x.allAdjacent_;
    this->fullAttackIncludesNextAction_ = x.fullAttackIncludesNextAction_;
  }

  return *this;
}

RPG_Monster_AttackAction_XMLTree_Type::
~RPG_Monster_AttackAction_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_AttackAction_XMLTree_Type& x, const RPG_Monster_AttackAction_XMLTree_Type& y)
{
  if (!(x.weapon () == y.weapon ()))
    return false;

  if (!(x.attackBonus () == y.attackBonus ()))
    return false;

  if (!(x.attackForm () == y.attackForm ()))
    return false;

  if (!(x.damage () == y.damage ()))
    return false;

  if (!(x.effect () == y.effect ()))
    return false;

  if (!(x.numAttacksPerRound () == y.numAttacksPerRound ()))
    return false;

  if (!(x.ranged () == y.ranged ()))
    return false;

  if (!(x.trigger () == y.trigger ()))
    return false;

  if (!(x.allAdjacent () == y.allAdjacent ()))
    return false;

  if (!(x.fullAttackIncludesNextAction () == y.fullAttackIncludesNextAction ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_AttackAction_XMLTree_Type& x, const RPG_Monster_AttackAction_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Attack_XMLTree_Type
//

RPG_Monster_Attack_XMLTree_Type::
RPG_Monster_Attack_XMLTree_Type (const baseAttackBonus_type& baseAttackBonus,
                                 const grappleBonus_type& grappleBonus)
: ::xml_schema::type (),
  baseAttackBonus_ (baseAttackBonus, this),
  grappleBonus_ (grappleBonus, this),
  standardAttackAction_ (this),
  fullAttackAction_ (this),
  actionsAreInclusive_ (actionsAreInclusive_default_value (), this)
{
}

RPG_Monster_Attack_XMLTree_Type::
RPG_Monster_Attack_XMLTree_Type (const RPG_Monster_Attack_XMLTree_Type& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseAttackBonus_ (x.baseAttackBonus_, f, this),
  grappleBonus_ (x.grappleBonus_, f, this),
  standardAttackAction_ (x.standardAttackAction_, f, this),
  fullAttackAction_ (x.fullAttackAction_, f, this),
  actionsAreInclusive_ (x.actionsAreInclusive_, f, this)
{
}

RPG_Monster_Attack_XMLTree_Type::
RPG_Monster_Attack_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseAttackBonus_ (this),
  grappleBonus_ (this),
  standardAttackAction_ (this),
  fullAttackAction_ (this),
  actionsAreInclusive_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Monster_Attack_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseAttackBonus
    //
    if (n.name () == "baseAttackBonus" && n.namespace_ () == "urn:rpg")
    {
      if (!baseAttackBonus_.present ())
      {
        this->baseAttackBonus_.set (baseAttackBonus_traits::create (i, f, this));
        continue;
      }
    }

    // grappleBonus
    //
    if (n.name () == "grappleBonus" && n.namespace_ () == "urn:rpg")
    {
      if (!grappleBonus_.present ())
      {
        this->grappleBonus_.set (grappleBonus_traits::create (i, f, this));
        continue;
      }
    }

    // standardAttackAction
    //
    if (n.name () == "standardAttackAction" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< standardAttackAction_type > r (
        standardAttackAction_traits::create (i, f, this));

      this->standardAttackAction_.push_back (::std::move (r));
      continue;
    }

    // fullAttackAction
    //
    if (n.name () == "fullAttackAction" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< fullAttackAction_type > r (
        fullAttackAction_traits::create (i, f, this));

      this->fullAttackAction_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!baseAttackBonus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseAttackBonus",
      "urn:rpg");
  }

  if (!grappleBonus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "grappleBonus",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "actionsAreInclusive" && n.namespace_ ().empty ())
    {
      this->actionsAreInclusive_.set (actionsAreInclusive_traits::create (i, f, this));
      continue;
    }
  }

  if (!actionsAreInclusive_.present ())
  {
    this->actionsAreInclusive_.set (actionsAreInclusive_default_value ());
  }
}

RPG_Monster_Attack_XMLTree_Type* RPG_Monster_Attack_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Attack_XMLTree_Type (*this, f, c);
}

RPG_Monster_Attack_XMLTree_Type& RPG_Monster_Attack_XMLTree_Type::
operator= (const RPG_Monster_Attack_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->baseAttackBonus_ = x.baseAttackBonus_;
    this->grappleBonus_ = x.grappleBonus_;
    this->standardAttackAction_ = x.standardAttackAction_;
    this->fullAttackAction_ = x.fullAttackAction_;
    this->actionsAreInclusive_ = x.actionsAreInclusive_;
  }

  return *this;
}

RPG_Monster_Attack_XMLTree_Type::
~RPG_Monster_Attack_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Attack_XMLTree_Type& x, const RPG_Monster_Attack_XMLTree_Type& y)
{
  if (!(x.baseAttackBonus () == y.baseAttackBonus ()))
    return false;

  if (!(x.grappleBonus () == y.grappleBonus ()))
    return false;

  if (!(x.standardAttackAction () == y.standardAttackAction ()))
    return false;

  if (!(x.fullAttackAction () == y.fullAttackAction ()))
    return false;

  if (!(x.actionsAreInclusive () == y.actionsAreInclusive ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Attack_XMLTree_Type& x, const RPG_Monster_Attack_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_ActionTrigger_XMLTree_Type
//

RPG_Monster_ActionTrigger_XMLTree_Type::
RPG_Monster_ActionTrigger_XMLTree_Type (const weapon_type& weapon,
                                        const numHits_type& numHits)
: ::xml_schema::type (),
  weapon_ (weapon, this),
  numHits_ (numHits, this)
{
}

RPG_Monster_ActionTrigger_XMLTree_Type::
RPG_Monster_ActionTrigger_XMLTree_Type (const RPG_Monster_ActionTrigger_XMLTree_Type& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  weapon_ (x.weapon_, f, this),
  numHits_ (x.numHits_, f, this)
{
}

RPG_Monster_ActionTrigger_XMLTree_Type::
RPG_Monster_ActionTrigger_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  weapon_ (this),
  numHits_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_ActionTrigger_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // weapon
    //
    if (n.name () == "weapon" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< weapon_type > r (
        weapon_traits::create (i, f, this));

      if (!weapon_.present ())
      {
        this->weapon_.set (::std::move (r));
        continue;
      }
    }

    // numHits
    //
    if (n.name () == "numHits" && n.namespace_ () == "urn:rpg")
    {
      if (!numHits_.present ())
      {
        this->numHits_.set (numHits_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!weapon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "weapon",
      "urn:rpg");
  }

  if (!numHits_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numHits",
      "urn:rpg");
  }
}

RPG_Monster_ActionTrigger_XMLTree_Type* RPG_Monster_ActionTrigger_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_ActionTrigger_XMLTree_Type (*this, f, c);
}

RPG_Monster_ActionTrigger_XMLTree_Type& RPG_Monster_ActionTrigger_XMLTree_Type::
operator= (const RPG_Monster_ActionTrigger_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->weapon_ = x.weapon_;
    this->numHits_ = x.numHits_;
  }

  return *this;
}

RPG_Monster_ActionTrigger_XMLTree_Type::
~RPG_Monster_ActionTrigger_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_ActionTrigger_XMLTree_Type& x, const RPG_Monster_ActionTrigger_XMLTree_Type& y)
{
  if (!(x.weapon () == y.weapon ()))
    return false;

  if (!(x.numHits () == y.numHits ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_ActionTrigger_XMLTree_Type& x, const RPG_Monster_ActionTrigger_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialAttackPreCondition_XMLTree_Type
//

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
RPG_Monster_SpecialAttackPreCondition_XMLTree_Type ()
: ::xml_schema::type (),
  action_ (this),
  targetAlignment_ (this),
  ownCondition_ (this),
  targetCondition_ (this),
  minTargetSize_ (this),
  maxTargetSize_ (this),
  check_ (this)
{
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
RPG_Monster_SpecialAttackPreCondition_XMLTree_Type (const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& x,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  action_ (x.action_, f, this),
  targetAlignment_ (x.targetAlignment_, f, this),
  ownCondition_ (x.ownCondition_, f, this),
  targetCondition_ (x.targetCondition_, f, this),
  minTargetSize_ (x.minTargetSize_, f, this),
  maxTargetSize_ (x.maxTargetSize_, f, this),
  check_ (x.check_, f, this)
{
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
RPG_Monster_SpecialAttackPreCondition_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::flags f,
                                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  action_ (this),
  targetAlignment_ (this),
  ownCondition_ (this),
  targetCondition_ (this),
  minTargetSize_ (this),
  maxTargetSize_ (this),
  check_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // action
    //
    if (n.name () == "action" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< action_type > r (
        action_traits::create (i, f, this));

      if (!this->action_)
      {
        this->action_.set (::std::move (r));
        continue;
      }
    }

    // targetAlignment
    //
    if (n.name () == "targetAlignment" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< targetAlignment_type > r (
        targetAlignment_traits::create (i, f, this));

      if (!this->targetAlignment_)
      {
        this->targetAlignment_.set (::std::move (r));
        continue;
      }
    }

    // ownCondition
    //
    if (n.name () == "ownCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< ownCondition_type > r (
        ownCondition_traits::create (i, f, this));

      this->ownCondition_.push_back (::std::move (r));
      continue;
    }

    // targetCondition
    //
    if (n.name () == "targetCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< targetCondition_type > r (
        targetCondition_traits::create (i, f, this));

      this->targetCondition_.push_back (::std::move (r));
      continue;
    }

    // minTargetSize
    //
    if (n.name () == "minTargetSize" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< minTargetSize_type > r (
        minTargetSize_traits::create (i, f, this));

      if (!this->minTargetSize_)
      {
        this->minTargetSize_.set (::std::move (r));
        continue;
      }
    }

    // maxTargetSize
    //
    if (n.name () == "maxTargetSize" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< maxTargetSize_type > r (
        maxTargetSize_traits::create (i, f, this));

      if (!this->maxTargetSize_)
      {
        this->maxTargetSize_.set (::std::move (r));
        continue;
      }
    }

    // check
    //
    if (n.name () == "check" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< check_type > r (
        check_traits::create (i, f, this));

      if (!this->check_)
      {
        this->check_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type* RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialAttackPreCondition_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
operator= (const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->action_ = x.action_;
    this->targetAlignment_ = x.targetAlignment_;
    this->ownCondition_ = x.ownCondition_;
    this->targetCondition_ = x.targetCondition_;
    this->minTargetSize_ = x.minTargetSize_;
    this->maxTargetSize_ = x.maxTargetSize_;
    this->check_ = x.check_;
  }

  return *this;
}

RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::
~RPG_Monster_SpecialAttackPreCondition_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& x, const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& y)
{
  if (!(x.action () == y.action ()))
    return false;

  if (!(x.targetAlignment () == y.targetAlignment ()))
    return false;

  if (!(x.ownCondition () == y.ownCondition ()))
    return false;

  if (!(x.targetCondition () == y.targetCondition ()))
    return false;

  if (!(x.minTargetSize () == y.minTargetSize ()))
    return false;

  if (!(x.maxTargetSize () == y.maxTargetSize ()))
    return false;

  if (!(x.check () == y.check ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& x, const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialAttackProperties_XMLTree_Type
//

RPG_Monster_SpecialAttackProperties_XMLTree_Type::
RPG_Monster_SpecialAttackProperties_XMLTree_Type (const abilityClass_type& abilityClass,
                                                  const type_type& type,
                                                  const actionType_type& actionType,
                                                  const action_type& action)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (abilityClass,
                                                    type,
                                                    actionType),
  preCondition_ (this),
  action_ (action, this)
{
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::
RPG_Monster_SpecialAttackProperties_XMLTree_Type (const abilityClass_type& abilityClass,
                                                  const type_type& type,
                                                  const actionType_type& actionType,
                                                  ::std::unique_ptr< action_type > action)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (abilityClass,
                                                    type,
                                                    actionType),
  preCondition_ (this),
  action_ (std::move (action), this)
{
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::
RPG_Monster_SpecialAttackProperties_XMLTree_Type (const RPG_Monster_SpecialAttackProperties_XMLTree_Type& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (x, f, c),
  preCondition_ (x.preCondition_, f, this),
  action_ (x.action_, f, this)
{
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::
RPG_Monster_SpecialAttackProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  preCondition_ (this),
  action_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialAttackProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Monster_SpecialBaseProperties_XMLTree_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // preCondition
    //
    if (n.name () == "preCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< preCondition_type > r (
        preCondition_traits::create (i, f, this));

      this->preCondition_.push_back (::std::move (r));
      continue;
    }

    // action
    //
    if (n.name () == "action" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< action_type > r (
        action_traits::create (i, f, this));

      if (!action_.present ())
      {
        this->action_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!action_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "action",
      "urn:rpg");
  }
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type* RPG_Monster_SpecialAttackProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialAttackProperties_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type& RPG_Monster_SpecialAttackProperties_XMLTree_Type::
operator= (const RPG_Monster_SpecialAttackProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (*this) = x;
    this->preCondition_ = x.preCondition_;
    this->action_ = x.action_;
  }

  return *this;
}

RPG_Monster_SpecialAttackProperties_XMLTree_Type::
~RPG_Monster_SpecialAttackProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialAttackProperties_XMLTree_Type& x, const RPG_Monster_SpecialAttackProperties_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (y)))
    return false;

  if (!(x.preCondition () == y.preCondition ()))
    return false;

  if (!(x.action () == y.action ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialAttackProperties_XMLTree_Type& x, const RPG_Monster_SpecialAttackProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type
//

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type ()
: ::xml_schema::type (),
  targetCondition_ (this),
  maxTargetSize_ (this),
  check_ (this)
{
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type (const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  targetCondition_ (x.targetCondition_, f, this),
  maxTargetSize_ (x.maxTargetSize_, f, this),
  check_ (x.check_, f, this)
{
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  targetCondition_ (this),
  maxTargetSize_ (this),
  check_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // targetCondition
    //
    if (n.name () == "targetCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< targetCondition_type > r (
        targetCondition_traits::create (i, f, this));

      this->targetCondition_.push_back (::std::move (r));
      continue;
    }

    // maxTargetSize
    //
    if (n.name () == "maxTargetSize" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< maxTargetSize_type > r (
        maxTargetSize_traits::create (i, f, this));

      if (!this->maxTargetSize_)
      {
        this->maxTargetSize_.set (::std::move (r));
        continue;
      }
    }

    // check
    //
    if (n.name () == "check" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< check_type > r (
        check_traits::create (i, f, this));

      if (!this->check_)
      {
        this->check_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type* RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
operator= (const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->targetCondition_ = x.targetCondition_;
    this->maxTargetSize_ = x.maxTargetSize_;
    this->check_ = x.check_;
  }

  return *this;
}

RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::
~RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& x, const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& y)
{
  if (!(x.targetCondition () == y.targetCondition ()))
    return false;

  if (!(x.maxTargetSize () == y.maxTargetSize ()))
    return false;

  if (!(x.check () == y.check ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& x, const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SummonMonster_XMLTree_Type
//

RPG_Monster_SummonMonster_XMLTree_Type::
RPG_Monster_SummonMonster_XMLTree_Type (const name_type& name,
                                        const amount_type& amount)
: ::xml_schema::type (),
  name_ (name, this),
  amount_ (amount, this),
  successRate_ (successRate_default_value (), this),
  actionsAreInclusive_ (actionsAreInclusive_default_value (), this)
{
}

RPG_Monster_SummonMonster_XMLTree_Type::
RPG_Monster_SummonMonster_XMLTree_Type (const name_type& name,
                                        ::std::unique_ptr< amount_type > amount)
: ::xml_schema::type (),
  name_ (name, this),
  amount_ (std::move (amount), this),
  successRate_ (successRate_default_value (), this),
  actionsAreInclusive_ (actionsAreInclusive_default_value (), this)
{
}

RPG_Monster_SummonMonster_XMLTree_Type::
RPG_Monster_SummonMonster_XMLTree_Type (const RPG_Monster_SummonMonster_XMLTree_Type& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  amount_ (x.amount_, f, this),
  successRate_ (x.successRate_, f, this),
  actionsAreInclusive_ (x.actionsAreInclusive_, f, this)
{
}

RPG_Monster_SummonMonster_XMLTree_Type::
RPG_Monster_SummonMonster_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  amount_ (this),
  successRate_ (this),
  actionsAreInclusive_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Monster_SummonMonster_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // amount
    //
    if (n.name () == "amount" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< amount_type > r (
        amount_traits::create (i, f, this));

      if (!amount_.present ())
      {
        this->amount_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "urn:rpg");
  }

  if (!amount_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "amount",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "successRate" && n.namespace_ ().empty ())
    {
      this->successRate_.set (successRate_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "actionsAreInclusive" && n.namespace_ ().empty ())
    {
      this->actionsAreInclusive_.set (actionsAreInclusive_traits::create (i, f, this));
      continue;
    }
  }

  if (!successRate_.present ())
  {
    this->successRate_.set (successRate_default_value ());
  }

  if (!actionsAreInclusive_.present ())
  {
    this->actionsAreInclusive_.set (actionsAreInclusive_default_value ());
  }
}

RPG_Monster_SummonMonster_XMLTree_Type* RPG_Monster_SummonMonster_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SummonMonster_XMLTree_Type (*this, f, c);
}

RPG_Monster_SummonMonster_XMLTree_Type& RPG_Monster_SummonMonster_XMLTree_Type::
operator= (const RPG_Monster_SummonMonster_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->amount_ = x.amount_;
    this->successRate_ = x.successRate_;
    this->actionsAreInclusive_ = x.actionsAreInclusive_;
  }

  return *this;
}

RPG_Monster_SummonMonster_XMLTree_Type::
~RPG_Monster_SummonMonster_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SummonMonster_XMLTree_Type& x, const RPG_Monster_SummonMonster_XMLTree_Type& y)
{
  if (!(x.name () == y.name ()))
    return false;

  if (!(x.amount () == y.amount ()))
    return false;

  if (!(x.successRate () == y.successRate ()))
    return false;

  if (!(x.actionsAreInclusive () == y.actionsAreInclusive ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SummonMonster_XMLTree_Type& x, const RPG_Monster_SummonMonster_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SpecialAbilityProperties_XMLTree_Type
//

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
RPG_Monster_SpecialAbilityProperties_XMLTree_Type (const abilityClass_type& abilityClass,
                                                   const type_type& type,
                                                   const actionType_type& actionType)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (abilityClass,
                                                    type,
                                                    actionType),
  preCondition_ (this),
  summon_ (this),
  spell_ (this),
  ranged_ (this)
{
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
RPG_Monster_SpecialAbilityProperties_XMLTree_Type (const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (x, f, c),
  preCondition_ (x.preCondition_, f, this),
  summon_ (x.summon_, f, this),
  spell_ (x.spell_, f, this),
  ranged_ (x.ranged_, f, this)
{
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
RPG_Monster_SpecialAbilityProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
: ::RPG_Monster_SpecialBaseProperties_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  preCondition_ (this),
  summon_ (this),
  spell_ (this),
  ranged_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Monster_SpecialBaseProperties_XMLTree_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // preCondition
    //
    if (n.name () == "preCondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< preCondition_type > r (
        preCondition_traits::create (i, f, this));

      this->preCondition_.push_back (::std::move (r));
      continue;
    }

    // summon
    //
    if (n.name () == "summon" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< summon_type > r (
        summon_traits::create (i, f, this));

      this->summon_.push_back (::std::move (r));
      continue;
    }

    // spell
    //
    if (n.name () == "spell" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< spell_type > r (
        spell_traits::create (i, f, this));

      this->spell_.push_back (::std::move (r));
      continue;
    }

    // ranged
    //
    if (n.name () == "ranged" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< ranged_type > r (
        ranged_traits::create (i, f, this));

      if (!this->ranged_)
      {
        this->ranged_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type* RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SpecialAbilityProperties_XMLTree_Type (*this, f, c);
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type& RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
operator= (const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (*this) = x;
    this->preCondition_ = x.preCondition_;
    this->summon_ = x.summon_;
    this->spell_ = x.spell_;
    this->ranged_ = x.ranged_;
  }

  return *this;
}

RPG_Monster_SpecialAbilityProperties_XMLTree_Type::
~RPG_Monster_SpecialAbilityProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& x, const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (y)))
    return false;

  if (!(x.preCondition () == y.preCondition ()))
    return false;

  if (!(x.summon () == y.summon ()))
    return false;

  if (!(x.spell () == y.spell ()))
    return false;

  if (!(x.ranged () == y.ranged ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& x, const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_SavingThrowModifiers_XMLTree_Type
//

RPG_Monster_SavingThrowModifiers_XMLTree_Type::
RPG_Monster_SavingThrowModifiers_XMLTree_Type (const fortitude_type& fortitude,
                                               const reflex_type& reflex,
                                               const will_type& will)
: ::xml_schema::type (),
  fortitude_ (fortitude, this),
  reflex_ (reflex, this),
  will_ (will, this)
{
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::
RPG_Monster_SavingThrowModifiers_XMLTree_Type (const RPG_Monster_SavingThrowModifiers_XMLTree_Type& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  fortitude_ (x.fortitude_, f, this),
  reflex_ (x.reflex_, f, this),
  will_ (x.will_, f, this)
{
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::
RPG_Monster_SavingThrowModifiers_XMLTree_Type (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  fortitude_ (this),
  reflex_ (this),
  will_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_SavingThrowModifiers_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // fortitude
    //
    if (n.name () == "fortitude" && n.namespace_ () == "urn:rpg")
    {
      if (!fortitude_.present ())
      {
        this->fortitude_.set (fortitude_traits::create (i, f, this));
        continue;
      }
    }

    // reflex
    //
    if (n.name () == "reflex" && n.namespace_ () == "urn:rpg")
    {
      if (!reflex_.present ())
      {
        this->reflex_.set (reflex_traits::create (i, f, this));
        continue;
      }
    }

    // will
    //
    if (n.name () == "will" && n.namespace_ () == "urn:rpg")
    {
      if (!will_.present ())
      {
        this->will_.set (will_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!fortitude_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fortitude",
      "urn:rpg");
  }

  if (!reflex_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "reflex",
      "urn:rpg");
  }

  if (!will_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "will",
      "urn:rpg");
  }
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type* RPG_Monster_SavingThrowModifiers_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_SavingThrowModifiers_XMLTree_Type (*this, f, c);
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type& RPG_Monster_SavingThrowModifiers_XMLTree_Type::
operator= (const RPG_Monster_SavingThrowModifiers_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->fortitude_ = x.fortitude_;
    this->reflex_ = x.reflex_;
    this->will_ = x.will_;
  }

  return *this;
}

RPG_Monster_SavingThrowModifiers_XMLTree_Type::
~RPG_Monster_SavingThrowModifiers_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_SavingThrowModifiers_XMLTree_Type& x, const RPG_Monster_SavingThrowModifiers_XMLTree_Type& y)
{
  if (!(x.fortitude () == y.fortitude ()))
    return false;

  if (!(x.reflex () == y.reflex ()))
    return false;

  if (!(x.will () == y.will ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_SavingThrowModifiers_XMLTree_Type& x, const RPG_Monster_SavingThrowModifiers_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Organization_XMLTree_Type
//

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Monster_Organization_XMLTree_Type_convert ();
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Monster_Organization_XMLTree_Type_convert ();
}

RPG_Monster_Organization_XMLTree_Type::
RPG_Monster_Organization_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Monster_Organization_XMLTree_Type_convert ();
}

RPG_Monster_Organization_XMLTree_Type* RPG_Monster_Organization_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Organization_XMLTree_Type (*this, f, c);
}

RPG_Monster_Organization_XMLTree_Type::value RPG_Monster_Organization_XMLTree_Type::
_xsd_RPG_Monster_Organization_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Monster_Organization_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Monster_Organization_XMLTree_Type_indexes_,
                    _xsd_RPG_Monster_Organization_XMLTree_Type_indexes_ + 25,
                    *this,
                    c));

  if (i == _xsd_RPG_Monster_Organization_XMLTree_Type_indexes_ + 25 || _xsd_RPG_Monster_Organization_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Monster_Organization_XMLTree_Type::
_xsd_RPG_Monster_Organization_XMLTree_Type_literals_[25] =
{
  "ORGANIZATION_ANY",
  "ORGANIZATION_BAND",
  "ORGANIZATION_BROOD",
  "ORGANIZATION_COLONY",
  "ORGANIZATION_CLAN",
  "ORGANIZATION_CLUSTER",
  "ORGANIZATION_CLUTCH",
  "ORGANIZATION_COMPANY",
  "ORGANIZATION_CROWD",
  "ORGANIZATION_FLIGHT",
  "ORGANIZATION_FLOCK",
  "ORGANIZATION_GANG",
  "ORGANIZATION_GROUP",
  "ORGANIZATION_MOB",
  "ORGANIZATION_PACK",
  "ORGANIZATION_PAIR",
  "ORGANIZATION_PATCH",
  "ORGANIZATION_PRIDE",
  "ORGANIZATION_SOLITARY",
  "ORGANIZATION_SQUAD",
  "ORGANIZATION_SWARM",
  "ORGANIZATION_TEAM",
  "ORGANIZATION_TRIBE",
  "ORGANIZATION_TROOP",
  "ORGANIZATION_TROUPE"
};

const RPG_Monster_Organization_XMLTree_Type::value RPG_Monster_Organization_XMLTree_Type::
_xsd_RPG_Monster_Organization_XMLTree_Type_indexes_[25] =
{
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_ANY,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_BAND,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_BROOD,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_CLAN,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_CLUSTER,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_CLUTCH,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_COLONY,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_COMPANY,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_CROWD,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_FLIGHT,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_FLOCK,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_GANG,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_GROUP,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_MOB,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_PACK,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_PAIR,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_PATCH,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_PRIDE,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_SOLITARY,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_SQUAD,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_SWARM,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_TEAM,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_TRIBE,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_TROOP,
  ::RPG_Monster_Organization_XMLTree_Type::ORGANIZATION_TROUPE
};

// RPG_Monster_OrganizationSlaverStep_XMLTree_Type
//

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
RPG_Monster_OrganizationSlaverStep_XMLTree_Type (const name_type& name,
                                                 const range_type& range)
: ::xml_schema::type (),
  name_ (name, this),
  range_ (range, this)
{
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
RPG_Monster_OrganizationSlaverStep_XMLTree_Type (const name_type& name,
                                                 ::std::unique_ptr< range_type > range)
: ::xml_schema::type (),
  name_ (name, this),
  range_ (std::move (range), this)
{
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
RPG_Monster_OrganizationSlaverStep_XMLTree_Type (const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  range_ (x.range_, f, this)
{
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
RPG_Monster_OrganizationSlaverStep_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  range_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // range
    //
    if (n.name () == "range" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< range_type > r (
        range_traits::create (i, f, this));

      if (!range_.present ())
      {
        this->range_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "urn:rpg");
  }

  if (!range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "range",
      "urn:rpg");
  }
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type* RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_OrganizationSlaverStep_XMLTree_Type (*this, f, c);
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type& RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
operator= (const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->range_ = x.range_;
  }

  return *this;
}

RPG_Monster_OrganizationSlaverStep_XMLTree_Type::
~RPG_Monster_OrganizationSlaverStep_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& x, const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& y)
{
  if (!(x.name () == y.name ()))
    return false;

  if (!(x.range () == y.range ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& x, const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_OrganizationStep_XMLTree_Type
//

RPG_Monster_OrganizationStep_XMLTree_Type::
RPG_Monster_OrganizationStep_XMLTree_Type (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this),
  range_ (this),
  slaves_ (this)
{
}

RPG_Monster_OrganizationStep_XMLTree_Type::
RPG_Monster_OrganizationStep_XMLTree_Type (const RPG_Monster_OrganizationStep_XMLTree_Type& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  range_ (x.range_, f, this),
  slaves_ (x.slaves_, f, this)
{
}

RPG_Monster_OrganizationStep_XMLTree_Type::
RPG_Monster_OrganizationStep_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  range_ (this),
  slaves_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_OrganizationStep_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // range
    //
    if (n.name () == "range" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< range_type > r (
        range_traits::create (i, f, this));

      if (!this->range_)
      {
        this->range_.set (::std::move (r));
        continue;
      }
    }

    // slaves
    //
    if (n.name () == "slaves" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< slaves_type > r (
        slaves_traits::create (i, f, this));

      this->slaves_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }
}

RPG_Monster_OrganizationStep_XMLTree_Type* RPG_Monster_OrganizationStep_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_OrganizationStep_XMLTree_Type (*this, f, c);
}

RPG_Monster_OrganizationStep_XMLTree_Type& RPG_Monster_OrganizationStep_XMLTree_Type::
operator= (const RPG_Monster_OrganizationStep_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->range_ = x.range_;
    this->slaves_ = x.slaves_;
  }

  return *this;
}

RPG_Monster_OrganizationStep_XMLTree_Type::
~RPG_Monster_OrganizationStep_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_OrganizationStep_XMLTree_Type& x, const RPG_Monster_OrganizationStep_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.range () == y.range ()))
    return false;

  if (!(x.slaves () == y.slaves ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_OrganizationStep_XMLTree_Type& x, const RPG_Monster_OrganizationStep_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Organizations_XMLTree_Type
//

RPG_Monster_Organizations_XMLTree_Type::
RPG_Monster_Organizations_XMLTree_Type ()
: ::xml_schema::type (),
  step_ (this)
{
}

RPG_Monster_Organizations_XMLTree_Type::
RPG_Monster_Organizations_XMLTree_Type (const RPG_Monster_Organizations_XMLTree_Type& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  step_ (x.step_, f, this)
{
}

RPG_Monster_Organizations_XMLTree_Type::
RPG_Monster_Organizations_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  step_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_Organizations_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // step
    //
    if (n.name () == "step" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< step_type > r (
        step_traits::create (i, f, this));

      this->step_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

RPG_Monster_Organizations_XMLTree_Type* RPG_Monster_Organizations_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Organizations_XMLTree_Type (*this, f, c);
}

RPG_Monster_Organizations_XMLTree_Type& RPG_Monster_Organizations_XMLTree_Type::
operator= (const RPG_Monster_Organizations_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->step_ = x.step_;
  }

  return *this;
}

RPG_Monster_Organizations_XMLTree_Type::
~RPG_Monster_Organizations_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Organizations_XMLTree_Type& x, const RPG_Monster_Organizations_XMLTree_Type& y)
{
  if (!(x.step () == y.step ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Organizations_XMLTree_Type& x, const RPG_Monster_Organizations_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_AdvancementStep_XMLTree_Type
//

RPG_Monster_AdvancementStep_XMLTree_Type::
RPG_Monster_AdvancementStep_XMLTree_Type (const size_type& size,
                                          const range_type& range)
: ::xml_schema::type (),
  size_ (size, this),
  range_ (range, this)
{
}

RPG_Monster_AdvancementStep_XMLTree_Type::
RPG_Monster_AdvancementStep_XMLTree_Type (const size_type& size,
                                          ::std::unique_ptr< range_type > range)
: ::xml_schema::type (),
  size_ (size, this),
  range_ (std::move (range), this)
{
}

RPG_Monster_AdvancementStep_XMLTree_Type::
RPG_Monster_AdvancementStep_XMLTree_Type (const RPG_Monster_AdvancementStep_XMLTree_Type& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  size_ (x.size_, f, this),
  range_ (x.range_, f, this)
{
}

RPG_Monster_AdvancementStep_XMLTree_Type::
RPG_Monster_AdvancementStep_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  size_ (this),
  range_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_AdvancementStep_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // size
    //
    if (n.name () == "size" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // range
    //
    if (n.name () == "range" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< range_type > r (
        range_traits::create (i, f, this));

      if (!range_.present ())
      {
        this->range_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "urn:rpg");
  }

  if (!range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "range",
      "urn:rpg");
  }
}

RPG_Monster_AdvancementStep_XMLTree_Type* RPG_Monster_AdvancementStep_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_AdvancementStep_XMLTree_Type (*this, f, c);
}

RPG_Monster_AdvancementStep_XMLTree_Type& RPG_Monster_AdvancementStep_XMLTree_Type::
operator= (const RPG_Monster_AdvancementStep_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->size_ = x.size_;
    this->range_ = x.range_;
  }

  return *this;
}

RPG_Monster_AdvancementStep_XMLTree_Type::
~RPG_Monster_AdvancementStep_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_AdvancementStep_XMLTree_Type& x, const RPG_Monster_AdvancementStep_XMLTree_Type& y)
{
  if (!(x.size () == y.size ()))
    return false;

  if (!(x.range () == y.range ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_AdvancementStep_XMLTree_Type& x, const RPG_Monster_AdvancementStep_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Advancement_XMLTree_Type
//

RPG_Monster_Advancement_XMLTree_Type::
RPG_Monster_Advancement_XMLTree_Type ()
: ::xml_schema::type (),
  step_ (this)
{
}

RPG_Monster_Advancement_XMLTree_Type::
RPG_Monster_Advancement_XMLTree_Type (const RPG_Monster_Advancement_XMLTree_Type& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  step_ (x.step_, f, this)
{
}

RPG_Monster_Advancement_XMLTree_Type::
RPG_Monster_Advancement_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  step_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_Advancement_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // step
    //
    if (n.name () == "step" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< step_type > r (
        step_traits::create (i, f, this));

      this->step_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

RPG_Monster_Advancement_XMLTree_Type* RPG_Monster_Advancement_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Advancement_XMLTree_Type (*this, f, c);
}

RPG_Monster_Advancement_XMLTree_Type& RPG_Monster_Advancement_XMLTree_Type::
operator= (const RPG_Monster_Advancement_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->step_ = x.step_;
  }

  return *this;
}

RPG_Monster_Advancement_XMLTree_Type::
~RPG_Monster_Advancement_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Advancement_XMLTree_Type& x, const RPG_Monster_Advancement_XMLTree_Type& y)
{
  if (!(x.step () == y.step ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Advancement_XMLTree_Type& x, const RPG_Monster_Advancement_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_PropertiesXML_XMLTree_Type
//

RPG_Monster_PropertiesXML_XMLTree_Type::
RPG_Monster_PropertiesXML_XMLTree_Type (const name_type& name,
                                        const size_type& size,
                                        const type_type& type,
                                        const hitDice_type& hitDice,
                                        const initiative_type& initiative,
                                        const speed_type& speed,
                                        const armorClass_type& armorClass,
                                        const attack_type& attack,
                                        const space_type& space,
                                        const reach_type& reach,
                                        const saves_type& saves,
                                        const attributes_type& attributes,
                                        const environment_type& environment,
                                        const organizations_type& organizations,
                                        const challengeRating_type& challengeRating,
                                        const treasureModifier_type& treasureModifier,
                                        const alignment_type& alignment,
                                        const levelAdjustment_type& levelAdjustment)
: ::xml_schema::type (),
  name_ (name, this),
  size_ (size, this),
  type_ (type, this),
  hitDice_ (hitDice, this),
  initiative_ (initiative, this),
  speed_ (speed, this),
  armorClass_ (armorClass, this),
  specialDefense_ (this),
  attack_ (attack, this),
  specialAttack_ (this),
  specialAbility_ (this),
  space_ (space, this),
  reach_ (reach, this),
  saves_ (saves, this),
  attributes_ (attributes, this),
  skills_ (this),
  feats_ (this),
  environment_ (environment, this),
  organizations_ (organizations, this),
  challengeRating_ (challengeRating, this),
  treasureModifier_ (treasureModifier, this),
  alignment_ (alignment, this),
  advancements_ (this),
  levelAdjustment_ (levelAdjustment, this)
{
}

RPG_Monster_PropertiesXML_XMLTree_Type::
RPG_Monster_PropertiesXML_XMLTree_Type (const name_type& name,
                                        ::std::unique_ptr< size_type > size,
                                        ::std::unique_ptr< type_type > type,
                                        ::std::unique_ptr< hitDice_type > hitDice,
                                        const initiative_type& initiative,
                                        const speed_type& speed,
                                        ::std::unique_ptr< armorClass_type > armorClass,
                                        ::std::unique_ptr< attack_type > attack,
                                        const space_type& space,
                                        const reach_type& reach,
                                        ::std::unique_ptr< saves_type > saves,
                                        ::std::unique_ptr< attributes_type > attributes,
                                        ::std::unique_ptr< environment_type > environment,
                                        ::std::unique_ptr< organizations_type > organizations,
                                        const challengeRating_type& challengeRating,
                                        const treasureModifier_type& treasureModifier,
                                        ::std::unique_ptr< alignment_type > alignment,
                                        const levelAdjustment_type& levelAdjustment)
: ::xml_schema::type (),
  name_ (name, this),
  size_ (std::move (size), this),
  type_ (std::move (type), this),
  hitDice_ (std::move (hitDice), this),
  initiative_ (initiative, this),
  speed_ (speed, this),
  armorClass_ (std::move (armorClass), this),
  specialDefense_ (this),
  attack_ (std::move (attack), this),
  specialAttack_ (this),
  specialAbility_ (this),
  space_ (space, this),
  reach_ (reach, this),
  saves_ (std::move (saves), this),
  attributes_ (std::move (attributes), this),
  skills_ (this),
  feats_ (this),
  environment_ (std::move (environment), this),
  organizations_ (std::move (organizations), this),
  challengeRating_ (challengeRating, this),
  treasureModifier_ (treasureModifier, this),
  alignment_ (std::move (alignment), this),
  advancements_ (this),
  levelAdjustment_ (levelAdjustment, this)
{
}

RPG_Monster_PropertiesXML_XMLTree_Type::
RPG_Monster_PropertiesXML_XMLTree_Type (const RPG_Monster_PropertiesXML_XMLTree_Type& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  size_ (x.size_, f, this),
  type_ (x.type_, f, this),
  hitDice_ (x.hitDice_, f, this),
  initiative_ (x.initiative_, f, this),
  speed_ (x.speed_, f, this),
  armorClass_ (x.armorClass_, f, this),
  specialDefense_ (x.specialDefense_, f, this),
  attack_ (x.attack_, f, this),
  specialAttack_ (x.specialAttack_, f, this),
  specialAbility_ (x.specialAbility_, f, this),
  space_ (x.space_, f, this),
  reach_ (x.reach_, f, this),
  saves_ (x.saves_, f, this),
  attributes_ (x.attributes_, f, this),
  skills_ (x.skills_, f, this),
  feats_ (x.feats_, f, this),
  environment_ (x.environment_, f, this),
  organizations_ (x.organizations_, f, this),
  challengeRating_ (x.challengeRating_, f, this),
  treasureModifier_ (x.treasureModifier_, f, this),
  alignment_ (x.alignment_, f, this),
  advancements_ (x.advancements_, f, this),
  levelAdjustment_ (x.levelAdjustment_, f, this)
{
}

RPG_Monster_PropertiesXML_XMLTree_Type::
RPG_Monster_PropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  size_ (this),
  type_ (this),
  hitDice_ (this),
  initiative_ (this),
  speed_ (this),
  armorClass_ (this),
  specialDefense_ (this),
  attack_ (this),
  specialAttack_ (this),
  specialAbility_ (this),
  space_ (this),
  reach_ (this),
  saves_ (this),
  attributes_ (this),
  skills_ (this),
  feats_ (this),
  environment_ (this),
  organizations_ (this),
  challengeRating_ (this),
  treasureModifier_ (this),
  alignment_ (this),
  advancements_ (this),
  levelAdjustment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_PropertiesXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // size
    //
    if (n.name () == "size" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // hitDice
    //
    if (n.name () == "hitDice" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< hitDice_type > r (
        hitDice_traits::create (i, f, this));

      if (!hitDice_.present ())
      {
        this->hitDice_.set (::std::move (r));
        continue;
      }
    }

    // initiative
    //
    if (n.name () == "initiative" && n.namespace_ () == "urn:rpg")
    {
      if (!initiative_.present ())
      {
        this->initiative_.set (initiative_traits::create (i, f, this));
        continue;
      }
    }

    // speed
    //
    if (n.name () == "speed" && n.namespace_ () == "urn:rpg")
    {
      if (!speed_.present ())
      {
        this->speed_.set (speed_traits::create (i, f, this));
        continue;
      }
    }

    // armorClass
    //
    if (n.name () == "armorClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< armorClass_type > r (
        armorClass_traits::create (i, f, this));

      if (!armorClass_.present ())
      {
        this->armorClass_.set (::std::move (r));
        continue;
      }
    }

    // specialDefense
    //
    if (n.name () == "specialDefense" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< specialDefense_type > r (
        specialDefense_traits::create (i, f, this));

      this->specialDefense_.push_back (::std::move (r));
      continue;
    }

    // attack
    //
    if (n.name () == "attack" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< attack_type > r (
        attack_traits::create (i, f, this));

      if (!attack_.present ())
      {
        this->attack_.set (::std::move (r));
        continue;
      }
    }

    // specialAttack
    //
    if (n.name () == "specialAttack" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< specialAttack_type > r (
        specialAttack_traits::create (i, f, this));

      this->specialAttack_.push_back (::std::move (r));
      continue;
    }

    // specialAbility
    //
    if (n.name () == "specialAbility" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< specialAbility_type > r (
        specialAbility_traits::create (i, f, this));

      this->specialAbility_.push_back (::std::move (r));
      continue;
    }

    // space
    //
    if (n.name () == "space" && n.namespace_ () == "urn:rpg")
    {
      if (!space_.present ())
      {
        this->space_.set (space_traits::create (i, f, this));
        continue;
      }
    }

    // reach
    //
    if (n.name () == "reach" && n.namespace_ () == "urn:rpg")
    {
      if (!reach_.present ())
      {
        this->reach_.set (reach_traits::create (i, f, this));
        continue;
      }
    }

    // saves
    //
    if (n.name () == "saves" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< saves_type > r (
        saves_traits::create (i, f, this));

      if (!saves_.present ())
      {
        this->saves_.set (::std::move (r));
        continue;
      }
    }

    // attributes
    //
    if (n.name () == "attributes" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< attributes_type > r (
        attributes_traits::create (i, f, this));

      if (!attributes_.present ())
      {
        this->attributes_.set (::std::move (r));
        continue;
      }
    }

    // skills
    //
    if (n.name () == "skills" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< skills_type > r (
        skills_traits::create (i, f, this));

      if (!this->skills_)
      {
        this->skills_.set (::std::move (r));
        continue;
      }
    }

    // feats
    //
    if (n.name () == "feats" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< feats_type > r (
        feats_traits::create (i, f, this));

      if (!this->feats_)
      {
        this->feats_.set (::std::move (r));
        continue;
      }
    }

    // environment
    //
    if (n.name () == "environment" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< environment_type > r (
        environment_traits::create (i, f, this));

      if (!environment_.present ())
      {
        this->environment_.set (::std::move (r));
        continue;
      }
    }

    // organizations
    //
    if (n.name () == "organizations" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< organizations_type > r (
        organizations_traits::create (i, f, this));

      if (!organizations_.present ())
      {
        this->organizations_.set (::std::move (r));
        continue;
      }
    }

    // challengeRating
    //
    if (n.name () == "challengeRating" && n.namespace_ () == "urn:rpg")
    {
      if (!challengeRating_.present ())
      {
        this->challengeRating_.set (challengeRating_traits::create (i, f, this));
        continue;
      }
    }

    // treasureModifier
    //
    if (n.name () == "treasureModifier" && n.namespace_ () == "urn:rpg")
    {
      if (!treasureModifier_.present ())
      {
        this->treasureModifier_.set (treasureModifier_traits::create (i, f, this));
        continue;
      }
    }

    // alignment
    //
    if (n.name () == "alignment" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< alignment_type > r (
        alignment_traits::create (i, f, this));

      if (!alignment_.present ())
      {
        this->alignment_.set (::std::move (r));
        continue;
      }
    }

    // advancements
    //
    if (n.name () == "advancements" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< advancements_type > r (
        advancements_traits::create (i, f, this));

      if (!this->advancements_)
      {
        this->advancements_.set (::std::move (r));
        continue;
      }
    }

    // levelAdjustment
    //
    if (n.name () == "levelAdjustment" && n.namespace_ () == "urn:rpg")
    {
      if (!levelAdjustment_.present ())
      {
        this->levelAdjustment_.set (levelAdjustment_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "urn:rpg");
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "urn:rpg");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!hitDice_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "hitDice",
      "urn:rpg");
  }

  if (!initiative_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initiative",
      "urn:rpg");
  }

  if (!speed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "speed",
      "urn:rpg");
  }

  if (!armorClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "armorClass",
      "urn:rpg");
  }

  if (!attack_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "attack",
      "urn:rpg");
  }

  if (!space_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "space",
      "urn:rpg");
  }

  if (!reach_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "reach",
      "urn:rpg");
  }

  if (!saves_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "saves",
      "urn:rpg");
  }

  if (!attributes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "attributes",
      "urn:rpg");
  }

  if (!environment_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "environment",
      "urn:rpg");
  }

  if (!organizations_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "organizations",
      "urn:rpg");
  }

  if (!challengeRating_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "challengeRating",
      "urn:rpg");
  }

  if (!treasureModifier_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "treasureModifier",
      "urn:rpg");
  }

  if (!alignment_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "alignment",
      "urn:rpg");
  }

  if (!levelAdjustment_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "levelAdjustment",
      "urn:rpg");
  }
}

RPG_Monster_PropertiesXML_XMLTree_Type* RPG_Monster_PropertiesXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_PropertiesXML_XMLTree_Type (*this, f, c);
}

RPG_Monster_PropertiesXML_XMLTree_Type& RPG_Monster_PropertiesXML_XMLTree_Type::
operator= (const RPG_Monster_PropertiesXML_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->size_ = x.size_;
    this->type_ = x.type_;
    this->hitDice_ = x.hitDice_;
    this->initiative_ = x.initiative_;
    this->speed_ = x.speed_;
    this->armorClass_ = x.armorClass_;
    this->specialDefense_ = x.specialDefense_;
    this->attack_ = x.attack_;
    this->specialAttack_ = x.specialAttack_;
    this->specialAbility_ = x.specialAbility_;
    this->space_ = x.space_;
    this->reach_ = x.reach_;
    this->saves_ = x.saves_;
    this->attributes_ = x.attributes_;
    this->skills_ = x.skills_;
    this->feats_ = x.feats_;
    this->environment_ = x.environment_;
    this->organizations_ = x.organizations_;
    this->challengeRating_ = x.challengeRating_;
    this->treasureModifier_ = x.treasureModifier_;
    this->alignment_ = x.alignment_;
    this->advancements_ = x.advancements_;
    this->levelAdjustment_ = x.levelAdjustment_;
  }

  return *this;
}

RPG_Monster_PropertiesXML_XMLTree_Type::
~RPG_Monster_PropertiesXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_PropertiesXML_XMLTree_Type& x, const RPG_Monster_PropertiesXML_XMLTree_Type& y)
{
  if (!(x.name () == y.name ()))
    return false;

  if (!(x.size () == y.size ()))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.hitDice () == y.hitDice ()))
    return false;

  if (!(x.initiative () == y.initiative ()))
    return false;

  if (!(x.speed () == y.speed ()))
    return false;

  if (!(x.armorClass () == y.armorClass ()))
    return false;

  if (!(x.specialDefense () == y.specialDefense ()))
    return false;

  if (!(x.attack () == y.attack ()))
    return false;

  if (!(x.specialAttack () == y.specialAttack ()))
    return false;

  if (!(x.specialAbility () == y.specialAbility ()))
    return false;

  if (!(x.space () == y.space ()))
    return false;

  if (!(x.reach () == y.reach ()))
    return false;

  if (!(x.saves () == y.saves ()))
    return false;

  if (!(x.attributes () == y.attributes ()))
    return false;

  if (!(x.skills () == y.skills ()))
    return false;

  if (!(x.feats () == y.feats ()))
    return false;

  if (!(x.environment () == y.environment ()))
    return false;

  if (!(x.organizations () == y.organizations ()))
    return false;

  if (!(x.challengeRating () == y.challengeRating ()))
    return false;

  if (!(x.treasureModifier () == y.treasureModifier ()))
    return false;

  if (!(x.alignment () == y.alignment ()))
    return false;

  if (!(x.advancements () == y.advancements ()))
    return false;

  if (!(x.levelAdjustment () == y.levelAdjustment ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_PropertiesXML_XMLTree_Type& x, const RPG_Monster_PropertiesXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_StateBase_XMLTree_Type
//

RPG_Monster_StateBase_XMLTree_Type::
RPG_Monster_StateBase_XMLTree_Type (const conditions_type& conditions,
                                    const HP_type& HP,
                                    const gold_type& gold,
                                    const maxHP_type& maxHP)
: ::RPG_Player_StateBase_XMLTree_Type (conditions,
                                       HP),
  gold_ (gold, this),
  inventory_ (this),
  maxHP_ (maxHP, this)
{
}

RPG_Monster_StateBase_XMLTree_Type::
RPG_Monster_StateBase_XMLTree_Type (::std::unique_ptr< conditions_type > conditions,
                                    const HP_type& HP,
                                    const gold_type& gold,
                                    const maxHP_type& maxHP)
: ::RPG_Player_StateBase_XMLTree_Type (std::move (conditions),
                                       HP),
  gold_ (gold, this),
  inventory_ (this),
  maxHP_ (maxHP, this)
{
}

RPG_Monster_StateBase_XMLTree_Type::
RPG_Monster_StateBase_XMLTree_Type (const RPG_Monster_StateBase_XMLTree_Type& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::RPG_Player_StateBase_XMLTree_Type (x, f, c),
  gold_ (x.gold_, f, this),
  inventory_ (x.inventory_, f, this),
  maxHP_ (x.maxHP_, f, this)
{
}

RPG_Monster_StateBase_XMLTree_Type::
RPG_Monster_StateBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::RPG_Player_StateBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  gold_ (this),
  inventory_ (this),
  maxHP_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_StateBase_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Player_StateBase_XMLTree_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // gold
    //
    if (n.name () == "gold" && n.namespace_ () == "urn:rpg")
    {
      if (!gold_.present ())
      {
        this->gold_.set (gold_traits::create (i, f, this));
        continue;
      }
    }

    // inventory
    //
    if (n.name () == "inventory" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< inventory_type > r (
        inventory_traits::create (i, f, this));

      if (!this->inventory_)
      {
        this->inventory_.set (::std::move (r));
        continue;
      }
    }

    // maxHP
    //
    if (n.name () == "maxHP" && n.namespace_ () == "urn:rpg")
    {
      if (!maxHP_.present ())
      {
        this->maxHP_.set (maxHP_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!gold_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gold",
      "urn:rpg");
  }

  if (!maxHP_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxHP",
      "urn:rpg");
  }
}

RPG_Monster_StateBase_XMLTree_Type* RPG_Monster_StateBase_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_StateBase_XMLTree_Type (*this, f, c);
}

RPG_Monster_StateBase_XMLTree_Type& RPG_Monster_StateBase_XMLTree_Type::
operator= (const RPG_Monster_StateBase_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Player_StateBase_XMLTree_Type& > (*this) = x;
    this->gold_ = x.gold_;
    this->inventory_ = x.inventory_;
    this->maxHP_ = x.maxHP_;
  }

  return *this;
}

RPG_Monster_StateBase_XMLTree_Type::
~RPG_Monster_StateBase_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_StateBase_XMLTree_Type& x, const RPG_Monster_StateBase_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Player_StateBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Player_StateBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.gold () == y.gold ()))
    return false;

  if (!(x.inventory () == y.inventory ()))
    return false;

  if (!(x.maxHP () == y.maxHP ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_StateBase_XMLTree_Type& x, const RPG_Monster_StateBase_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_State_XMLTree_Type
//

RPG_Monster_State_XMLTree_Type::
RPG_Monster_State_XMLTree_Type (const conditions_type& conditions,
                                const HP_type& HP,
                                const gold_type& gold,
                                const maxHP_type& maxHP,
                                const type_type& type)
: ::RPG_Monster_StateBase_XMLTree_Type (conditions,
                                        HP,
                                        gold,
                                        maxHP),
  type_ (type, this)
{
}

RPG_Monster_State_XMLTree_Type::
RPG_Monster_State_XMLTree_Type (::std::unique_ptr< conditions_type > conditions,
                                const HP_type& HP,
                                const gold_type& gold,
                                const maxHP_type& maxHP,
                                const type_type& type)
: ::RPG_Monster_StateBase_XMLTree_Type (std::move (conditions),
                                        HP,
                                        gold,
                                        maxHP),
  type_ (type, this)
{
}

RPG_Monster_State_XMLTree_Type::
RPG_Monster_State_XMLTree_Type (const RPG_Monster_State_XMLTree_Type& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::RPG_Monster_StateBase_XMLTree_Type (x, f, c),
  type_ (x.type_, f, this)
{
}

RPG_Monster_State_XMLTree_Type::
RPG_Monster_State_XMLTree_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::RPG_Monster_StateBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_State_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Monster_StateBase_XMLTree_Type::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }
}

RPG_Monster_State_XMLTree_Type* RPG_Monster_State_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_State_XMLTree_Type (*this, f, c);
}

RPG_Monster_State_XMLTree_Type& RPG_Monster_State_XMLTree_Type::
operator= (const RPG_Monster_State_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Monster_StateBase_XMLTree_Type& > (*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

RPG_Monster_State_XMLTree_Type::
~RPG_Monster_State_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_State_XMLTree_Type& x, const RPG_Monster_State_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Monster_StateBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Monster_StateBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_State_XMLTree_Type& x, const RPG_Monster_State_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Spawn_XMLTree_Type
//

RPG_Monster_Spawn_XMLTree_Type::
RPG_Monster_Spawn_XMLTree_Type (const type_type& type,
                                const interval_type& interval,
                                const probability_type& probability,
                                const max_num_spawned_type& max_num_spawned,
                                const amble_probability_type& amble_probability)
: ::xml_schema::type (),
  type_ (type, this),
  interval_ (interval, this),
  probability_ (probability, this),
  max_num_spawned_ (max_num_spawned, this),
  amble_probability_ (amble_probability, this)
{
}

RPG_Monster_Spawn_XMLTree_Type::
RPG_Monster_Spawn_XMLTree_Type (const type_type& type,
                                ::std::unique_ptr< interval_type > interval,
                                const probability_type& probability,
                                const max_num_spawned_type& max_num_spawned,
                                const amble_probability_type& amble_probability)
: ::xml_schema::type (),
  type_ (type, this),
  interval_ (std::move (interval), this),
  probability_ (probability, this),
  max_num_spawned_ (max_num_spawned, this),
  amble_probability_ (amble_probability, this)
{
}

RPG_Monster_Spawn_XMLTree_Type::
RPG_Monster_Spawn_XMLTree_Type (const RPG_Monster_Spawn_XMLTree_Type& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  interval_ (x.interval_, f, this),
  probability_ (x.probability_, f, this),
  max_num_spawned_ (x.max_num_spawned_, f, this),
  amble_probability_ (x.amble_probability_, f, this)
{
}

RPG_Monster_Spawn_XMLTree_Type::
RPG_Monster_Spawn_XMLTree_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  interval_ (this),
  probability_ (this),
  max_num_spawned_ (this),
  amble_probability_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_Spawn_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (::std::move (r));
        continue;
      }
    }

    // interval
    //
    if (n.name () == "interval" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< interval_type > r (
        interval_traits::create (i, f, this));

      if (!interval_.present ())
      {
        this->interval_.set (::std::move (r));
        continue;
      }
    }

    // probability
    //
    if (n.name () == "probability" && n.namespace_ () == "urn:rpg")
    {
      if (!probability_.present ())
      {
        this->probability_.set (probability_traits::create (i, f, this));
        continue;
      }
    }

    // max_num_spawned
    //
    if (n.name () == "max_num_spawned" && n.namespace_ () == "urn:rpg")
    {
      if (!max_num_spawned_.present ())
      {
        this->max_num_spawned_.set (max_num_spawned_traits::create (i, f, this));
        continue;
      }
    }

    // amble_probability
    //
    if (n.name () == "amble_probability" && n.namespace_ () == "urn:rpg")
    {
      if (!amble_probability_.present ())
      {
        this->amble_probability_.set (amble_probability_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!interval_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "interval",
      "urn:rpg");
  }

  if (!probability_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "probability",
      "urn:rpg");
  }

  if (!max_num_spawned_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "max_num_spawned",
      "urn:rpg");
  }

  if (!amble_probability_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "amble_probability",
      "urn:rpg");
  }
}

RPG_Monster_Spawn_XMLTree_Type* RPG_Monster_Spawn_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Spawn_XMLTree_Type (*this, f, c);
}

RPG_Monster_Spawn_XMLTree_Type& RPG_Monster_Spawn_XMLTree_Type::
operator= (const RPG_Monster_Spawn_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->interval_ = x.interval_;
    this->probability_ = x.probability_;
    this->max_num_spawned_ = x.max_num_spawned_;
    this->amble_probability_ = x.amble_probability_;
  }

  return *this;
}

RPG_Monster_Spawn_XMLTree_Type::
~RPG_Monster_Spawn_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Spawn_XMLTree_Type& x, const RPG_Monster_Spawn_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.interval () == y.interval ()))
    return false;

  if (!(x.probability () == y.probability ()))
    return false;

  if (!(x.max_num_spawned () == y.max_num_spawned ()))
    return false;

  if (!(x.amble_probability () == y.amble_probability ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Spawn_XMLTree_Type& x, const RPG_Monster_Spawn_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Monster_Dictionary_XMLTree_Type
//

RPG_Monster_Dictionary_XMLTree_Type::
RPG_Monster_Dictionary_XMLTree_Type ()
: ::xml_schema::type (),
  monster_ (this)
{
}

RPG_Monster_Dictionary_XMLTree_Type::
RPG_Monster_Dictionary_XMLTree_Type (const RPG_Monster_Dictionary_XMLTree_Type& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  monster_ (x.monster_, f, this)
{
}

RPG_Monster_Dictionary_XMLTree_Type::
RPG_Monster_Dictionary_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  monster_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Monster_Dictionary_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // monster
    //
    if (n.name () == "monster" && n.namespace_ () == "urn:rpg")
    {
      ::std::unique_ptr< monster_type > r (
        monster_traits::create (i, f, this));

      this->monster_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

RPG_Monster_Dictionary_XMLTree_Type* RPG_Monster_Dictionary_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Monster_Dictionary_XMLTree_Type (*this, f, c);
}

RPG_Monster_Dictionary_XMLTree_Type& RPG_Monster_Dictionary_XMLTree_Type::
operator= (const RPG_Monster_Dictionary_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->monster_ = x.monster_;
  }

  return *this;
}

RPG_Monster_Dictionary_XMLTree_Type::
~RPG_Monster_Dictionary_XMLTree_Type ()
{
}

bool
operator== (const RPG_Monster_Dictionary_XMLTree_Type& x, const RPG_Monster_Dictionary_XMLTree_Type& y)
{
  if (!(x.monster () == y.monster ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Monster_Dictionary_XMLTree_Type& x, const RPG_Monster_Dictionary_XMLTree_Type& y)
{
  return !(x == y);
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Size_XMLTree_Type& i)
{
  o << ::std::endl << "size: " << i.size ();
  o << ::std::endl << "isTall: " << i.isTall ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_NaturalArmorClass_XMLTree_Type& i)
{
  o << ::std::endl << "normal: " << i.normal ();
  o << ::std::endl << "touch: " << i.touch ();
  o << ::std::endl << "flatFooted: " << i.flatFooted ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::value i)
{
  return o << RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type::_xsd_RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialBaseProperties_XMLTree_Type& i)
{
  o << ::std::endl << "abilityClass: " << i.abilityClass ();
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "actionType: " << i.actionType ();
  if (i.usage ())
  {
    o << ::std::endl << "usage: " << *i.usage ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Monster_NaturalWeapon_XMLTree_Type::value i)
{
  return o << RPG_Monster_NaturalWeapon_XMLTree_Type::_xsd_RPG_Monster_NaturalWeapon_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_NaturalWeapon_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Monster_WeaponTypeUnion_XMLTree_Type::value i)
{
  return o << RPG_Monster_WeaponTypeUnion_XMLTree_Type::_xsd_RPG_Monster_WeaponTypeUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_WeaponTypeUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& i)
{
  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::weaponType_const_iterator
       b (i.weaponType ().begin ()), e (i.weaponType ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "weaponType: " << *b;
  }

  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::ownCondition_const_iterator
       b (i.ownCondition ().begin ()), e (i.ownCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ownCondition: " << *b;
  }

  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), e (i.targetCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "targetCondition: " << *b;
  }

  o << ::std::endl << "isMagicalWeapon: " << i.isMagicalWeapon ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_DefenseAction_XMLTree_Type& i)
{
  for (RPG_Monster_DefenseAction_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), e (i.preCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "preCondition: " << *b;
  }

  if (i.damage ())
  {
    o << ::std::endl << "damage: " << *i.damage ();
  }

  if (i.ranged ())
  {
    o << ::std::endl << "ranged: " << *i.ranged ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  for (RPG_Monster_SpecialDefenseProperties_XMLTree_Type::action_const_iterator
       b (i.action ().begin ()), e (i.action ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "action: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_AttackAction_XMLTree_Type& i)
{
  o << ::std::endl << "weapon: " << i.weapon ();
  for (RPG_Monster_AttackAction_XMLTree_Type::attackBonus_const_iterator
       b (i.attackBonus ().begin ()), e (i.attackBonus ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "attackBonus: " << *b;
  }

  for (RPG_Monster_AttackAction_XMLTree_Type::attackForm_const_iterator
       b (i.attackForm ().begin ()), e (i.attackForm ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "attackForm: " << *b;
  }

  if (i.damage ())
  {
    o << ::std::endl << "damage: " << *i.damage ();
  }

  if (i.effect ())
  {
    o << ::std::endl << "effect: " << *i.effect ();
  }

  if (i.numAttacksPerRound ())
  {
    o << ::std::endl << "numAttacksPerRound: " << *i.numAttacksPerRound ();
  }

  if (i.ranged ())
  {
    o << ::std::endl << "ranged: " << *i.ranged ();
  }

  for (RPG_Monster_AttackAction_XMLTree_Type::trigger_const_iterator
       b (i.trigger ().begin ()), e (i.trigger ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "trigger: " << *b;
  }

  o << ::std::endl << "allAdjacent: " << i.allAdjacent ();
  o << ::std::endl << "fullAttackIncludesNextAction: " << i.fullAttackIncludesNextAction ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Attack_XMLTree_Type& i)
{
  o << ::std::endl << "baseAttackBonus: " << i.baseAttackBonus ();
  o << ::std::endl << "grappleBonus: " << i.grappleBonus ();
  for (RPG_Monster_Attack_XMLTree_Type::standardAttackAction_const_iterator
       b (i.standardAttackAction ().begin ()), e (i.standardAttackAction ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "standardAttackAction: " << *b;
  }

  for (RPG_Monster_Attack_XMLTree_Type::fullAttackAction_const_iterator
       b (i.fullAttackAction ().begin ()), e (i.fullAttackAction ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "fullAttackAction: " << *b;
  }

  o << ::std::endl << "actionsAreInclusive: " << i.actionsAreInclusive ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_ActionTrigger_XMLTree_Type& i)
{
  o << ::std::endl << "weapon: " << i.weapon ();
  o << ::std::endl << "numHits: " << i.numHits ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& i)
{
  if (i.action ())
  {
    o << ::std::endl << "action: " << *i.action ();
  }

  if (i.targetAlignment ())
  {
    o << ::std::endl << "targetAlignment: " << *i.targetAlignment ();
  }

  for (RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::ownCondition_const_iterator
       b (i.ownCondition ().begin ()), e (i.ownCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "ownCondition: " << *b;
  }

  for (RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), e (i.targetCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "targetCondition: " << *b;
  }

  if (i.minTargetSize ())
  {
    o << ::std::endl << "minTargetSize: " << *i.minTargetSize ();
  }

  if (i.maxTargetSize ())
  {
    o << ::std::endl << "maxTargetSize: " << *i.maxTargetSize ();
  }

  if (i.check ())
  {
    o << ::std::endl << "check: " << *i.check ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialAttackProperties_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  for (RPG_Monster_SpecialAttackProperties_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), e (i.preCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "preCondition: " << *b;
  }

  o << ::std::endl << "action: " << i.action ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& i)
{
  for (RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), e (i.targetCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "targetCondition: " << *b;
  }

  if (i.maxTargetSize ())
  {
    o << ::std::endl << "maxTargetSize: " << *i.maxTargetSize ();
  }

  if (i.check ())
  {
    o << ::std::endl << "check: " << *i.check ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SummonMonster_XMLTree_Type& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "amount: " << i.amount ();
  o << ::std::endl << "successRate: " << i.successRate ();
  o << ::std::endl << "actionsAreInclusive: " << i.actionsAreInclusive ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), e (i.preCondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "preCondition: " << *b;
  }

  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::summon_const_iterator
       b (i.summon ().begin ()), e (i.summon ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "summon: " << *b;
  }

  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), e (i.spell ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "spell: " << *b;
  }

  if (i.ranged ())
  {
    o << ::std::endl << "ranged: " << *i.ranged ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_SavingThrowModifiers_XMLTree_Type& i)
{
  o << ::std::endl << "fortitude: " << i.fortitude ();
  o << ::std::endl << "reflex: " << i.reflex ();
  o << ::std::endl << "will: " << i.will ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Monster_Organization_XMLTree_Type::value i)
{
  return o << RPG_Monster_Organization_XMLTree_Type::_xsd_RPG_Monster_Organization_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Organization_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "range: " << i.range ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_OrganizationStep_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  if (i.range ())
  {
    o << ::std::endl << "range: " << *i.range ();
  }

  for (RPG_Monster_OrganizationStep_XMLTree_Type::slaves_const_iterator
       b (i.slaves ().begin ()), e (i.slaves ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "slaves: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Organizations_XMLTree_Type& i)
{
  for (RPG_Monster_Organizations_XMLTree_Type::step_const_iterator
       b (i.step ().begin ()), e (i.step ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "step: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_AdvancementStep_XMLTree_Type& i)
{
  o << ::std::endl << "size: " << i.size ();
  o << ::std::endl << "range: " << i.range ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Advancement_XMLTree_Type& i)
{
  for (RPG_Monster_Advancement_XMLTree_Type::step_const_iterator
       b (i.step ().begin ()), e (i.step ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "step: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_PropertiesXML_XMLTree_Type& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "size: " << i.size ();
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "hitDice: " << i.hitDice ();
  o << ::std::endl << "initiative: " << i.initiative ();
  o << ::std::endl << "speed: " << i.speed ();
  o << ::std::endl << "armorClass: " << i.armorClass ();
  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialDefense_const_iterator
       b (i.specialDefense ().begin ()), e (i.specialDefense ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "specialDefense: " << *b;
  }

  o << ::std::endl << "attack: " << i.attack ();
  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialAttack_const_iterator
       b (i.specialAttack ().begin ()), e (i.specialAttack ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "specialAttack: " << *b;
  }

  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialAbility_const_iterator
       b (i.specialAbility ().begin ()), e (i.specialAbility ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "specialAbility: " << *b;
  }

  o << ::std::endl << "space: " << i.space ();
  o << ::std::endl << "reach: " << i.reach ();
  o << ::std::endl << "saves: " << i.saves ();
  o << ::std::endl << "attributes: " << i.attributes ();
  if (i.skills ())
  {
    o << ::std::endl << "skills: " << *i.skills ();
  }

  if (i.feats ())
  {
    o << ::std::endl << "feats: " << *i.feats ();
  }

  o << ::std::endl << "environment: " << i.environment ();
  o << ::std::endl << "organizations: " << i.organizations ();
  o << ::std::endl << "challengeRating: " << i.challengeRating ();
  o << ::std::endl << "treasureModifier: " << i.treasureModifier ();
  o << ::std::endl << "alignment: " << i.alignment ();
  if (i.advancements ())
  {
    o << ::std::endl << "advancements: " << *i.advancements ();
  }

  o << ::std::endl << "levelAdjustment: " << i.levelAdjustment ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_StateBase_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Player_StateBase_XMLTree_Type& > (i);

  o << ::std::endl << "gold: " << i.gold ();
  if (i.inventory ())
  {
    o << ::std::endl << "inventory: " << *i.inventory ();
  }

  o << ::std::endl << "maxHP: " << i.maxHP ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_State_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Monster_StateBase_XMLTree_Type& > (i);

  o << ::std::endl << "type: " << i.type ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Spawn_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "interval: " << i.interval ();
  o << ::std::endl << "probability: " << i.probability ();
  o << ::std::endl << "max_num_spawned: " << i.max_num_spawned ();
  o << ::std::endl << "amble_probability: " << i.amble_probability ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Monster_Dictionary_XMLTree_Type& i)
{
  for (RPG_Monster_Dictionary_XMLTree_Type::monster_const_iterator
       b (i.monster ().begin ()), e (i.monster ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "monster: " << *b;
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::monsterDictionary (isrc, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::monsterDictionary (isrc, h, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::monsterDictionary (isrc, h, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::monsterDictionary (isrc, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::monsterDictionary (isrc, h, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::monsterDictionary (isrc, h, f, p);
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
    ::monsterDictionary (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (const ::xercesc::DOMDocument& doc,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > (
      ::monsterDictionary (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "monsterDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > r (
      ::xsd::cxx::tree::traits< ::RPG_Monster_Dictionary_XMLTree_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "monsterDictionary",
    "urn:rpg");
}

::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type >
monsterDictionary (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "monsterDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    ::std::unique_ptr< ::RPG_Monster_Dictionary_XMLTree_Type > r (
      ::xsd::cxx::tree::traits< ::RPG_Monster_Dictionary_XMLTree_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "monsterDictionary",
    "urn:rpg");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Size_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        "urn:rpg",
        e));

    s << i.size ();
  }

  // isTall
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isTall",
        e));

    a << i.isTall ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_NaturalArmorClass_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // normal
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "normal",
        "urn:rpg",
        e));

    s << i.normal ();
  }

  // touch
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "touch",
        "urn:rpg",
        e));

    s << i.touch ();
  }

  // flatFooted
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "flatFooted",
        "urn:rpg",
        e));

    s << i.flatFooted ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Monster_SpecialPropertyTypeUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialBaseProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // abilityClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "abilityClass",
        "urn:rpg",
        e));

    s << i.abilityClass ();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // actionType
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "actionType",
        "urn:rpg",
        e));

    s << i.actionType ();
  }

  // usage
  //
  if (i.usage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "usage",
        "urn:rpg",
        e));

    s << *i.usage ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_NaturalWeapon_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Monster_NaturalWeapon_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Monster_NaturalWeapon_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_WeaponTypeUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Monster_WeaponTypeUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Monster_WeaponTypeUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // weaponType
  //
  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::weaponType_const_iterator
       b (i.weaponType ().begin ()), n (i.weaponType ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::weaponType_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weaponType",
        "urn:rpg",
        e));

    s << x;
  }

  // ownCondition
  //
  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::ownCondition_const_iterator
       b (i.ownCondition ().begin ()), n (i.ownCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::ownCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ownCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // targetCondition
  //
  for (RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), n (i.targetCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialDefensePreCondition_XMLTree_Type::targetCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "targetCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // isMagicalWeapon
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isMagicalWeapon",
        e));

    a << i.isMagicalWeapon ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_DefenseAction_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // preCondition
  //
  for (RPG_Monster_DefenseAction_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), n (i.preCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_DefenseAction_XMLTree_Type::preCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "preCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // damage
  //
  if (i.damage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damage",
        "urn:rpg",
        e));

    s << *i.damage ();
  }

  // ranged
  //
  if (i.ranged ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ranged",
        "urn:rpg",
        e));

    s << *i.ranged ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialDefenseProperties_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  // action
  //
  for (RPG_Monster_SpecialDefenseProperties_XMLTree_Type::action_const_iterator
       b (i.action ().begin ()), n (i.action ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialDefenseProperties_XMLTree_Type::action_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "action",
        "urn:rpg",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_AttackAction_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // weapon
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weapon",
        "urn:rpg",
        e));

    s << i.weapon ();
  }

  // attackBonus
  //
  for (RPG_Monster_AttackAction_XMLTree_Type::attackBonus_const_iterator
       b (i.attackBonus ().begin ()), n (i.attackBonus ().end ());
       b != n; ++b)
  {
    const RPG_Monster_AttackAction_XMLTree_Type::attackBonus_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attackBonus",
        "urn:rpg",
        e));

    s << x;
  }

  // attackForm
  //
  for (RPG_Monster_AttackAction_XMLTree_Type::attackForm_const_iterator
       b (i.attackForm ().begin ()), n (i.attackForm ().end ());
       b != n; ++b)
  {
    const RPG_Monster_AttackAction_XMLTree_Type::attackForm_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attackForm",
        "urn:rpg",
        e));

    s << x;
  }

  // damage
  //
  if (i.damage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damage",
        "urn:rpg",
        e));

    s << *i.damage ();
  }

  // effect
  //
  if (i.effect ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "effect",
        "urn:rpg",
        e));

    s << *i.effect ();
  }

  // numAttacksPerRound
  //
  if (i.numAttacksPerRound ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numAttacksPerRound",
        "urn:rpg",
        e));

    s << *i.numAttacksPerRound ();
  }

  // ranged
  //
  if (i.ranged ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ranged",
        "urn:rpg",
        e));

    s << *i.ranged ();
  }

  // trigger
  //
  for (RPG_Monster_AttackAction_XMLTree_Type::trigger_const_iterator
       b (i.trigger ().begin ()), n (i.trigger ().end ());
       b != n; ++b)
  {
    const RPG_Monster_AttackAction_XMLTree_Type::trigger_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "trigger",
        "urn:rpg",
        e));

    s << x;
  }

  // allAdjacent
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "allAdjacent",
        e));

    a << i.allAdjacent ();
  }

  // fullAttackIncludesNextAction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "fullAttackIncludesNextAction",
        e));

    a << i.fullAttackIncludesNextAction ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Attack_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // baseAttackBonus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseAttackBonus",
        "urn:rpg",
        e));

    s << i.baseAttackBonus ();
  }

  // grappleBonus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "grappleBonus",
        "urn:rpg",
        e));

    s << i.grappleBonus ();
  }

  // standardAttackAction
  //
  for (RPG_Monster_Attack_XMLTree_Type::standardAttackAction_const_iterator
       b (i.standardAttackAction ().begin ()), n (i.standardAttackAction ().end ());
       b != n; ++b)
  {
    const RPG_Monster_Attack_XMLTree_Type::standardAttackAction_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "standardAttackAction",
        "urn:rpg",
        e));

    s << x;
  }

  // fullAttackAction
  //
  for (RPG_Monster_Attack_XMLTree_Type::fullAttackAction_const_iterator
       b (i.fullAttackAction ().begin ()), n (i.fullAttackAction ().end ());
       b != n; ++b)
  {
    const RPG_Monster_Attack_XMLTree_Type::fullAttackAction_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "fullAttackAction",
        "urn:rpg",
        e));

    s << x;
  }

  // actionsAreInclusive
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "actionsAreInclusive",
        e));

    a << i.actionsAreInclusive ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_ActionTrigger_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // weapon
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weapon",
        "urn:rpg",
        e));

    s << i.weapon ();
  }

  // numHits
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numHits",
        "urn:rpg",
        e));

    s << i.numHits ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // action
  //
  if (i.action ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "action",
        "urn:rpg",
        e));

    s << *i.action ();
  }

  // targetAlignment
  //
  if (i.targetAlignment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "targetAlignment",
        "urn:rpg",
        e));

    s << *i.targetAlignment ();
  }

  // ownCondition
  //
  for (RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::ownCondition_const_iterator
       b (i.ownCondition ().begin ()), n (i.ownCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::ownCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ownCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // targetCondition
  //
  for (RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), n (i.targetCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAttackPreCondition_XMLTree_Type::targetCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "targetCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // minTargetSize
  //
  if (i.minTargetSize ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "minTargetSize",
        "urn:rpg",
        e));

    s << *i.minTargetSize ();
  }

  // maxTargetSize
  //
  if (i.maxTargetSize ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxTargetSize",
        "urn:rpg",
        e));

    s << *i.maxTargetSize ();
  }

  // check
  //
  if (i.check ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "check",
        "urn:rpg",
        e));

    s << *i.check ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialAttackProperties_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  // preCondition
  //
  for (RPG_Monster_SpecialAttackProperties_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), n (i.preCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAttackProperties_XMLTree_Type::preCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "preCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // action
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "action",
        "urn:rpg",
        e));

    s << i.action ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // targetCondition
  //
  for (RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::targetCondition_const_iterator
       b (i.targetCondition ().begin ()), n (i.targetCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAbilityPreCondition_XMLTree_Type::targetCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "targetCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // maxTargetSize
  //
  if (i.maxTargetSize ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxTargetSize",
        "urn:rpg",
        e));

    s << *i.maxTargetSize ();
  }

  // check
  //
  if (i.check ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "check",
        "urn:rpg",
        e));

    s << *i.check ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SummonMonster_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        "urn:rpg",
        e));

    s << i.name ();
  }

  // amount
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "amount",
        "urn:rpg",
        e));

    s << i.amount ();
  }

  // successRate
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "successRate",
        e));

    a << i.successRate ();
  }

  // actionsAreInclusive
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "actionsAreInclusive",
        e));

    a << i.actionsAreInclusive ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SpecialAbilityProperties_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Monster_SpecialBaseProperties_XMLTree_Type& > (i);

  // preCondition
  //
  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::preCondition_const_iterator
       b (i.preCondition ().begin ()), n (i.preCondition ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::preCondition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "preCondition",
        "urn:rpg",
        e));

    s << x;
  }

  // summon
  //
  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::summon_const_iterator
       b (i.summon ().begin ()), n (i.summon ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::summon_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "summon",
        "urn:rpg",
        e));

    s << x;
  }

  // spell
  //
  for (RPG_Monster_SpecialAbilityProperties_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), n (i.spell ().end ());
       b != n; ++b)
  {
    const RPG_Monster_SpecialAbilityProperties_XMLTree_Type::spell_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spell",
        "urn:rpg",
        e));

    s << x;
  }

  // ranged
  //
  if (i.ranged ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ranged",
        "urn:rpg",
        e));

    s << *i.ranged ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_SavingThrowModifiers_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // fortitude
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "fortitude",
        "urn:rpg",
        e));

    s << i.fortitude ();
  }

  // reflex
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "reflex",
        "urn:rpg",
        e));

    s << i.reflex ();
  }

  // will
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "will",
        "urn:rpg",
        e));

    s << i.will ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Organization_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Monster_Organization_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Monster_Organization_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_OrganizationSlaverStep_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        "urn:rpg",
        e));

    s << i.name ();
  }

  // range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "range",
        "urn:rpg",
        e));

    s << i.range ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_OrganizationStep_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // range
  //
  if (i.range ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "range",
        "urn:rpg",
        e));

    s << *i.range ();
  }

  // slaves
  //
  for (RPG_Monster_OrganizationStep_XMLTree_Type::slaves_const_iterator
       b (i.slaves ().begin ()), n (i.slaves ().end ());
       b != n; ++b)
  {
    const RPG_Monster_OrganizationStep_XMLTree_Type::slaves_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "slaves",
        "urn:rpg",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Organizations_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // step
  //
  for (RPG_Monster_Organizations_XMLTree_Type::step_const_iterator
       b (i.step ().begin ()), n (i.step ().end ());
       b != n; ++b)
  {
    const RPG_Monster_Organizations_XMLTree_Type::step_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "step",
        "urn:rpg",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_AdvancementStep_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        "urn:rpg",
        e));

    s << i.size ();
  }

  // range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "range",
        "urn:rpg",
        e));

    s << i.range ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Advancement_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // step
  //
  for (RPG_Monster_Advancement_XMLTree_Type::step_const_iterator
       b (i.step ().begin ()), n (i.step ().end ());
       b != n; ++b)
  {
    const RPG_Monster_Advancement_XMLTree_Type::step_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "step",
        "urn:rpg",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_PropertiesXML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        "urn:rpg",
        e));

    s << i.name ();
  }

  // size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        "urn:rpg",
        e));

    s << i.size ();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // hitDice
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "hitDice",
        "urn:rpg",
        e));

    s << i.hitDice ();
  }

  // initiative
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "initiative",
        "urn:rpg",
        e));

    s << i.initiative ();
  }

  // speed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "speed",
        "urn:rpg",
        e));

    s << i.speed ();
  }

  // armorClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "armorClass",
        "urn:rpg",
        e));

    s << i.armorClass ();
  }

  // specialDefense
  //
  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialDefense_const_iterator
       b (i.specialDefense ().begin ()), n (i.specialDefense ().end ());
       b != n; ++b)
  {
    const RPG_Monster_PropertiesXML_XMLTree_Type::specialDefense_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "specialDefense",
        "urn:rpg",
        e));

    s << x;
  }

  // attack
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attack",
        "urn:rpg",
        e));

    s << i.attack ();
  }

  // specialAttack
  //
  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialAttack_const_iterator
       b (i.specialAttack ().begin ()), n (i.specialAttack ().end ());
       b != n; ++b)
  {
    const RPG_Monster_PropertiesXML_XMLTree_Type::specialAttack_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "specialAttack",
        "urn:rpg",
        e));

    s << x;
  }

  // specialAbility
  //
  for (RPG_Monster_PropertiesXML_XMLTree_Type::specialAbility_const_iterator
       b (i.specialAbility ().begin ()), n (i.specialAbility ().end ());
       b != n; ++b)
  {
    const RPG_Monster_PropertiesXML_XMLTree_Type::specialAbility_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "specialAbility",
        "urn:rpg",
        e));

    s << x;
  }

  // space
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "space",
        "urn:rpg",
        e));

    s << i.space ();
  }

  // reach
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "reach",
        "urn:rpg",
        e));

    s << i.reach ();
  }

  // saves
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "saves",
        "urn:rpg",
        e));

    s << i.saves ();
  }

  // attributes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attributes",
        "urn:rpg",
        e));

    s << i.attributes ();
  }

  // skills
  //
  if (i.skills ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "skills",
        "urn:rpg",
        e));

    s << *i.skills ();
  }

  // feats
  //
  if (i.feats ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "feats",
        "urn:rpg",
        e));

    s << *i.feats ();
  }

  // environment
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "environment",
        "urn:rpg",
        e));

    s << i.environment ();
  }

  // organizations
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "organizations",
        "urn:rpg",
        e));

    s << i.organizations ();
  }

  // challengeRating
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "challengeRating",
        "urn:rpg",
        e));

    s << i.challengeRating ();
  }

  // treasureModifier
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasureModifier",
        "urn:rpg",
        e));

    s << i.treasureModifier ();
  }

  // alignment
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "alignment",
        "urn:rpg",
        e));

    s << i.alignment ();
  }

  // advancements
  //
  if (i.advancements ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "advancements",
        "urn:rpg",
        e));

    s << *i.advancements ();
  }

  // levelAdjustment
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelAdjustment",
        "urn:rpg",
        e));

    s << i.levelAdjustment ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_StateBase_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Player_StateBase_XMLTree_Type& > (i);

  // gold
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "gold",
        "urn:rpg",
        e));

    s << i.gold ();
  }

  // inventory
  //
  if (i.inventory ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "inventory",
        "urn:rpg",
        e));

    s << *i.inventory ();
  }

  // maxHP
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxHP",
        "urn:rpg",
        e));

    s << i.maxHP ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_State_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Monster_StateBase_XMLTree_Type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Spawn_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // interval
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "interval",
        "urn:rpg",
        e));

    s << i.interval ();
  }

  // probability
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "probability",
        "urn:rpg",
        e));

    s << i.probability ();
  }

  // max_num_spawned
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "max_num_spawned",
        "urn:rpg",
        e));

    s << i.max_num_spawned ();
  }

  // amble_probability
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "amble_probability",
        "urn:rpg",
        e));

    s << i.amble_probability ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Monster_Dictionary_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // monster
  //
  for (RPG_Monster_Dictionary_XMLTree_Type::monster_const_iterator
       b (i.monster ().begin ()), n (i.monster ().end ());
       b != n; ++b)
  {
    const RPG_Monster_Dictionary_XMLTree_Type::monster_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "monster",
        "urn:rpg",
        e));

    s << x;
  }
}

void
monsterDictionary (::std::ostream& o,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
monsterDictionary (::std::ostream& o,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
monsterDictionary (::std::ostream& o,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
monsterDictionary (::xercesc::XMLFormatTarget& t,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
monsterDictionary (::xercesc::XMLFormatTarget& t,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
monsterDictionary (::xercesc::XMLFormatTarget& t,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::monsterDictionary (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
monsterDictionary (::xercesc::DOMDocument& d,
                   const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "monsterDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "monsterDictionary",
      "urn:rpg");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
monsterDictionary (const ::RPG_Monster_Dictionary_XMLTree_Type& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "monsterDictionary",
      "urn:rpg",
      m, f));

  ::monsterDictionary (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

