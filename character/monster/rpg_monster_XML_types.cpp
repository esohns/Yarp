// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_monster_XML_types.h"

// RPG_Monster_Size_Type_pskel
//

void RPG_Monster_Size_Type_pskel::
size_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Monster_Size_Type_pskel::
isTall_parser (::xml_schema::boolean_pskel& p)
{
  this->isTall_parser_ = &p;
}

void RPG_Monster_Size_Type_pskel::
parsers (::RPG_Common_Size_Type_pskel& size,
         ::xml_schema::boolean_pskel& isTall)
{
  this->size_parser_ = &size;
  this->isTall_parser_ = &isTall;
}

RPG_Monster_Size_Type_pskel::
RPG_Monster_Size_Type_pskel ()
: size_parser_ (0),
  isTall_parser_ (0)
{
}

// RPG_Monster_NaturalArmorClass_Type_pskel
//

void RPG_Monster_NaturalArmorClass_Type_pskel::
normal_parser (::xml_schema::byte_pskel& p)
{
  this->normal_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
touch_parser (::xml_schema::byte_pskel& p)
{
  this->touch_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
flatFooted_parser (::xml_schema::byte_pskel& p)
{
  this->flatFooted_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
parsers (::xml_schema::byte_pskel& normal,
         ::xml_schema::byte_pskel& touch,
         ::xml_schema::byte_pskel& flatFooted)
{
  this->normal_parser_ = &normal;
  this->touch_parser_ = &touch;
  this->flatFooted_parser_ = &flatFooted;
}

RPG_Monster_NaturalArmorClass_Type_pskel::
RPG_Monster_NaturalArmorClass_Type_pskel ()
: normal_parser_ (0),
  touch_parser_ (0),
  flatFooted_parser_ (0)
{
}

// RPG_Monster_SpecialBaseProperties_Type_pskel
//

void RPG_Monster_SpecialBaseProperties_Type_pskel::
abilityClass_parser (::RPG_Magic_AbilityClass_Type_pskel& p)
{
  this->abilityClass_parser_ = &p;
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
type_parser (::RPG_Monster_SpecialPropertyTypeUnion_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
actionType_parser (::RPG_Common_ActionType_Type_pskel& p)
{
  this->actionType_parser_ = &p;
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
usage_parser (::RPG_Common_Usage_Type_pskel& p)
{
  this->usage_parser_ = &p;
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
parsers (::RPG_Magic_AbilityClass_Type_pskel& abilityClass,
         ::RPG_Monster_SpecialPropertyTypeUnion_Type_pskel& type,
         ::RPG_Common_ActionType_Type_pskel& actionType,
         ::RPG_Common_Usage_Type_pskel& usage)
{
  this->abilityClass_parser_ = &abilityClass;
  this->type_parser_ = &type;
  this->actionType_parser_ = &actionType;
  this->usage_parser_ = &usage;
}

RPG_Monster_SpecialBaseProperties_Type_pskel::
RPG_Monster_SpecialBaseProperties_Type_pskel ()
: abilityClass_parser_ (0),
  type_parser_ (0),
  actionType_parser_ (0),
  usage_parser_ (0)
{
}

// RPG_Monster_SpecialDefensePreCondition_Type_pskel
//

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
weaponType_parser (::RPG_Monster_WeaponTypeUnion_Type_pskel& p)
{
  this->weaponType_parser_ = &p;
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
ownCondition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->ownCondition_parser_ = &p;
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
targetCondition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->targetCondition_parser_ = &p;
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
isMagicalWeapon_parser (::xml_schema::boolean_pskel& p)
{
  this->isMagicalWeapon_parser_ = &p;
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
parsers (::RPG_Monster_WeaponTypeUnion_Type_pskel& weaponType,
         ::RPG_Common_Condition_Type_pskel& ownCondition,
         ::RPG_Common_Condition_Type_pskel& targetCondition,
         ::xml_schema::boolean_pskel& isMagicalWeapon)
{
  this->weaponType_parser_ = &weaponType;
  this->ownCondition_parser_ = &ownCondition;
  this->targetCondition_parser_ = &targetCondition;
  this->isMagicalWeapon_parser_ = &isMagicalWeapon;
}

RPG_Monster_SpecialDefensePreCondition_Type_pskel::
RPG_Monster_SpecialDefensePreCondition_Type_pskel ()
: weaponType_parser_ (0),
  ownCondition_parser_ (0),
  targetCondition_parser_ (0),
  isMagicalWeapon_parser_ (0)
{
}

// RPG_Monster_DefenseAction_Type_pskel
//

void RPG_Monster_DefenseAction_Type_pskel::
preCondition_parser (::RPG_Monster_SpecialDefensePreCondition_Type_pskel& p)
{
  this->preCondition_parser_ = &p;
}

void RPG_Monster_DefenseAction_Type_pskel::
damage_parser (::RPG_Combat_Damage_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Monster_DefenseAction_Type_pskel::
ranged_parser (::RPG_Combat_RangedAttackProperties_Type_pskel& p)
{
  this->ranged_parser_ = &p;
}

void RPG_Monster_DefenseAction_Type_pskel::
parsers (::RPG_Monster_SpecialDefensePreCondition_Type_pskel& preCondition,
         ::RPG_Combat_Damage_Type_pskel& damage,
         ::RPG_Combat_RangedAttackProperties_Type_pskel& ranged)
{
  this->preCondition_parser_ = &preCondition;
  this->damage_parser_ = &damage;
  this->ranged_parser_ = &ranged;
}

RPG_Monster_DefenseAction_Type_pskel::
RPG_Monster_DefenseAction_Type_pskel ()
: preCondition_parser_ (0),
  damage_parser_ (0),
  ranged_parser_ (0)
{
}

// RPG_Monster_SpecialDefenseProperties_Type_pskel
//

void RPG_Monster_SpecialDefenseProperties_Type_pskel::
action_parser (::RPG_Monster_DefenseAction_Type_pskel& p)
{
  this->action_parser_ = &p;
}

void RPG_Monster_SpecialDefenseProperties_Type_pskel::
parsers (::RPG_Magic_AbilityClass_Type_pskel& abilityClass,
         ::RPG_Monster_SpecialPropertyTypeUnion_Type_pskel& type,
         ::RPG_Common_ActionType_Type_pskel& actionType,
         ::RPG_Common_Usage_Type_pskel& usage,
         ::RPG_Monster_DefenseAction_Type_pskel& action)
{
  this->abilityClass_parser_ = &abilityClass;
  this->type_parser_ = &type;
  this->actionType_parser_ = &actionType;
  this->usage_parser_ = &usage;
  this->action_parser_ = &action;
}

RPG_Monster_SpecialDefenseProperties_Type_pskel::
RPG_Monster_SpecialDefenseProperties_Type_pskel ()
: action_parser_ (0)
{
}

// RPG_Monster_AttackAction_Type_pskel
//

void RPG_Monster_AttackAction_Type_pskel::
weapon_parser (::RPG_Monster_WeaponTypeUnion_Type_pskel& p)
{
  this->weapon_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
attackBonus_parser (::xml_schema::byte_pskel& p)
{
  this->attackBonus_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
attackForm_parser (::RPG_Combat_AttackForm_Type_pskel& p)
{
  this->attackForm_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
damage_parser (::RPG_Combat_Damage_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
effect_parser (::RPG_Magic_SpellLikeProperties_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
numAttacksPerRound_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->numAttacksPerRound_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
ranged_parser (::RPG_Combat_RangedAttackProperties_Type_pskel& p)
{
  this->ranged_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
trigger_parser (::RPG_Character_Ability_Type_pskel& p)
{
  this->trigger_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
allAdjacent_parser (::xml_schema::boolean_pskel& p)
{
  this->allAdjacent_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
fullAttackIncludesNextAction_parser (::xml_schema::boolean_pskel& p)
{
  this->fullAttackIncludesNextAction_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
parsers (::RPG_Monster_WeaponTypeUnion_Type_pskel& weapon,
         ::xml_schema::byte_pskel& attackBonus,
         ::RPG_Combat_AttackForm_Type_pskel& attackForm,
         ::RPG_Combat_Damage_Type_pskel& damage,
         ::RPG_Magic_SpellLikeProperties_Type_pskel& effect,
         ::xml_schema::unsigned_byte_pskel& numAttacksPerRound,
         ::RPG_Combat_RangedAttackProperties_Type_pskel& ranged,
         ::RPG_Character_Ability_Type_pskel& trigger,
         ::xml_schema::boolean_pskel& allAdjacent,
         ::xml_schema::boolean_pskel& fullAttackIncludesNextAction)
{
  this->weapon_parser_ = &weapon;
  this->attackBonus_parser_ = &attackBonus;
  this->attackForm_parser_ = &attackForm;
  this->damage_parser_ = &damage;
  this->effect_parser_ = &effect;
  this->numAttacksPerRound_parser_ = &numAttacksPerRound;
  this->ranged_parser_ = &ranged;
  this->trigger_parser_ = &trigger;
  this->allAdjacent_parser_ = &allAdjacent;
  this->fullAttackIncludesNextAction_parser_ = &fullAttackIncludesNextAction;
}

RPG_Monster_AttackAction_Type_pskel::
RPG_Monster_AttackAction_Type_pskel ()
: weapon_parser_ (0),
  attackBonus_parser_ (0),
  attackForm_parser_ (0),
  damage_parser_ (0),
  effect_parser_ (0),
  numAttacksPerRound_parser_ (0),
  ranged_parser_ (0),
  trigger_parser_ (0),
  allAdjacent_parser_ (0),
  fullAttackIncludesNextAction_parser_ (0)
{
}

// RPG_Monster_Attack_Type_pskel
//

void RPG_Monster_Attack_Type_pskel::
baseAttackBonus_parser (::xml_schema::byte_pskel& p)
{
  this->baseAttackBonus_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
grappleBonus_parser (::xml_schema::byte_pskel& p)
{
  this->grappleBonus_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
standardAttackAction_parser (::RPG_Monster_AttackAction_Type_pskel& p)
{
  this->standardAttackAction_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
fullAttackAction_parser (::RPG_Monster_AttackAction_Type_pskel& p)
{
  this->fullAttackAction_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
actionsAreInclusive_parser (::xml_schema::boolean_pskel& p)
{
  this->actionsAreInclusive_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
parsers (::xml_schema::byte_pskel& baseAttackBonus,
         ::xml_schema::byte_pskel& grappleBonus,
         ::RPG_Monster_AttackAction_Type_pskel& standardAttackAction,
         ::RPG_Monster_AttackAction_Type_pskel& fullAttackAction,
         ::xml_schema::boolean_pskel& actionsAreInclusive)
{
  this->baseAttackBonus_parser_ = &baseAttackBonus;
  this->grappleBonus_parser_ = &grappleBonus;
  this->standardAttackAction_parser_ = &standardAttackAction;
  this->fullAttackAction_parser_ = &fullAttackAction;
  this->actionsAreInclusive_parser_ = &actionsAreInclusive;
}

RPG_Monster_Attack_Type_pskel::
RPG_Monster_Attack_Type_pskel ()
: baseAttackBonus_parser_ (0),
  grappleBonus_parser_ (0),
  standardAttackAction_parser_ (0),
  fullAttackAction_parser_ (0),
  actionsAreInclusive_parser_ (0)
{
}

// RPG_Monster_ActionTrigger_Type_pskel
//

void RPG_Monster_ActionTrigger_Type_pskel::
weapon_parser (::RPG_Monster_WeaponTypeUnion_Type_pskel& p)
{
  this->weapon_parser_ = &p;
}

void RPG_Monster_ActionTrigger_Type_pskel::
numHits_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->numHits_parser_ = &p;
}

void RPG_Monster_ActionTrigger_Type_pskel::
parsers (::RPG_Monster_WeaponTypeUnion_Type_pskel& weapon,
         ::xml_schema::unsigned_byte_pskel& numHits)
{
  this->weapon_parser_ = &weapon;
  this->numHits_parser_ = &numHits;
}

RPG_Monster_ActionTrigger_Type_pskel::
RPG_Monster_ActionTrigger_Type_pskel ()
: weapon_parser_ (0),
  numHits_parser_ (0)
{
}

// RPG_Monster_SpecialAttackPreCondition_Type_pskel
//

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
action_parser (::RPG_Monster_ActionTrigger_Type_pskel& p)
{
  this->action_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
targetAlignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->targetAlignment_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
ownCondition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->ownCondition_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
targetCondition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->targetCondition_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
minTargetSize_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->minTargetSize_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
maxTargetSize_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->maxTargetSize_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
check_parser (::RPG_Combat_Check_Type_pskel& p)
{
  this->check_parser_ = &p;
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
parsers (::RPG_Monster_ActionTrigger_Type_pskel& action,
         ::RPG_Character_Alignment_Type_pskel& targetAlignment,
         ::RPG_Common_Condition_Type_pskel& ownCondition,
         ::RPG_Common_Condition_Type_pskel& targetCondition,
         ::RPG_Common_Size_Type_pskel& minTargetSize,
         ::RPG_Common_Size_Type_pskel& maxTargetSize,
         ::RPG_Combat_Check_Type_pskel& check)
{
  this->action_parser_ = &action;
  this->targetAlignment_parser_ = &targetAlignment;
  this->ownCondition_parser_ = &ownCondition;
  this->targetCondition_parser_ = &targetCondition;
  this->minTargetSize_parser_ = &minTargetSize;
  this->maxTargetSize_parser_ = &maxTargetSize;
  this->check_parser_ = &check;
}

RPG_Monster_SpecialAttackPreCondition_Type_pskel::
RPG_Monster_SpecialAttackPreCondition_Type_pskel ()
: action_parser_ (0),
  targetAlignment_parser_ (0),
  ownCondition_parser_ (0),
  targetCondition_parser_ (0),
  minTargetSize_parser_ (0),
  maxTargetSize_parser_ (0),
  check_parser_ (0)
{
}

// RPG_Monster_SpecialAttackProperties_Type_pskel
//

void RPG_Monster_SpecialAttackProperties_Type_pskel::
preCondition_parser (::RPG_Monster_SpecialAttackPreCondition_Type_pskel& p)
{
  this->preCondition_parser_ = &p;
}

void RPG_Monster_SpecialAttackProperties_Type_pskel::
action_parser (::RPG_Monster_AttackAction_Type_pskel& p)
{
  this->action_parser_ = &p;
}

void RPG_Monster_SpecialAttackProperties_Type_pskel::
parsers (::RPG_Magic_AbilityClass_Type_pskel& abilityClass,
         ::RPG_Monster_SpecialPropertyTypeUnion_Type_pskel& type,
         ::RPG_Common_ActionType_Type_pskel& actionType,
         ::RPG_Common_Usage_Type_pskel& usage,
         ::RPG_Monster_SpecialAttackPreCondition_Type_pskel& preCondition,
         ::RPG_Monster_AttackAction_Type_pskel& action)
{
  this->abilityClass_parser_ = &abilityClass;
  this->type_parser_ = &type;
  this->actionType_parser_ = &actionType;
  this->usage_parser_ = &usage;
  this->preCondition_parser_ = &preCondition;
  this->action_parser_ = &action;
}

RPG_Monster_SpecialAttackProperties_Type_pskel::
RPG_Monster_SpecialAttackProperties_Type_pskel ()
: preCondition_parser_ (0),
  action_parser_ (0)
{
}

// RPG_Monster_SpecialAbilityPreCondition_Type_pskel
//

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
targetCondition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->targetCondition_parser_ = &p;
}

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
maxTargetSize_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->maxTargetSize_parser_ = &p;
}

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
check_parser (::RPG_Combat_Check_Type_pskel& p)
{
  this->check_parser_ = &p;
}

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
parsers (::RPG_Common_Condition_Type_pskel& targetCondition,
         ::RPG_Common_Size_Type_pskel& maxTargetSize,
         ::RPG_Combat_Check_Type_pskel& check)
{
  this->targetCondition_parser_ = &targetCondition;
  this->maxTargetSize_parser_ = &maxTargetSize;
  this->check_parser_ = &check;
}

RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
RPG_Monster_SpecialAbilityPreCondition_Type_pskel ()
: targetCondition_parser_ (0),
  maxTargetSize_parser_ (0),
  check_parser_ (0)
{
}

// RPG_Monster_SummonMonster_Type_pskel
//

void RPG_Monster_SummonMonster_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Monster_SummonMonster_Type_pskel::
amount_parser (::RPG_Dice_Roll_Type_pskel& p)
{
  this->amount_parser_ = &p;
}

void RPG_Monster_SummonMonster_Type_pskel::
successRate_parser (::xml_schema::float_pskel& p)
{
  this->successRate_parser_ = &p;
}

void RPG_Monster_SummonMonster_Type_pskel::
actionsAreInclusive_parser (::xml_schema::boolean_pskel& p)
{
  this->actionsAreInclusive_parser_ = &p;
}

void RPG_Monster_SummonMonster_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Dice_Roll_Type_pskel& amount,
         ::xml_schema::float_pskel& successRate,
         ::xml_schema::boolean_pskel& actionsAreInclusive)
{
  this->name_parser_ = &name;
  this->amount_parser_ = &amount;
  this->successRate_parser_ = &successRate;
  this->actionsAreInclusive_parser_ = &actionsAreInclusive;
}

RPG_Monster_SummonMonster_Type_pskel::
RPG_Monster_SummonMonster_Type_pskel ()
: name_parser_ (0),
  amount_parser_ (0),
  successRate_parser_ (0),
  actionsAreInclusive_parser_ (0)
{
}

// RPG_Monster_SpecialAbilityProperties_Type_pskel
//

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
preCondition_parser (::RPG_Monster_SpecialAbilityPreCondition_Type_pskel& p)
{
  this->preCondition_parser_ = &p;
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
summon_parser (::RPG_Monster_SummonMonster_Type_pskel& p)
{
  this->summon_parser_ = &p;
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
spell_parser (::RPG_Magic_SpellLikeProperties_Type_pskel& p)
{
  this->spell_parser_ = &p;
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
ranged_parser (::RPG_Combat_RangedAttackProperties_Type_pskel& p)
{
  this->ranged_parser_ = &p;
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
parsers (::RPG_Magic_AbilityClass_Type_pskel& abilityClass,
         ::RPG_Monster_SpecialPropertyTypeUnion_Type_pskel& type,
         ::RPG_Common_ActionType_Type_pskel& actionType,
         ::RPG_Common_Usage_Type_pskel& usage,
         ::RPG_Monster_SpecialAbilityPreCondition_Type_pskel& preCondition,
         ::RPG_Monster_SummonMonster_Type_pskel& summon,
         ::RPG_Magic_SpellLikeProperties_Type_pskel& spell,
         ::RPG_Combat_RangedAttackProperties_Type_pskel& ranged)
{
  this->abilityClass_parser_ = &abilityClass;
  this->type_parser_ = &type;
  this->actionType_parser_ = &actionType;
  this->usage_parser_ = &usage;
  this->preCondition_parser_ = &preCondition;
  this->summon_parser_ = &summon;
  this->spell_parser_ = &spell;
  this->ranged_parser_ = &ranged;
}

RPG_Monster_SpecialAbilityProperties_Type_pskel::
RPG_Monster_SpecialAbilityProperties_Type_pskel ()
: preCondition_parser_ (0),
  summon_parser_ (0),
  spell_parser_ (0),
  ranged_parser_ (0)
{
}

// RPG_Monster_SavingThrowModifiers_Type_pskel
//

void RPG_Monster_SavingThrowModifiers_Type_pskel::
fortitude_parser (::xml_schema::byte_pskel& p)
{
  this->fortitude_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
reflex_parser (::xml_schema::byte_pskel& p)
{
  this->reflex_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
will_parser (::xml_schema::byte_pskel& p)
{
  this->will_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
parsers (::xml_schema::byte_pskel& fortitude,
         ::xml_schema::byte_pskel& reflex,
         ::xml_schema::byte_pskel& will)
{
  this->fortitude_parser_ = &fortitude;
  this->reflex_parser_ = &reflex;
  this->will_parser_ = &will;
}

RPG_Monster_SavingThrowModifiers_Type_pskel::
RPG_Monster_SavingThrowModifiers_Type_pskel ()
: fortitude_parser_ (0),
  reflex_parser_ (0),
  will_parser_ (0)
{
}

// RPG_Monster_OrganizationSlaverStep_Type_pskel
//

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Dice_ValueRange_Type_pskel& range)
{
  this->name_parser_ = &name;
  this->range_parser_ = &range;
}

RPG_Monster_OrganizationSlaverStep_Type_pskel::
RPG_Monster_OrganizationSlaverStep_Type_pskel ()
: name_parser_ (0),
  range_parser_ (0)
{
}

// RPG_Monster_OrganizationStep_Type_pskel
//

void RPG_Monster_OrganizationStep_Type_pskel::
type_parser (::RPG_Monster_Organization_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
slaves_parser (::RPG_Monster_OrganizationSlaverStep_Type_pskel& p)
{
  this->slaves_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
parsers (::RPG_Monster_Organization_Type_pskel& type,
         ::RPG_Dice_ValueRange_Type_pskel& range,
         ::RPG_Monster_OrganizationSlaverStep_Type_pskel& slaves)
{
  this->type_parser_ = &type;
  this->range_parser_ = &range;
  this->slaves_parser_ = &slaves;
}

RPG_Monster_OrganizationStep_Type_pskel::
RPG_Monster_OrganizationStep_Type_pskel ()
: type_parser_ (0),
  range_parser_ (0),
  slaves_parser_ (0)
{
}

// RPG_Monster_Organizations_Type_pskel
//

void RPG_Monster_Organizations_Type_pskel::
step_parser (::RPG_Monster_OrganizationStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Monster_Organizations_Type_pskel::
parsers (::RPG_Monster_OrganizationStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Monster_Organizations_Type_pskel::
RPG_Monster_Organizations_Type_pskel ()
: step_parser_ (0)
{
}

// RPG_Monster_AdvancementStep_Type_pskel
//

void RPG_Monster_AdvancementStep_Type_pskel::
size_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Monster_AdvancementStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_AdvancementStep_Type_pskel::
parsers (::RPG_Common_Size_Type_pskel& size,
         ::RPG_Dice_ValueRange_Type_pskel& range)
{
  this->size_parser_ = &size;
  this->range_parser_ = &range;
}

RPG_Monster_AdvancementStep_Type_pskel::
RPG_Monster_AdvancementStep_Type_pskel ()
: size_parser_ (0),
  range_parser_ (0)
{
}

// RPG_Monster_Advancement_Type_pskel
//

void RPG_Monster_Advancement_Type_pskel::
step_parser (::RPG_Monster_AdvancementStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Monster_Advancement_Type_pskel::
parsers (::RPG_Monster_AdvancementStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Monster_Advancement_Type_pskel::
RPG_Monster_Advancement_Type_pskel ()
: step_parser_ (0)
{
}

// RPG_Monster_PropertiesXML_Type_pskel
//

void RPG_Monster_PropertiesXML_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
size_parser (::RPG_Monster_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
type_parser (::RPG_Common_CreatureType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
hitDice_parser (::RPG_Dice_Roll_Type_pskel& p)
{
  this->hitDice_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
initiative_parser (::xml_schema::byte_pskel& p)
{
  this->initiative_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
speed_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->speed_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
armorClass_parser (::RPG_Monster_NaturalArmorClass_Type_pskel& p)
{
  this->armorClass_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialDefense_parser (::RPG_Monster_SpecialDefenseProperties_Type_pskel& p)
{
  this->specialDefense_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
attack_parser (::RPG_Monster_Attack_Type_pskel& p)
{
  this->attack_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialAttack_parser (::RPG_Monster_SpecialAttackProperties_Type_pskel& p)
{
  this->specialAttack_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialAbility_parser (::RPG_Monster_SpecialAbilityProperties_Type_pskel& p)
{
  this->specialAbility_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
space_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->space_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
reach_parser (::xml_schema::unsigned_short_pskel& p)
{
  this->reach_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
saves_parser (::RPG_Monster_SavingThrowModifiers_Type_pskel& p)
{
  this->saves_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
attributes_parser (::RPG_Character_Attributes_Type_pskel& p)
{
  this->attributes_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
skills_parser (::RPG_Character_Skills_Type_pskel& p)
{
  this->skills_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
feats_parser (::RPG_Character_Feats_Type_pskel& p)
{
  this->feats_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
environment_parser (::RPG_Common_Environment_Type_pskel& p)
{
  this->environment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
organizations_parser (::RPG_Monster_Organizations_Type_pskel& p)
{
  this->organizations_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
challengeRating_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->challengeRating_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
treasureModifier_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->treasureModifier_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
alignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->alignment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
advancements_parser (::RPG_Monster_Advancement_Type_pskel& p)
{
  this->advancements_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
levelAdjustment_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelAdjustment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Monster_Size_Type_pskel& size,
         ::RPG_Common_CreatureType_Type_pskel& type,
         ::RPG_Dice_Roll_Type_pskel& hitDice,
         ::xml_schema::byte_pskel& initiative,
         ::xml_schema::unsigned_byte_pskel& speed,
         ::RPG_Monster_NaturalArmorClass_Type_pskel& armorClass,
         ::RPG_Monster_SpecialDefenseProperties_Type_pskel& specialDefense,
         ::RPG_Monster_Attack_Type_pskel& attack,
         ::RPG_Monster_SpecialAttackProperties_Type_pskel& specialAttack,
         ::RPG_Monster_SpecialAbilityProperties_Type_pskel& specialAbility,
         ::xml_schema::unsigned_byte_pskel& space,
         ::xml_schema::unsigned_short_pskel& reach,
         ::RPG_Monster_SavingThrowModifiers_Type_pskel& saves,
         ::RPG_Character_Attributes_Type_pskel& attributes,
         ::RPG_Character_Skills_Type_pskel& skills,
         ::RPG_Character_Feats_Type_pskel& feats,
         ::RPG_Common_Environment_Type_pskel& environment,
         ::RPG_Monster_Organizations_Type_pskel& organizations,
         ::xml_schema::unsigned_byte_pskel& challengeRating,
         ::xml_schema::unsigned_byte_pskel& treasureModifier,
         ::RPG_Character_Alignment_Type_pskel& alignment,
         ::RPG_Monster_Advancement_Type_pskel& advancements,
         ::xml_schema::unsigned_byte_pskel& levelAdjustment)
{
  this->name_parser_ = &name;
  this->size_parser_ = &size;
  this->type_parser_ = &type;
  this->hitDice_parser_ = &hitDice;
  this->initiative_parser_ = &initiative;
  this->speed_parser_ = &speed;
  this->armorClass_parser_ = &armorClass;
  this->specialDefense_parser_ = &specialDefense;
  this->attack_parser_ = &attack;
  this->specialAttack_parser_ = &specialAttack;
  this->specialAbility_parser_ = &specialAbility;
  this->space_parser_ = &space;
  this->reach_parser_ = &reach;
  this->saves_parser_ = &saves;
  this->attributes_parser_ = &attributes;
  this->skills_parser_ = &skills;
  this->feats_parser_ = &feats;
  this->environment_parser_ = &environment;
  this->organizations_parser_ = &organizations;
  this->challengeRating_parser_ = &challengeRating;
  this->treasureModifier_parser_ = &treasureModifier;
  this->alignment_parser_ = &alignment;
  this->advancements_parser_ = &advancements;
  this->levelAdjustment_parser_ = &levelAdjustment;
}

RPG_Monster_PropertiesXML_Type_pskel::
RPG_Monster_PropertiesXML_Type_pskel ()
: name_parser_ (0),
  size_parser_ (0),
  type_parser_ (0),
  hitDice_parser_ (0),
  initiative_parser_ (0),
  speed_parser_ (0),
  armorClass_parser_ (0),
  specialDefense_parser_ (0),
  attack_parser_ (0),
  specialAttack_parser_ (0),
  specialAbility_parser_ (0),
  space_parser_ (0),
  reach_parser_ (0),
  saves_parser_ (0),
  attributes_parser_ (0),
  skills_parser_ (0),
  feats_parser_ (0),
  environment_parser_ (0),
  organizations_parser_ (0),
  challengeRating_parser_ (0),
  treasureModifier_parser_ (0),
  alignment_parser_ (0),
  advancements_parser_ (0),
  levelAdjustment_parser_ (0)
{
}

// RPG_Monster_Dictionary_Type_pskel
//

void RPG_Monster_Dictionary_Type_pskel::
monster_parser (::RPG_Monster_PropertiesXML_Type_pskel& p)
{
  this->monster_parser_ = &p;
}

void RPG_Monster_Dictionary_Type_pskel::
parsers (::RPG_Monster_PropertiesXML_Type_pskel& monster)
{
  this->monster_parser_ = &monster;
}

RPG_Monster_Dictionary_Type_pskel::
RPG_Monster_Dictionary_Type_pskel ()
: monster_parser_ (0)
{
}

// RPG_Monster_Size_Type_pskel
//

void RPG_Monster_Size_Type_pskel::
size (const RPG_Common_Size&)
{
}

void RPG_Monster_Size_Type_pskel::
isTall (bool)
{
}

bool RPG_Monster_Size_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Size_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  return false;
}

bool RPG_Monster_Size_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "isTall" && ns.empty ())
  {
    if (this->isTall_parser_)
    {
      this->isTall_parser_->pre ();
      this->isTall_parser_->_pre_impl ();
      this->isTall_parser_->_characters (v);
      this->isTall_parser_->_post_impl ();
      this->isTall (this->isTall_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Monster_NaturalArmorClass_Type_pskel
//

void RPG_Monster_NaturalArmorClass_Type_pskel::
normal (signed char)
{
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
touch (signed char)
{
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
flatFooted (signed char)
{
}

bool RPG_Monster_NaturalArmorClass_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "normal" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->normal_parser_;

    if (this->normal_parser_)
      this->normal_parser_->pre ();

    return true;
  }

  if (n == "touch" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->touch_parser_;

    if (this->touch_parser_)
      this->touch_parser_->pre ();

    return true;
  }

  if (n == "flatFooted" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->flatFooted_parser_;

    if (this->flatFooted_parser_)
      this->flatFooted_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_NaturalArmorClass_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "normal" && ns == "urn:rpg")
  {
    if (this->normal_parser_)
      this->normal (this->normal_parser_->post_byte ());

    return true;
  }

  if (n == "touch" && ns == "urn:rpg")
  {
    if (this->touch_parser_)
      this->touch (this->touch_parser_->post_byte ());

    return true;
  }

  if (n == "flatFooted" && ns == "urn:rpg")
  {
    if (this->flatFooted_parser_)
      this->flatFooted (this->flatFooted_parser_->post_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialBaseProperties_Type_pskel
//

void RPG_Monster_SpecialBaseProperties_Type_pskel::
abilityClass (const RPG_Magic_AbilityClass&)
{
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
type (const RPG_Monster_SpecialPropertyTypeUnion&)
{
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
actionType (const RPG_Common_ActionType&)
{
}

void RPG_Monster_SpecialBaseProperties_Type_pskel::
usage (const RPG_Common_Usage&)
{
}

bool RPG_Monster_SpecialBaseProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "abilityClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->abilityClass_parser_;

    if (this->abilityClass_parser_)
      this->abilityClass_parser_->pre ();

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "actionType" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->actionType_parser_;

    if (this->actionType_parser_)
      this->actionType_parser_->pre ();

    return true;
  }

  if (n == "usage" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->usage_parser_;

    if (this->usage_parser_)
      this->usage_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialBaseProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "abilityClass" && ns == "urn:rpg")
  {
    if (this->abilityClass_parser_)
      this->abilityClass (this->abilityClass_parser_->post_RPG_Magic_AbilityClass_Type ());

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Monster_SpecialPropertyTypeUnion_Type ());

    return true;
  }

  if (n == "actionType" && ns == "urn:rpg")
  {
    if (this->actionType_parser_)
      this->actionType (this->actionType_parser_->post_RPG_Common_ActionType_Type ());

    return true;
  }

  if (n == "usage" && ns == "urn:rpg")
  {
    if (this->usage_parser_)
      this->usage (this->usage_parser_->post_RPG_Common_Usage_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialDefensePreCondition_Type_pskel
//

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
weaponType (const RPG_Monster_WeaponTypeUnion&)
{
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
ownCondition (const RPG_Common_Condition&)
{
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
targetCondition (const RPG_Common_Condition&)
{
}

void RPG_Monster_SpecialDefensePreCondition_Type_pskel::
isMagicalWeapon (bool)
{
}

bool RPG_Monster_SpecialDefensePreCondition_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "weaponType" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->weaponType_parser_;

    if (this->weaponType_parser_)
      this->weaponType_parser_->pre ();

    return true;
  }

  if (n == "ownCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ownCondition_parser_;

    if (this->ownCondition_parser_)
      this->ownCondition_parser_->pre ();

    return true;
  }

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->targetCondition_parser_;

    if (this->targetCondition_parser_)
      this->targetCondition_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialDefensePreCondition_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "weaponType" && ns == "urn:rpg")
  {
    if (this->weaponType_parser_)
      this->weaponType (this->weaponType_parser_->post_RPG_Monster_WeaponTypeUnion_Type ());

    return true;
  }

  if (n == "ownCondition" && ns == "urn:rpg")
  {
    if (this->ownCondition_parser_)
      this->ownCondition (this->ownCondition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    if (this->targetCondition_parser_)
      this->targetCondition (this->targetCondition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialDefensePreCondition_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "isMagicalWeapon" && ns.empty ())
  {
    if (this->isMagicalWeapon_parser_)
    {
      this->isMagicalWeapon_parser_->pre ();
      this->isMagicalWeapon_parser_->_pre_impl ();
      this->isMagicalWeapon_parser_->_characters (v);
      this->isMagicalWeapon_parser_->_post_impl ();
      this->isMagicalWeapon (this->isMagicalWeapon_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Monster_DefenseAction_Type_pskel
//

void RPG_Monster_DefenseAction_Type_pskel::
preCondition (const RPG_Monster_SpecialDefensePreCondition&)
{
}

void RPG_Monster_DefenseAction_Type_pskel::
damage (const RPG_Combat_Damage&)
{
}

void RPG_Monster_DefenseAction_Type_pskel::
ranged (const RPG_Combat_RangedAttackProperties&)
{
}

bool RPG_Monster_DefenseAction_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->preCondition_parser_;

    if (this->preCondition_parser_)
      this->preCondition_parser_->pre ();

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

    if (this->damage_parser_)
      this->damage_parser_->pre ();

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ranged_parser_;

    if (this->ranged_parser_)
      this->ranged_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_DefenseAction_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    if (this->preCondition_parser_)
      this->preCondition (this->preCondition_parser_->post_RPG_Monster_SpecialDefensePreCondition_Type ());

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    if (this->damage_parser_)
      this->damage (this->damage_parser_->post_RPG_Combat_Damage_Type ());

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    if (this->ranged_parser_)
      this->ranged (this->ranged_parser_->post_RPG_Combat_RangedAttackProperties_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialDefenseProperties_Type_pskel
//

void RPG_Monster_SpecialDefenseProperties_Type_pskel::
action (const RPG_Monster_DefenseAction&)
{
}

bool RPG_Monster_SpecialDefenseProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_start_element_impl (ns, n, t))
    return true;

  if (n == "action" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

    if (this->action_parser_)
      this->action_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialDefenseProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_end_element_impl (ns, n))
    return true;

  if (n == "action" && ns == "urn:rpg")
  {
    if (this->action_parser_)
      this->action (this->action_parser_->post_RPG_Monster_DefenseAction_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_AttackAction_Type_pskel
//

void RPG_Monster_AttackAction_Type_pskel::
weapon (const RPG_Monster_WeaponTypeUnion&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
attackBonus (signed char)
{
}

void RPG_Monster_AttackAction_Type_pskel::
attackForm (const RPG_Combat_AttackForm&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
damage (const RPG_Combat_Damage&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
effect (const RPG_Magic_SpellLikeProperties&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
numAttacksPerRound (unsigned char)
{
}

void RPG_Monster_AttackAction_Type_pskel::
ranged (const RPG_Combat_RangedAttackProperties&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
trigger (const RPG_Character_Ability&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
allAdjacent (bool)
{
}

void RPG_Monster_AttackAction_Type_pskel::
fullAttackIncludesNextAction (bool)
{
}

bool RPG_Monster_AttackAction_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->weapon_parser_;

    if (this->weapon_parser_)
      this->weapon_parser_->pre ();

    return true;
  }

  if (n == "attackBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackBonus_parser_;

    if (this->attackBonus_parser_)
      this->attackBonus_parser_->pre ();

    return true;
  }

  if (n == "attackForm" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackForm_parser_;

    if (this->attackForm_parser_)
      this->attackForm_parser_->pre ();

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

    if (this->damage_parser_)
      this->damage_parser_->pre ();

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->effect_parser_;

    if (this->effect_parser_)
      this->effect_parser_->pre ();

    return true;
  }

  if (n == "numAttacksPerRound" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->numAttacksPerRound_parser_;

    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound_parser_->pre ();

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ranged_parser_;

    if (this->ranged_parser_)
      this->ranged_parser_->pre ();

    return true;
  }

  if (n == "trigger" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->trigger_parser_;

    if (this->trigger_parser_)
      this->trigger_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_AttackAction_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    if (this->weapon_parser_)
      this->weapon (this->weapon_parser_->post_RPG_Monster_WeaponTypeUnion_Type ());

    return true;
  }

  if (n == "attackBonus" && ns == "urn:rpg")
  {
    if (this->attackBonus_parser_)
      this->attackBonus (this->attackBonus_parser_->post_byte ());

    return true;
  }

  if (n == "attackForm" && ns == "urn:rpg")
  {
    if (this->attackForm_parser_)
      this->attackForm (this->attackForm_parser_->post_RPG_Combat_AttackForm_Type ());

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    if (this->damage_parser_)
      this->damage (this->damage_parser_->post_RPG_Combat_Damage_Type ());

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    if (this->effect_parser_)
      this->effect (this->effect_parser_->post_RPG_Magic_SpellLikeProperties_Type ());

    return true;
  }

  if (n == "numAttacksPerRound" && ns == "urn:rpg")
  {
    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound (this->numAttacksPerRound_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    if (this->ranged_parser_)
      this->ranged (this->ranged_parser_->post_RPG_Combat_RangedAttackProperties_Type ());

    return true;
  }

  if (n == "trigger" && ns == "urn:rpg")
  {
    if (this->trigger_parser_)
      this->trigger (this->trigger_parser_->post_RPG_Character_Ability_Type ());

    return true;
  }

  return false;
}

bool RPG_Monster_AttackAction_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "allAdjacent" && ns.empty ())
  {
    if (this->allAdjacent_parser_)
    {
      this->allAdjacent_parser_->pre ();
      this->allAdjacent_parser_->_pre_impl ();
      this->allAdjacent_parser_->_characters (v);
      this->allAdjacent_parser_->_post_impl ();
      this->allAdjacent (this->allAdjacent_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "fullAttackIncludesNextAction" && ns.empty ())
  {
    if (this->fullAttackIncludesNextAction_parser_)
    {
      this->fullAttackIncludesNextAction_parser_->pre ();
      this->fullAttackIncludesNextAction_parser_->_pre_impl ();
      this->fullAttackIncludesNextAction_parser_->_characters (v);
      this->fullAttackIncludesNextAction_parser_->_post_impl ();
      this->fullAttackIncludesNextAction (this->fullAttackIncludesNextAction_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Monster_Attack_Type_pskel
//

void RPG_Monster_Attack_Type_pskel::
baseAttackBonus (signed char)
{
}

void RPG_Monster_Attack_Type_pskel::
grappleBonus (signed char)
{
}

void RPG_Monster_Attack_Type_pskel::
standardAttackAction (const RPG_Monster_AttackAction&)
{
}

void RPG_Monster_Attack_Type_pskel::
fullAttackAction (const RPG_Monster_AttackAction&)
{
}

void RPG_Monster_Attack_Type_pskel::
actionsAreInclusive (bool)
{
}

bool RPG_Monster_Attack_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "baseAttackBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->baseAttackBonus_parser_;

    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus_parser_->pre ();

    return true;
  }

  if (n == "grappleBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->grappleBonus_parser_;

    if (this->grappleBonus_parser_)
      this->grappleBonus_parser_->pre ();

    return true;
  }

  if (n == "standardAttackAction" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->standardAttackAction_parser_;

    if (this->standardAttackAction_parser_)
      this->standardAttackAction_parser_->pre ();

    return true;
  }

  if (n == "fullAttackAction" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fullAttackAction_parser_;

    if (this->fullAttackAction_parser_)
      this->fullAttackAction_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Attack_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "baseAttackBonus" && ns == "urn:rpg")
  {
    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus (this->baseAttackBonus_parser_->post_byte ());

    return true;
  }

  if (n == "grappleBonus" && ns == "urn:rpg")
  {
    if (this->grappleBonus_parser_)
      this->grappleBonus (this->grappleBonus_parser_->post_byte ());

    return true;
  }

  if (n == "standardAttackAction" && ns == "urn:rpg")
  {
    if (this->standardAttackAction_parser_)
      this->standardAttackAction (this->standardAttackAction_parser_->post_RPG_Monster_AttackAction_Type ());

    return true;
  }

  if (n == "fullAttackAction" && ns == "urn:rpg")
  {
    if (this->fullAttackAction_parser_)
      this->fullAttackAction (this->fullAttackAction_parser_->post_RPG_Monster_AttackAction_Type ());

    return true;
  }

  return false;
}

bool RPG_Monster_Attack_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "actionsAreInclusive" && ns.empty ())
  {
    if (this->actionsAreInclusive_parser_)
    {
      this->actionsAreInclusive_parser_->pre ();
      this->actionsAreInclusive_parser_->_pre_impl ();
      this->actionsAreInclusive_parser_->_characters (v);
      this->actionsAreInclusive_parser_->_post_impl ();
      this->actionsAreInclusive (this->actionsAreInclusive_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Monster_ActionTrigger_Type_pskel
//

void RPG_Monster_ActionTrigger_Type_pskel::
weapon (const RPG_Monster_WeaponTypeUnion&)
{
}

void RPG_Monster_ActionTrigger_Type_pskel::
numHits (unsigned char)
{
}

bool RPG_Monster_ActionTrigger_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->weapon_parser_;

    if (this->weapon_parser_)
      this->weapon_parser_->pre ();

    return true;
  }

  if (n == "numHits" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->numHits_parser_;

    if (this->numHits_parser_)
      this->numHits_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_ActionTrigger_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    if (this->weapon_parser_)
      this->weapon (this->weapon_parser_->post_RPG_Monster_WeaponTypeUnion_Type ());

    return true;
  }

  if (n == "numHits" && ns == "urn:rpg")
  {
    if (this->numHits_parser_)
      this->numHits (this->numHits_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialAttackPreCondition_Type_pskel
//

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
action (const RPG_Monster_ActionTrigger&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
targetAlignment (const RPG_Character_Alignment&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
ownCondition (const RPG_Common_Condition&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
targetCondition (const RPG_Common_Condition&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
minTargetSize (const RPG_Common_Size&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
maxTargetSize (const RPG_Common_Size&)
{
}

void RPG_Monster_SpecialAttackPreCondition_Type_pskel::
check (const RPG_Combat_Check&)
{
}

bool RPG_Monster_SpecialAttackPreCondition_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "action" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

    if (this->action_parser_)
      this->action_parser_->pre ();

    return true;
  }

  if (n == "targetAlignment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->targetAlignment_parser_;

    if (this->targetAlignment_parser_)
      this->targetAlignment_parser_->pre ();

    return true;
  }

  if (n == "ownCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ownCondition_parser_;

    if (this->ownCondition_parser_)
      this->ownCondition_parser_->pre ();

    return true;
  }

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->targetCondition_parser_;

    if (this->targetCondition_parser_)
      this->targetCondition_parser_->pre ();

    return true;
  }

  if (n == "minTargetSize" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->minTargetSize_parser_;

    if (this->minTargetSize_parser_)
      this->minTargetSize_parser_->pre ();

    return true;
  }

  if (n == "maxTargetSize" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxTargetSize_parser_;

    if (this->maxTargetSize_parser_)
      this->maxTargetSize_parser_->pre ();

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->check_parser_;

    if (this->check_parser_)
      this->check_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialAttackPreCondition_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "action" && ns == "urn:rpg")
  {
    if (this->action_parser_)
      this->action (this->action_parser_->post_RPG_Monster_ActionTrigger_Type ());

    return true;
  }

  if (n == "targetAlignment" && ns == "urn:rpg")
  {
    if (this->targetAlignment_parser_)
      this->targetAlignment (this->targetAlignment_parser_->post_RPG_Character_Alignment_Type ());

    return true;
  }

  if (n == "ownCondition" && ns == "urn:rpg")
  {
    if (this->ownCondition_parser_)
      this->ownCondition (this->ownCondition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    if (this->targetCondition_parser_)
      this->targetCondition (this->targetCondition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  if (n == "minTargetSize" && ns == "urn:rpg")
  {
    if (this->minTargetSize_parser_)
      this->minTargetSize (this->minTargetSize_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  if (n == "maxTargetSize" && ns == "urn:rpg")
  {
    if (this->maxTargetSize_parser_)
      this->maxTargetSize (this->maxTargetSize_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    if (this->check_parser_)
      this->check (this->check_parser_->post_RPG_Combat_Check_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialAttackProperties_Type_pskel
//

void RPG_Monster_SpecialAttackProperties_Type_pskel::
preCondition (const RPG_Monster_SpecialAttackPreCondition&)
{
}

void RPG_Monster_SpecialAttackProperties_Type_pskel::
action (const RPG_Monster_AttackAction&)
{
}

bool RPG_Monster_SpecialAttackProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_start_element_impl (ns, n, t))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->preCondition_parser_;

    if (this->preCondition_parser_)
      this->preCondition_parser_->pre ();

    return true;
  }

  if (n == "action" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

    if (this->action_parser_)
      this->action_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialAttackProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_end_element_impl (ns, n))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    if (this->preCondition_parser_)
      this->preCondition (this->preCondition_parser_->post_RPG_Monster_SpecialAttackPreCondition_Type ());

    return true;
  }

  if (n == "action" && ns == "urn:rpg")
  {
    if (this->action_parser_)
      this->action (this->action_parser_->post_RPG_Monster_AttackAction_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SpecialAbilityPreCondition_Type_pskel
//

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
targetCondition (const RPG_Common_Condition&)
{
}

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
maxTargetSize (const RPG_Common_Size&)
{
}

void RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
check (const RPG_Combat_Check&)
{
}

bool RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->targetCondition_parser_;

    if (this->targetCondition_parser_)
      this->targetCondition_parser_->pre ();

    return true;
  }

  if (n == "maxTargetSize" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxTargetSize_parser_;

    if (this->maxTargetSize_parser_)
      this->maxTargetSize_parser_->pre ();

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->check_parser_;

    if (this->check_parser_)
      this->check_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialAbilityPreCondition_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "targetCondition" && ns == "urn:rpg")
  {
    if (this->targetCondition_parser_)
      this->targetCondition (this->targetCondition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  if (n == "maxTargetSize" && ns == "urn:rpg")
  {
    if (this->maxTargetSize_parser_)
      this->maxTargetSize (this->maxTargetSize_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    if (this->check_parser_)
      this->check (this->check_parser_->post_RPG_Combat_Check_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SummonMonster_Type_pskel
//

void RPG_Monster_SummonMonster_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Monster_SummonMonster_Type_pskel::
amount (const RPG_Dice_Roll&)
{
}

void RPG_Monster_SummonMonster_Type_pskel::
successRate (float)
{
}

void RPG_Monster_SummonMonster_Type_pskel::
actionsAreInclusive (bool)
{
}

bool RPG_Monster_SummonMonster_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "amount" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->amount_parser_;

    if (this->amount_parser_)
      this->amount_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SummonMonster_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "amount" && ns == "urn:rpg")
  {
    if (this->amount_parser_)
      this->amount (this->amount_parser_->post_RPG_Dice_Roll_Type ());

    return true;
  }

  return false;
}

bool RPG_Monster_SummonMonster_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "successRate" && ns.empty ())
  {
    if (this->successRate_parser_)
    {
      this->successRate_parser_->pre ();
      this->successRate_parser_->_pre_impl ();
      this->successRate_parser_->_characters (v);
      this->successRate_parser_->_post_impl ();
      this->successRate (this->successRate_parser_->post_float ());
    }

    return true;
  }

  if (n == "actionsAreInclusive" && ns.empty ())
  {
    if (this->actionsAreInclusive_parser_)
    {
      this->actionsAreInclusive_parser_->pre ();
      this->actionsAreInclusive_parser_->_pre_impl ();
      this->actionsAreInclusive_parser_->_characters (v);
      this->actionsAreInclusive_parser_->_post_impl ();
      this->actionsAreInclusive (this->actionsAreInclusive_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Monster_SpecialAbilityProperties_Type_pskel
//

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
preCondition (const RPG_Monster_SpecialAbilityPreCondition&)
{
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
summon (const RPG_Monster_SummonMonster&)
{
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
spell (const RPG_Magic_SpellLikeProperties&)
{
}

void RPG_Monster_SpecialAbilityProperties_Type_pskel::
ranged (const RPG_Combat_RangedAttackProperties&)
{
}

bool RPG_Monster_SpecialAbilityProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_start_element_impl (ns, n, t))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->preCondition_parser_;

    if (this->preCondition_parser_)
      this->preCondition_parser_->pre ();

    return true;
  }

  if (n == "summon" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->summon_parser_;

    if (this->summon_parser_)
      this->summon_parser_->pre ();

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->spell_parser_;

    if (this->spell_parser_)
      this->spell_parser_->pre ();

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ranged_parser_;

    if (this->ranged_parser_)
      this->ranged_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SpecialAbilityProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::RPG_Monster_SpecialBaseProperties_Type_pskel::_end_element_impl (ns, n))
    return true;

  if (n == "preCondition" && ns == "urn:rpg")
  {
    if (this->preCondition_parser_)
      this->preCondition (this->preCondition_parser_->post_RPG_Monster_SpecialAbilityPreCondition_Type ());

    return true;
  }

  if (n == "summon" && ns == "urn:rpg")
  {
    if (this->summon_parser_)
      this->summon (this->summon_parser_->post_RPG_Monster_SummonMonster_Type ());

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    if (this->spell_parser_)
      this->spell (this->spell_parser_->post_RPG_Magic_SpellLikeProperties_Type ());

    return true;
  }

  if (n == "ranged" && ns == "urn:rpg")
  {
    if (this->ranged_parser_)
      this->ranged (this->ranged_parser_->post_RPG_Combat_RangedAttackProperties_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SavingThrowModifiers_Type_pskel
//

void RPG_Monster_SavingThrowModifiers_Type_pskel::
fortitude (signed char)
{
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
reflex (signed char)
{
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
will (signed char)
{
}

bool RPG_Monster_SavingThrowModifiers_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "fortitude" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fortitude_parser_;

    if (this->fortitude_parser_)
      this->fortitude_parser_->pre ();

    return true;
  }

  if (n == "reflex" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reflex_parser_;

    if (this->reflex_parser_)
      this->reflex_parser_->pre ();

    return true;
  }

  if (n == "will" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->will_parser_;

    if (this->will_parser_)
      this->will_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SavingThrowModifiers_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "fortitude" && ns == "urn:rpg")
  {
    if (this->fortitude_parser_)
      this->fortitude (this->fortitude_parser_->post_byte ());

    return true;
  }

  if (n == "reflex" && ns == "urn:rpg")
  {
    if (this->reflex_parser_)
      this->reflex (this->reflex_parser_->post_byte ());

    return true;
  }

  if (n == "will" && ns == "urn:rpg")
  {
    if (this->will_parser_)
      this->will (this->will_parser_->post_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_OrganizationSlaverStep_Type_pskel
//

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

bool RPG_Monster_OrganizationSlaverStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_OrganizationSlaverStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_OrganizationStep_Type_pskel
//

void RPG_Monster_OrganizationStep_Type_pskel::
type (const RPG_Monster_Organization&)
{
}

void RPG_Monster_OrganizationStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

void RPG_Monster_OrganizationStep_Type_pskel::
slaves (const RPG_Monster_OrganizationSlaverStep&)
{
}

bool RPG_Monster_OrganizationStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  if (n == "slaves" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->slaves_parser_;

    if (this->slaves_parser_)
      this->slaves_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_OrganizationStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Monster_Organization_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  if (n == "slaves" && ns == "urn:rpg")
  {
    if (this->slaves_parser_)
      this->slaves (this->slaves_parser_->post_RPG_Monster_OrganizationSlaverStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_Organizations_Type_pskel
//

void RPG_Monster_Organizations_Type_pskel::
step (const RPG_Monster_OrganizationStep&)
{
}

bool RPG_Monster_Organizations_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

    if (this->step_parser_)
      this->step_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Organizations_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    if (this->step_parser_)
      this->step (this->step_parser_->post_RPG_Monster_OrganizationStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_AdvancementStep_Type_pskel
//

void RPG_Monster_AdvancementStep_Type_pskel::
size (const RPG_Common_Size&)
{
}

void RPG_Monster_AdvancementStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

bool RPG_Monster_AdvancementStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_AdvancementStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_Advancement_Type_pskel
//

void RPG_Monster_Advancement_Type_pskel::
step (const RPG_Monster_AdvancementStep&)
{
}

bool RPG_Monster_Advancement_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

    if (this->step_parser_)
      this->step_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Advancement_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    if (this->step_parser_)
      this->step (this->step_parser_->post_RPG_Monster_AdvancementStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_PropertiesXML_Type_pskel
//

void RPG_Monster_PropertiesXML_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
size (const RPG_Monster_Size&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
type (const RPG_Common_CreatureType&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
hitDice (const RPG_Dice_Roll&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
initiative (signed char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
speed (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
armorClass (const RPG_Monster_NaturalArmorClass&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialDefense (const RPG_Monster_SpecialDefenseProperties&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
attack (const RPG_Monster_Attack&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialAttack (const RPG_Monster_SpecialAttackProperties&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
specialAbility (const RPG_Monster_SpecialAbilityProperties&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
space (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
reach (unsigned short)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
saves (const RPG_Monster_SavingThrowModifiers&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
attributes (const RPG_Character_Attributes&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
skills (const RPG_Character_Skills&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
feats (const RPG_Character_Feats&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
environment (const RPG_Common_Environment&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
organizations (const RPG_Monster_Organizations&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
challengeRating (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
treasureModifier (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
alignment (const RPG_Character_Alignment&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
advancements (const RPG_Monster_Advancement&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
levelAdjustment (unsigned char)
{
}

bool RPG_Monster_PropertiesXML_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "hitDice" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->hitDice_parser_;

    if (this->hitDice_parser_)
      this->hitDice_parser_->pre ();

    return true;
  }

  if (n == "initiative" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->initiative_parser_;

    if (this->initiative_parser_)
      this->initiative_parser_->pre ();

    return true;
  }

  if (n == "speed" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->speed_parser_;

    if (this->speed_parser_)
      this->speed_parser_->pre ();

    return true;
  }

  if (n == "armorClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->armorClass_parser_;

    if (this->armorClass_parser_)
      this->armorClass_parser_->pre ();

    return true;
  }

  if (n == "specialDefense" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->specialDefense_parser_;

    if (this->specialDefense_parser_)
      this->specialDefense_parser_->pre ();

    return true;
  }

  if (n == "attack" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attack_parser_;

    if (this->attack_parser_)
      this->attack_parser_->pre ();

    return true;
  }

  if (n == "specialAttack" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->specialAttack_parser_;

    if (this->specialAttack_parser_)
      this->specialAttack_parser_->pre ();

    return true;
  }

  if (n == "specialAbility" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->specialAbility_parser_;

    if (this->specialAbility_parser_)
      this->specialAbility_parser_->pre ();

    return true;
  }

  if (n == "space" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->space_parser_;

    if (this->space_parser_)
      this->space_parser_->pre ();

    return true;
  }

  if (n == "reach" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reach_parser_;

    if (this->reach_parser_)
      this->reach_parser_->pre ();

    return true;
  }

  if (n == "saves" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->saves_parser_;

    if (this->saves_parser_)
      this->saves_parser_->pre ();

    return true;
  }

  if (n == "attributes" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attributes_parser_;

    if (this->attributes_parser_)
      this->attributes_parser_->pre ();

    return true;
  }

  if (n == "skills" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->skills_parser_;

    if (this->skills_parser_)
      this->skills_parser_->pre ();

    return true;
  }

  if (n == "feats" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->feats_parser_;

    if (this->feats_parser_)
      this->feats_parser_->pre ();

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->environment_parser_;

    if (this->environment_parser_)
      this->environment_parser_->pre ();

    return true;
  }

  if (n == "organizations" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->organizations_parser_;

    if (this->organizations_parser_)
      this->organizations_parser_->pre ();

    return true;
  }

  if (n == "challengeRating" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->challengeRating_parser_;

    if (this->challengeRating_parser_)
      this->challengeRating_parser_->pre ();

    return true;
  }

  if (n == "treasureModifier" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->treasureModifier_parser_;

    if (this->treasureModifier_parser_)
      this->treasureModifier_parser_->pre ();

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alignment_parser_;

    if (this->alignment_parser_)
      this->alignment_parser_->pre ();

    return true;
  }

  if (n == "advancements" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->advancements_parser_;

    if (this->advancements_parser_)
      this->advancements_parser_->pre ();

    return true;
  }

  if (n == "levelAdjustment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelAdjustment_parser_;

    if (this->levelAdjustment_parser_)
      this->levelAdjustment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_PropertiesXML_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Monster_Size_Type ());

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Common_CreatureType_Type ());

    return true;
  }

  if (n == "hitDice" && ns == "urn:rpg")
  {
    if (this->hitDice_parser_)
      this->hitDice (this->hitDice_parser_->post_RPG_Dice_Roll_Type ());

    return true;
  }

  if (n == "initiative" && ns == "urn:rpg")
  {
    if (this->initiative_parser_)
      this->initiative (this->initiative_parser_->post_byte ());

    return true;
  }

  if (n == "speed" && ns == "urn:rpg")
  {
    if (this->speed_parser_)
      this->speed (this->speed_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "armorClass" && ns == "urn:rpg")
  {
    if (this->armorClass_parser_)
      this->armorClass (this->armorClass_parser_->post_RPG_Monster_NaturalArmorClass_Type ());

    return true;
  }

  if (n == "specialDefense" && ns == "urn:rpg")
  {
    if (this->specialDefense_parser_)
      this->specialDefense (this->specialDefense_parser_->post_RPG_Monster_SpecialDefenseProperties_Type ());

    return true;
  }

  if (n == "attack" && ns == "urn:rpg")
  {
    if (this->attack_parser_)
      this->attack (this->attack_parser_->post_RPG_Monster_Attack_Type ());

    return true;
  }

  if (n == "specialAttack" && ns == "urn:rpg")
  {
    if (this->specialAttack_parser_)
      this->specialAttack (this->specialAttack_parser_->post_RPG_Monster_SpecialAttackProperties_Type ());

    return true;
  }

  if (n == "specialAbility" && ns == "urn:rpg")
  {
    if (this->specialAbility_parser_)
      this->specialAbility (this->specialAbility_parser_->post_RPG_Monster_SpecialAbilityProperties_Type ());

    return true;
  }

  if (n == "space" && ns == "urn:rpg")
  {
    if (this->space_parser_)
      this->space (this->space_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "reach" && ns == "urn:rpg")
  {
    if (this->reach_parser_)
      this->reach (this->reach_parser_->post_unsigned_short ());

    return true;
  }

  if (n == "saves" && ns == "urn:rpg")
  {
    if (this->saves_parser_)
      this->saves (this->saves_parser_->post_RPG_Monster_SavingThrowModifiers_Type ());

    return true;
  }

  if (n == "attributes" && ns == "urn:rpg")
  {
    if (this->attributes_parser_)
      this->attributes (this->attributes_parser_->post_RPG_Character_Attributes_Type ());

    return true;
  }

  if (n == "skills" && ns == "urn:rpg")
  {
    if (this->skills_parser_)
      this->skills (this->skills_parser_->post_RPG_Character_Skills_Type ());

    return true;
  }

  if (n == "feats" && ns == "urn:rpg")
  {
    if (this->feats_parser_)
      this->feats (this->feats_parser_->post_RPG_Character_Feats_Type ());

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    if (this->environment_parser_)
      this->environment (this->environment_parser_->post_RPG_Common_Environment_Type ());

    return true;
  }

  if (n == "organizations" && ns == "urn:rpg")
  {
    if (this->organizations_parser_)
      this->organizations (this->organizations_parser_->post_RPG_Monster_Organizations_Type ());

    return true;
  }

  if (n == "challengeRating" && ns == "urn:rpg")
  {
    if (this->challengeRating_parser_)
      this->challengeRating (this->challengeRating_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "treasureModifier" && ns == "urn:rpg")
  {
    if (this->treasureModifier_parser_)
      this->treasureModifier (this->treasureModifier_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    if (this->alignment_parser_)
      this->alignment (this->alignment_parser_->post_RPG_Character_Alignment_Type ());

    return true;
  }

  if (n == "advancements" && ns == "urn:rpg")
  {
    if (this->advancements_parser_)
      this->advancements (this->advancements_parser_->post_RPG_Monster_Advancement_Type ());

    return true;
  }

  if (n == "levelAdjustment" && ns == "urn:rpg")
  {
    if (this->levelAdjustment_parser_)
      this->levelAdjustment (this->levelAdjustment_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_Dictionary_Type_pskel
//

void RPG_Monster_Dictionary_Type_pskel::
monster (const RPG_Monster_PropertiesXML&)
{
}

void RPG_Monster_Dictionary_Type_pskel::
post_RPG_Monster_Dictionary_Type ()
{
}

bool RPG_Monster_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "monster" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->monster_parser_;

    if (this->monster_parser_)
      this->monster_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "monster" && ns == "urn:rpg")
  {
    if (this->monster_parser_)
      this->monster (this->monster_parser_->post_RPG_Monster_PropertiesXML_Type ());

    return true;
  }

  return false;
}

// Begin epilogue.
//
//
// End epilogue.

