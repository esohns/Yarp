// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___RPG_CHARACTER_XML_TREE_H
#define CXX___RPG_CHARACTER_XML_TREE_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "rpg_XMLSchema_XML_tree.h"

// Forward declarations.
//
class RPG_Character_Gender_XMLTree_Type;
class RPG_Character_Race_XMLTree_Type;
class RPG_Character_MetaClass_XMLTree_Type;
class RPG_Character_ClassXML_XMLTree_Type;
class RPG_Character_Ability_XMLTree_Type;
class RPG_Character_Abilities_XMLTree_Type;
class RPG_Character_Attributes_XMLTree_Type;
class RPG_Character_SkillValue_XMLTree_Type;
class RPG_Character_Skills_XMLTree_Type;
class RPG_Character_CheckTypeUnion_XMLTree_Type;
class RPG_Character_Check_XMLTree_Type;
class RPG_Character_Feat_XMLTree_Type;
class RPG_Character_Feats_XMLTree_Type;
class RPG_Character_AlignmentCivic_XMLTree_Type;
class RPG_Character_AlignmentEthic_XMLTree_Type;
class RPG_Character_Alignment_XMLTree_Type;
class RPG_Character_EquipmentSlot_XMLTree_Type;
class RPG_Character_OffHand_XMLTree_Type;

#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#include "rpg_common_XML_tree.h"

class RPG_Character_Gender_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    GENDER_NONE,
    GENDER_FEMALE,
    GENDER_MALE,
    GENDER_ANY
  };

  RPG_Character_Gender_XMLTree_Type (value v);

  RPG_Character_Gender_XMLTree_Type (const char* v);

  RPG_Character_Gender_XMLTree_Type (const ::std::string& v);

  RPG_Character_Gender_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_Gender_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Gender_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Gender_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Gender_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Gender_XMLTree_Type (const RPG_Character_Gender_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Character_Gender_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_Gender_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_Gender_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_Gender_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_Gender_XMLTree_Type_literals_[4];
  static const value _xsd_RPG_Character_Gender_XMLTree_Type_indexes_[4];
};

class RPG_Character_Race_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    RACE_NONE,
    RACE_DWARF,
    RACE_ELF,
    RACE_GNOME,
    RACE_HALFLING,
    RACE_HUMAN,
    RACE_ORC
  };

  RPG_Character_Race_XMLTree_Type (value v);

  RPG_Character_Race_XMLTree_Type (const char* v);

  RPG_Character_Race_XMLTree_Type (const ::std::string& v);

  RPG_Character_Race_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_Race_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Race_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Race_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Race_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Race_XMLTree_Type (const RPG_Character_Race_XMLTree_Type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual RPG_Character_Race_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_Race_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_Race_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_Race_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_Race_XMLTree_Type_literals_[7];
  static const value _xsd_RPG_Character_Race_XMLTree_Type_indexes_[7];
};

class RPG_Character_MetaClass_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    METACLASS_NONE,
    METACLASS_PRIEST,
    METACLASS_ROGUE,
    METACLASS_WARRIOR,
    METACLASS_WIZARD
  };

  RPG_Character_MetaClass_XMLTree_Type (value v);

  RPG_Character_MetaClass_XMLTree_Type (const char* v);

  RPG_Character_MetaClass_XMLTree_Type (const ::std::string& v);

  RPG_Character_MetaClass_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_MetaClass_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_MetaClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_MetaClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_MetaClass_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_MetaClass_XMLTree_Type (const RPG_Character_MetaClass_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Character_MetaClass_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_MetaClass_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_MetaClass_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_MetaClass_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_MetaClass_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Character_MetaClass_XMLTree_Type_indexes_[5];
};

class RPG_Character_ClassXML_XMLTree_Type: public ::xml_schema::type
{
  public:
  // metaClass
  // 
  typedef ::RPG_Character_MetaClass_XMLTree_Type metaClass_type;
  typedef ::xsd::cxx::tree::traits< metaClass_type, char > metaClass_traits;

  const metaClass_type&
  metaClass () const;

  metaClass_type&
  metaClass ();

  void
  metaClass (const metaClass_type& x);

  void
  metaClass (::std::auto_ptr< metaClass_type > p);

  // subClass
  // 
  typedef ::RPG_Common_SubClass_XMLTree_Type subClass_type;
  typedef ::xsd::cxx::tree::sequence< subClass_type > subClass_sequence;
  typedef subClass_sequence::iterator subClass_iterator;
  typedef subClass_sequence::const_iterator subClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< subClass_type, char > subClass_traits;

  const subClass_sequence&
  subClass () const;

  subClass_sequence&
  subClass ();

  void
  subClass (const subClass_sequence& s);

  // Constructors.
  //
  RPG_Character_ClassXML_XMLTree_Type (const metaClass_type&);

  RPG_Character_ClassXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Character_ClassXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Character_ClassXML_XMLTree_Type (const RPG_Character_ClassXML_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Character_ClassXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_ClassXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< metaClass_type > metaClass_;
  subClass_sequence subClass_;
};

bool
operator== (const RPG_Character_ClassXML_XMLTree_Type&, const RPG_Character_ClassXML_XMLTree_Type&);

bool
operator!= (const RPG_Character_ClassXML_XMLTree_Type&, const RPG_Character_ClassXML_XMLTree_Type&);


class RPG_Character_Ability_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ABILITY_ACID_ATTACK,
    ABILITY_CORROSIVE_SLIME,
    ABILITY_DEATH_THROES,
    ABILITY_ENTANGLE,
    ABILITY_FLAMING_BODY,
    ABILITY_LEAP_ATTACK,
    ABILITY_REND_ARMOR,
    ABILITY_SCORE_LOSS,
    ABILITY_SNEAK_ATTACK,
    ABILITY_SPORES,
    ABILITY_STENCH,
    ABILITY_THROW_WEB,
    ABILITY_ALTERNATE_FORM,
    ABILITY_ANTIMAGIC,
    ABILITY_BLINDSIGHT,
    ABILITY_BLINDSENSE,
    ABILITY_BREATH_WEAPON,
    ABILITY_CHANGE_SHAPE,
    ABILITY_CHARM,
    ABILITY_COMPULSION,
    ABILITY_IMMUNITY_COLD,
    ABILITY_CONSTRICT,
    ABILITY_RESISTANCE_TO_DAMAGE,
    ABILITY_DARKVISION,
    ABILITY_DEATH_ATTACK,
    ABILITY_DISEASE,
    ABILITY_ENERGY_DRAIN,
    ABILITY_ETHEREALNESS,
    ABILITY_EVASION,
    ABILITY_IMPROVED_EVASION,
    ABILITY_FAST_HEALING,
    ABILITY_FEAR,
    ABILITY_IMMUNITY_FIRE,
    ABILITY_GASEOUS_FORM,
    ABILITY_GAZE_ATTACK,
    ABILITY_IMPROVED_GRAB,
    ABILITY_INCORPOREALITY,
    ABILITY_INVISIBILITY,
    ABILITY_LEVEL_LOSS,
    ABILITY_LOWLIGHT_VISION,
    ABILITY_MANUFACTURED_WEAPONS,
    ABILITY_MOVEMENT_MODES,
    ABILITY_NATURAL_WEAPONS,
    ABILITY_NONABILITIES,
    ABILITY_PARALYZE_ATTACK,
    ABILITY_POISON_ATTACK,
    ABILITY_IMMUNITY_POISON,
    ABILITY_POLYMORPH,
    ABILITY_POUNCE,
    ABILITY_POWERFUL_CHARGE,
    ABILITY_PSIONICS,
    ABILITY_RAKE,
    ABILITY_RAY_ATTACK,
    ABILITY_REGENERATION,
    ABILITY_RESISTANCE_TO_ENERGY,
    ABILITY_SCENT,
    ABILITY_SONIC_ATTACK,
    ABILITY_IMMUNITY_SPELL,
    ABILITY_RESISTANCE_TO_SPELL,
    ABILITY_SPELLS,
    ABILITY_SUMMON,
    ABILITY_SWALLOW_WHOLE,
    ABILITY_TELEPATHY,
    ABILITY_TRAMPLE,
    ABILITY_TREMOR_SENSE,
    ABILITY_RESISTANCE_TO_TURNING,
    ABILITY_VULNERABILITY_TO_ENERGY,
    ABILITY_IMMUNITY_DISEASE,
    ABILITY_ANIMAL_COMPANION,
    ABILITY_WOODLAND_STRIDE,
    ABILITY_SENSE_TRAPS,
    ABILITY_UNCANNY_DODGE,
    ABILITY_IMPROVED_UNCANNY_DODGE,
    ABILITY_CRIPPLING_STRIKE,
    ABILITY_DEFENSIVE_ROLL,
    ABILITY_OPPORTUNIST,
    ABILITY_SKILL_MASTERY,
    ABILITY_SLIPPERY_MIND,
    ABILITY_BONUS_FEAT
  };

  RPG_Character_Ability_XMLTree_Type (value v);

  RPG_Character_Ability_XMLTree_Type (const char* v);

  RPG_Character_Ability_XMLTree_Type (const ::std::string& v);

  RPG_Character_Ability_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_Ability_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_Ability_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_Ability_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_Ability_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_Ability_XMLTree_Type (const RPG_Character_Ability_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Character_Ability_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_Ability_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_Ability_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_Ability_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_Ability_XMLTree_Type_literals_[79];
  static const value _xsd_RPG_Character_Ability_XMLTree_Type_indexes_[79];
};

class RPG_Character_Abilities_XMLTree_Type: public ::xml_schema::type
{
  public:
  // ability
  // 
  typedef ::RPG_Character_Ability_XMLTree_Type ability_type;
  typedef ::xsd::cxx::tree::sequence< ability_type > ability_sequence;
  typedef ability_sequence::iterator ability_iterator;
  typedef ability_sequence::const_iterator ability_const_iterator;
  typedef ::xsd::cxx::tree::traits< ability_type, char > ability_traits;

  const ability_sequence&
  ability () const;

  ability_sequence&
  ability ();

  void
  ability (const ability_sequence& s);

  // Constructors.
  //
  RPG_Character_Abilities_XMLTree_Type ();

  RPG_Character_Abilities_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_Abilities_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_Abilities_XMLTree_Type (const RPG_Character_Abilities_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Character_Abilities_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Abilities_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ability_sequence ability_;
};

bool
operator== (const RPG_Character_Abilities_XMLTree_Type&, const RPG_Character_Abilities_XMLTree_Type&);

bool
operator!= (const RPG_Character_Abilities_XMLTree_Type&, const RPG_Character_Abilities_XMLTree_Type&);


class RPG_Character_Attributes_XMLTree_Type: public ::xml_schema::type
{
  public:
  // strength
  // 
  typedef ::xml_schema::unsigned_byte strength_type;
  typedef ::xsd::cxx::tree::traits< strength_type, char > strength_traits;

  const strength_type&
  strength () const;

  strength_type&
  strength ();

  void
  strength (const strength_type& x);

  // dexterity
  // 
  typedef ::xml_schema::unsigned_byte dexterity_type;
  typedef ::xsd::cxx::tree::traits< dexterity_type, char > dexterity_traits;

  const dexterity_type&
  dexterity () const;

  dexterity_type&
  dexterity ();

  void
  dexterity (const dexterity_type& x);

  // constitution
  // 
  typedef ::xml_schema::unsigned_byte constitution_type;
  typedef ::xsd::cxx::tree::traits< constitution_type, char > constitution_traits;

  const constitution_type&
  constitution () const;

  constitution_type&
  constitution ();

  void
  constitution (const constitution_type& x);

  // intelligence
  // 
  typedef ::xml_schema::unsigned_byte intelligence_type;
  typedef ::xsd::cxx::tree::traits< intelligence_type, char > intelligence_traits;

  const intelligence_type&
  intelligence () const;

  intelligence_type&
  intelligence ();

  void
  intelligence (const intelligence_type& x);

  // wisdom
  // 
  typedef ::xml_schema::unsigned_byte wisdom_type;
  typedef ::xsd::cxx::tree::traits< wisdom_type, char > wisdom_traits;

  const wisdom_type&
  wisdom () const;

  wisdom_type&
  wisdom ();

  void
  wisdom (const wisdom_type& x);

  // charisma
  // 
  typedef ::xml_schema::unsigned_byte charisma_type;
  typedef ::xsd::cxx::tree::traits< charisma_type, char > charisma_traits;

  const charisma_type&
  charisma () const;

  charisma_type&
  charisma ();

  void
  charisma (const charisma_type& x);

  // Constructors.
  //
  RPG_Character_Attributes_XMLTree_Type (const strength_type&,
                                         const dexterity_type&,
                                         const constitution_type&,
                                         const intelligence_type&,
                                         const wisdom_type&,
                                         const charisma_type&);

  RPG_Character_Attributes_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Character_Attributes_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Character_Attributes_XMLTree_Type (const RPG_Character_Attributes_XMLTree_Type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual RPG_Character_Attributes_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Attributes_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< strength_type > strength_;
  ::xsd::cxx::tree::one< dexterity_type > dexterity_;
  ::xsd::cxx::tree::one< constitution_type > constitution_;
  ::xsd::cxx::tree::one< intelligence_type > intelligence_;
  ::xsd::cxx::tree::one< wisdom_type > wisdom_;
  ::xsd::cxx::tree::one< charisma_type > charisma_;
};

bool
operator== (const RPG_Character_Attributes_XMLTree_Type&, const RPG_Character_Attributes_XMLTree_Type&);

bool
operator!= (const RPG_Character_Attributes_XMLTree_Type&, const RPG_Character_Attributes_XMLTree_Type&);


class RPG_Character_SkillValue_XMLTree_Type: public ::xml_schema::type
{
  public:
  // skill
  // 
  typedef ::RPG_Common_Skill_XMLTree_Type skill_type;
  typedef ::xsd::cxx::tree::traits< skill_type, char > skill_traits;

  const skill_type&
  skill () const;

  skill_type&
  skill ();

  void
  skill (const skill_type& x);

  void
  skill (::std::auto_ptr< skill_type > p);

  // rank
  // 
  typedef ::xml_schema::byte rank_type;
  typedef ::xsd::cxx::tree::traits< rank_type, char > rank_traits;

  const rank_type&
  rank () const;

  rank_type&
  rank ();

  void
  rank (const rank_type& x);

  // Constructors.
  //
  RPG_Character_SkillValue_XMLTree_Type (const skill_type&,
                                         const rank_type&);

  RPG_Character_SkillValue_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Character_SkillValue_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Character_SkillValue_XMLTree_Type (const RPG_Character_SkillValue_XMLTree_Type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual RPG_Character_SkillValue_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_SkillValue_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< skill_type > skill_;
  ::xsd::cxx::tree::one< rank_type > rank_;
};

bool
operator== (const RPG_Character_SkillValue_XMLTree_Type&, const RPG_Character_SkillValue_XMLTree_Type&);

bool
operator!= (const RPG_Character_SkillValue_XMLTree_Type&, const RPG_Character_SkillValue_XMLTree_Type&);


class RPG_Character_Skills_XMLTree_Type: public ::xml_schema::type
{
  public:
  // skill
  // 
  typedef ::RPG_Character_SkillValue_XMLTree_Type skill_type;
  typedef ::xsd::cxx::tree::sequence< skill_type > skill_sequence;
  typedef skill_sequence::iterator skill_iterator;
  typedef skill_sequence::const_iterator skill_const_iterator;
  typedef ::xsd::cxx::tree::traits< skill_type, char > skill_traits;

  const skill_sequence&
  skill () const;

  skill_sequence&
  skill ();

  void
  skill (const skill_sequence& s);

  // Constructors.
  //
  RPG_Character_Skills_XMLTree_Type ();

  RPG_Character_Skills_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Skills_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Character_Skills_XMLTree_Type (const RPG_Character_Skills_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Character_Skills_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Skills_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  skill_sequence skill_;
};

bool
operator== (const RPG_Character_Skills_XMLTree_Type&, const RPG_Character_Skills_XMLTree_Type&);

bool
operator!= (const RPG_Character_Skills_XMLTree_Type&, const RPG_Character_Skills_XMLTree_Type&);


class RPG_Character_CheckTypeUnion_XMLTree_Type: public ::xml_schema::string
{
  public:

  RPG_Character_CheckTypeUnion_XMLTree_Type (const char* v);

  RPG_Character_CheckTypeUnion_XMLTree_Type (const ::std::string& v);

  RPG_Character_CheckTypeUnion_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_CheckTypeUnion_XMLTree_Type (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_CheckTypeUnion_XMLTree_Type (const RPG_Character_CheckTypeUnion_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Character_CheckTypeUnion_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;
};

class RPG_Character_Check_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Character_CheckTypeUnion_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // difficultyClass
  // 
  typedef ::xml_schema::unsigned_byte difficultyClass_type;
  typedef ::xsd::cxx::tree::traits< difficultyClass_type, char > difficultyClass_traits;

  const difficultyClass_type&
  difficultyClass () const;

  difficultyClass_type&
  difficultyClass ();

  void
  difficultyClass (const difficultyClass_type& x);

  // Constructors.
  //
  RPG_Character_Check_XMLTree_Type (const type_type&,
                                    const difficultyClass_type&);

  RPG_Character_Check_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Character_Check_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Character_Check_XMLTree_Type (const RPG_Character_Check_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Character_Check_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Check_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< difficultyClass_type > difficultyClass_;
};

bool
operator== (const RPG_Character_Check_XMLTree_Type&, const RPG_Character_Check_XMLTree_Type&);

bool
operator!= (const RPG_Character_Check_XMLTree_Type&, const RPG_Character_Check_XMLTree_Type&);


class RPG_Character_Feat_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    FEAT_BLIND_FIGHT,
    FEAT_COMBAT_EXPERTISE,
    FEAT_IMPROVED_DISARM,
    FEAT_IMPROVED_FEINT,
    FEAT_IMPROVED_TRIP,
    FEAT_WHIRLWIND_ATTACK,
    FEAT_COMBAT_REFLEXES,
    FEAT_DODGE,
    FEAT_MOBILITY,
    FEAT_SPRING_ATTACK,
    FEAT_PROFICIENCY_EXOTIC_WEAPONS,
    FEAT_IMPROVED_CRITICAL,
    FEAT_IMPROVED_INITIATIVE,
    FEAT_IMPROVED_SHIELD_BASH,
    FEAT_IMPROVED_UNARMED_STRIKE,
    FEAT_DEFLECT_ARROWS,
    FEAT_IMPROVED_GRAPPLE,
    FEAT_SNATCH_ARROWS,
    FEAT_STUNNING_FIST,
    FEAT_MOUNTED_COMBAT,
    FEAT_MOUNTED_ARCHERY,
    FEAT_RIDE_BY_ATTACK,
    FEAT_SPIRITED_CHARGE,
    FEAT_TRAMPLE,
    FEAT_POINT_BLANK_SHOT,
    FEAT_FAR_SHOT,
    FEAT_PRECISE_SHOT,
    FEAT_RAPID_SHOT,
    FEAT_MANY_SHOT,
    FEAT_SHOT_ON_THE_RUN,
    FEAT_IMPROVED_PRECISE_SHOT,
    FEAT_POWER_ATTACK,
    FEAT_CLEAVE,
    FEAT_GREAT_CLEAVE,
    FEAT_IMPROVED_BULL_RUSH,
    FEAT_IMPROVED_OVERRUN,
    FEAT_IMPROVED_SUNDER,
    FEAT_QUICK_DRAW,
    FEAT_RAPID_RELOAD,
    FEAT_TWO_WEAPON_FIGHTING,
    FEAT_TWO_WEAPON_DEFENSE,
    FEAT_IMPROVED_TWO_WEAPON_FIGHTING,
    FEAT_GREATER_TWO_WEAPON_FIGHTING,
    FEAT_WEAPON_FINESSE,
    FEAT_WEAPON_FOCUS,
    FEAT_WEAPON_SPECIALIZATION,
    FEAT_GREATER_WEAPON_FOCUS,
    FEAT_GREATER_WEAPON_SPECIALIZATION,
    FEAT_BREW_POTION,
    FEAT_CRAFT_MAGIC_ARMS_AND_ARMOR,
    FEAT_CRAFT_ROD,
    FEAT_CRAFT_STAFF,
    FEAT_CRAFT_WAND,
    FEAT_CRAFT_WONDROUS_ITEM,
    FEAT_FORGE_RING,
    FEAT_SCRIBE_SCROLL,
    FEAT_EMPOWER_SPELL,
    FEAT_ENLARGE_SPELL,
    FEAT_EXTEND_SPELL,
    FEAT_HEIGHTEN_SPELL,
    FEAT_MAXIMIZE_SPELL,
    FEAT_QUICKEN_SPELL,
    FEAT_SILENT_SPELL,
    FEAT_WIDEN_SPELL,
    FEAT_ACROBATIC,
    FEAT_AGILE,
    FEAT_ALERTNESS,
    FEAT_ANIMAL_AFFINITY,
    FEAT_PROFICIENCY_ARMOR_LIGHT,
    FEAT_PROFICIENCY_ARMOR_MEDIUM,
    FEAT_PROFICIENCY_ARMOR_HEAVY,
    FEAT_ATHLETIC,
    FEAT_AUGMENT_SUMMONING,
    FEAT_COMBAT_CASTING,
    FEAT_DECEITFUL,
    FEAT_DEFT_HANDS,
    FEAT_DILIGENT,
    FEAT_ENDURANCE,
    FEAT_DIE_HARD,
    FEAT_ESCHEW_MATERIALS,
    FEAT_EXTRA_TURNING,
    FEAT_GREAT_FORTITUDE,
    FEAT_IMPROVED_COUNTERSPELL,
    FEAT_IMPROVED_FAMILIAR,
    FEAT_IMPROVED_TURNING,
    FEAT_INVESTIGATOR,
    FEAT_IRON_WILL,
    FEAT_LEADERSHIP,
    FEAT_LIGHTNING_REFLEXES,
    FEAT_MAGICAL_APTITUDE,
    FEAT_PROFICIENCY_MARTIAL_WEAPONS,
    FEAT_NATURAL_SPELL,
    FEAT_NEGOTIATOR,
    FEAT_NIMBLE_FINGERS,
    FEAT_PERSUASIVE,
    FEAT_RUN,
    FEAT_SELF_SUFFICIENT,
    FEAT_PROFICIENCY_SHIELD,
    FEAT_PROFICIENCY_TOWER_SHIELD,
    FEAT_PROFICIENCY_SIMPLE_WEAPONS,
    FEAT_SKILL_FOCUS,
    FEAT_SPELL_FOCUS,
    FEAT_GREATER_SPELL_FOCUS,
    FEAT_SPELL_MASTERY,
    FEAT_SPELL_PENETRATION,
    FEAT_GREATER_SPELL_PENETRATION,
    FEAT_STEALTHY,
    FEAT_TOUGHNESS,
    FEAT_TRACK,
    FEAT_ABILITY_FOCUS,
    FEAT_AWESOME_BLOW,
    FEAT_CRAFT_CONSTRUCT,
    FEAT_EMPOWER_SPELLLIKE_ABILITY,
    FEAT_FLYBY_ATTACK,
    FEAT_HOVER,
    FEAT_IMPROVED_NATURAL_ARMOR,
    FEAT_IMPROVED_NATURAL_ATTACK,
    FEAT_MULTI_ATTACK,
    FEAT_MULTIWEAPON_FIGHTING,
    FEAT_QUICKEN_SPELLLIKE_ABILITY,
    FEAT_SNATCH,
    FEAT_WINGOVER
  };

  RPG_Character_Feat_XMLTree_Type (value v);

  RPG_Character_Feat_XMLTree_Type (const char* v);

  RPG_Character_Feat_XMLTree_Type (const ::std::string& v);

  RPG_Character_Feat_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_Feat_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Feat_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Feat_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Feat_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Character_Feat_XMLTree_Type (const RPG_Character_Feat_XMLTree_Type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual RPG_Character_Feat_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_Feat_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_Feat_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_Feat_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_Feat_XMLTree_Type_literals_[122];
  static const value _xsd_RPG_Character_Feat_XMLTree_Type_indexes_[122];
};

class RPG_Character_Feats_XMLTree_Type: public ::xml_schema::type
{
  public:
  // feat
  // 
  typedef ::RPG_Character_Feat_XMLTree_Type feat_type;
  typedef ::xsd::cxx::tree::sequence< feat_type > feat_sequence;
  typedef feat_sequence::iterator feat_iterator;
  typedef feat_sequence::const_iterator feat_const_iterator;
  typedef ::xsd::cxx::tree::traits< feat_type, char > feat_traits;

  const feat_sequence&
  feat () const;

  feat_sequence&
  feat ();

  void
  feat (const feat_sequence& s);

  // Constructors.
  //
  RPG_Character_Feats_XMLTree_Type ();

  RPG_Character_Feats_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Character_Feats_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Character_Feats_XMLTree_Type (const RPG_Character_Feats_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Character_Feats_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Feats_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  feat_sequence feat_;
};

bool
operator== (const RPG_Character_Feats_XMLTree_Type&, const RPG_Character_Feats_XMLTree_Type&);

bool
operator!= (const RPG_Character_Feats_XMLTree_Type&, const RPG_Character_Feats_XMLTree_Type&);


class RPG_Character_AlignmentCivic_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ALIGNMENTCIVIC_CHAOTIC,
    ALIGNMENTCIVIC_LAWFUL,
    ALIGNMENTCIVIC_NEUTRAL,
    ALIGNMENTCIVIC_ANY
  };

  RPG_Character_AlignmentCivic_XMLTree_Type (value v);

  RPG_Character_AlignmentCivic_XMLTree_Type (const char* v);

  RPG_Character_AlignmentCivic_XMLTree_Type (const ::std::string& v);

  RPG_Character_AlignmentCivic_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_AlignmentCivic_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentCivic_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentCivic_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentCivic_XMLTree_Type (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentCivic_XMLTree_Type (const RPG_Character_AlignmentCivic_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Character_AlignmentCivic_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_AlignmentCivic_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_literals_[4];
  static const value _xsd_RPG_Character_AlignmentCivic_XMLTree_Type_indexes_[4];
};

class RPG_Character_AlignmentEthic_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ALIGNMENTETHIC_EVIL,
    ALIGNMENTETHIC_GOOD,
    ALIGNMENTETHIC_NEUTRAL,
    ALIGNMENTETHIC_ANY
  };

  RPG_Character_AlignmentEthic_XMLTree_Type (value v);

  RPG_Character_AlignmentEthic_XMLTree_Type (const char* v);

  RPG_Character_AlignmentEthic_XMLTree_Type (const ::std::string& v);

  RPG_Character_AlignmentEthic_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_AlignmentEthic_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentEthic_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentEthic_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentEthic_XMLTree_Type (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Character_AlignmentEthic_XMLTree_Type (const RPG_Character_AlignmentEthic_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Character_AlignmentEthic_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_AlignmentEthic_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_literals_[4];
  static const value _xsd_RPG_Character_AlignmentEthic_XMLTree_Type_indexes_[4];
};

class RPG_Character_Alignment_XMLTree_Type: public ::xml_schema::type
{
  public:
  // civic
  // 
  typedef ::RPG_Character_AlignmentCivic_XMLTree_Type civic_type;
  typedef ::xsd::cxx::tree::traits< civic_type, char > civic_traits;

  const civic_type&
  civic () const;

  civic_type&
  civic ();

  void
  civic (const civic_type& x);

  void
  civic (::std::auto_ptr< civic_type > p);

  // ethic
  // 
  typedef ::RPG_Character_AlignmentEthic_XMLTree_Type ethic_type;
  typedef ::xsd::cxx::tree::traits< ethic_type, char > ethic_traits;

  const ethic_type&
  ethic () const;

  ethic_type&
  ethic ();

  void
  ethic (const ethic_type& x);

  void
  ethic (::std::auto_ptr< ethic_type > p);

  // Constructors.
  //
  RPG_Character_Alignment_XMLTree_Type (const civic_type&,
                                        const ethic_type&);

  RPG_Character_Alignment_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_Alignment_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Character_Alignment_XMLTree_Type (const RPG_Character_Alignment_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Character_Alignment_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Character_Alignment_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< civic_type > civic_;
  ::xsd::cxx::tree::one< ethic_type > ethic_;
};

bool
operator== (const RPG_Character_Alignment_XMLTree_Type&, const RPG_Character_Alignment_XMLTree_Type&);

bool
operator!= (const RPG_Character_Alignment_XMLTree_Type&, const RPG_Character_Alignment_XMLTree_Type&);


class RPG_Character_EquipmentSlot_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    EQUIPMENTSLOT_BODY,
    EQUIPMENTSLOT_EYES,
    EQUIPMENTSLOT_FEET,
    EQUIPMENTSLOT_FINGER,
    EQUIPMENTSLOT_HAND_LEFT,
    EQUIPMENTSLOT_HAND_RIGHT,
    EQUIPMENTSLOT_HANDS,
    EQUIPMENTSLOT_HEAD,
    EQUIPMENTSLOT_NECK,
    EQUIPMENTSLOT_SHOULDERS,
    EQUIPMENTSLOT_TORSO,
    EQUIPMENTSLOT_WAIST,
    EQUIPMENTSLOT_WRIST_LEFT,
    EQUIPMENTSLOT_WRIST_RIGHT,
    EQUIPMENTSLOT_WRISTS,
    EQUIPMENTSLOT_ANY
  };

  RPG_Character_EquipmentSlot_XMLTree_Type (value v);

  RPG_Character_EquipmentSlot_XMLTree_Type (const char* v);

  RPG_Character_EquipmentSlot_XMLTree_Type (const ::std::string& v);

  RPG_Character_EquipmentSlot_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_EquipmentSlot_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Character_EquipmentSlot_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Character_EquipmentSlot_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Character_EquipmentSlot_XMLTree_Type (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Character_EquipmentSlot_XMLTree_Type (const RPG_Character_EquipmentSlot_XMLTree_Type& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  virtual RPG_Character_EquipmentSlot_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_EquipmentSlot_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_literals_[16];
  static const value _xsd_RPG_Character_EquipmentSlot_XMLTree_Type_indexes_[16];
};

class RPG_Character_OffHand_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    OFFHAND_NONE,
    OFFHAND_LEFT,
    OFFHAND_RIGHT
  };

  RPG_Character_OffHand_XMLTree_Type (value v);

  RPG_Character_OffHand_XMLTree_Type (const char* v);

  RPG_Character_OffHand_XMLTree_Type (const ::std::string& v);

  RPG_Character_OffHand_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Character_OffHand_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_OffHand_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_OffHand_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_OffHand_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Character_OffHand_XMLTree_Type (const RPG_Character_OffHand_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Character_OffHand_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Character_OffHand_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Character_OffHand_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Character_OffHand_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Character_OffHand_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Character_OffHand_XMLTree_Type_indexes_[3];
};

#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, RPG_Character_Gender_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Gender_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_Race_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Race_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_MetaClass_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_MetaClass_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_ClassXML_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_Ability_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Ability_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Abilities_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Attributes_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_SkillValue_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Skills_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_CheckTypeUnion_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Check_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_Feat_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Feat_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Feats_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_AlignmentCivic_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_AlignmentCivic_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_AlignmentEthic_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_AlignmentEthic_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_Alignment_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_EquipmentSlot_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_EquipmentSlot_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Character_OffHand_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Character_OffHand_XMLTree_Type&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Gender_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_Gender_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_Gender_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Race_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_Race_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_Race_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_MetaClass_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_MetaClass_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_MetaClass_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_ClassXML_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Ability_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_Ability_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_Ability_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Abilities_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Attributes_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_SkillValue_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Skills_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Check_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Feat_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_Feat_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_Feat_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Feats_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_AlignmentCivic_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_AlignmentCivic_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_AlignmentCivic_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_AlignmentEthic_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_AlignmentEthic_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_AlignmentEthic_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_Alignment_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_EquipmentSlot_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_EquipmentSlot_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_EquipmentSlot_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Character_OffHand_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Character_OffHand_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Character_OffHand_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Gender_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Race_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_MetaClass_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_ClassXML_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Ability_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Abilities_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Attributes_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_SkillValue_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Skills_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_CheckTypeUnion_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Check_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Feat_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Feats_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_AlignmentCivic_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_AlignmentEthic_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_Alignment_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_EquipmentSlot_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Character_OffHand_XMLTree_Type&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___RPG_CHARACTER_XML_TREE_H
