// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_character_XML_types.h"

// RPG_Character_MonsterType_Type_pskel
//

void RPG_Character_MonsterType_Type_pskel::
metaType_parser (::RPG_Character_MonsterMetaType_Type_pskel& p)
{
  this->metaType_parser_ = &p;
}

void RPG_Character_MonsterType_Type_pskel::
subType_parser (::RPG_Character_MonsterSubType_Type_pskel& p)
{
  this->subType_parser_ = &p;
}

void RPG_Character_MonsterType_Type_pskel::
parsers (::RPG_Character_MonsterMetaType_Type_pskel& metaType,
         ::RPG_Character_MonsterSubType_Type_pskel& subType)
{
  this->metaType_parser_ = &metaType;
  this->subType_parser_ = &subType;
}

RPG_Character_MonsterType_Type_pskel::
RPG_Character_MonsterType_Type_pskel ()
: metaType_parser_ (0),
  subType_parser_ (0)
{
}

// RPG_Character_MonsterArmorClass_Type_pskel
//

void RPG_Character_MonsterArmorClass_Type_pskel::
normal_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->normal_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
touch_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->touch_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
flatFooted_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->flatFooted_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& normal,
         ::xml_schema::unsigned_int_pskel& touch,
         ::xml_schema::unsigned_int_pskel& flatFooted)
{
  this->normal_parser_ = &normal;
  this->touch_parser_ = &touch;
  this->flatFooted_parser_ = &flatFooted;
}

RPG_Character_MonsterArmorClass_Type_pskel::
RPG_Character_MonsterArmorClass_Type_pskel ()
: normal_parser_ (0),
  touch_parser_ (0),
  flatFooted_parser_ (0)
{
}

// RPG_Character_MonsterAttackAction_Type_pskel
//

void RPG_Character_MonsterAttackAction_Type_pskel::
monsterWeapon_parser (::RPG_Character_MonsterWeapon_Type_pskel& p)
{
  this->monsterWeapon_parser_ = &p;
}

void RPG_Character_MonsterAttackAction_Type_pskel::
attackBonus_parser (::xml_schema::integer_pskel& p)
{
  this->attackBonus_parser_ = &p;
}

void RPG_Character_MonsterAttackAction_Type_pskel::
attackForm_parser (::RPG_Character_MonsterAttackForm_Type_pskel& p)
{
  this->attackForm_parser_ = &p;
}

void RPG_Character_MonsterAttackAction_Type_pskel::
damage_parser (::RPG_Chance_DiceRoll_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Character_MonsterAttackAction_Type_pskel::
numAttacksPerRound_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->numAttacksPerRound_parser_ = &p;
}

void RPG_Character_MonsterAttackAction_Type_pskel::
parsers (::RPG_Character_MonsterWeapon_Type_pskel& monsterWeapon,
         ::xml_schema::integer_pskel& attackBonus,
         ::RPG_Character_MonsterAttackForm_Type_pskel& attackForm,
         ::RPG_Chance_DiceRoll_Type_pskel& damage,
         ::xml_schema::unsigned_int_pskel& numAttacksPerRound)
{
  this->monsterWeapon_parser_ = &monsterWeapon;
  this->attackBonus_parser_ = &attackBonus;
  this->attackForm_parser_ = &attackForm;
  this->damage_parser_ = &damage;
  this->numAttacksPerRound_parser_ = &numAttacksPerRound;
}

RPG_Character_MonsterAttackAction_Type_pskel::
RPG_Character_MonsterAttackAction_Type_pskel ()
: monsterWeapon_parser_ (0),
  attackBonus_parser_ (0),
  attackForm_parser_ (0),
  damage_parser_ (0),
  numAttacksPerRound_parser_ (0)
{
}

// RPG_Character_MonsterAttack_Type_pskel
//

void RPG_Character_MonsterAttack_Type_pskel::
baseAttackBonus_parser (::xml_schema::integer_pskel& p)
{
  this->baseAttackBonus_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
grappleBonus_parser (::xml_schema::integer_pskel& p)
{
  this->grappleBonus_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
attackAction_parser (::RPG_Character_MonsterAttackAction_Type_pskel& p)
{
  this->attackAction_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
parsers (::xml_schema::integer_pskel& baseAttackBonus,
         ::xml_schema::integer_pskel& grappleBonus,
         ::RPG_Character_MonsterAttackAction_Type_pskel& attackAction)
{
  this->baseAttackBonus_parser_ = &baseAttackBonus;
  this->grappleBonus_parser_ = &grappleBonus;
  this->attackAction_parser_ = &attackAction;
}

RPG_Character_MonsterAttack_Type_pskel::
RPG_Character_MonsterAttack_Type_pskel ()
: baseAttackBonus_parser_ (0),
  grappleBonus_parser_ (0),
  attackAction_parser_ (0)
{
}

// RPG_Character_SavingThrowModifiers_Type_pskel
//

void RPG_Character_SavingThrowModifiers_Type_pskel::
fortitude_parser (::xml_schema::integer_pskel& p)
{
  this->fortitude_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
reflex_parser (::xml_schema::integer_pskel& p)
{
  this->reflex_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
will_parser (::xml_schema::integer_pskel& p)
{
  this->will_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
parsers (::xml_schema::integer_pskel& fortitude,
         ::xml_schema::integer_pskel& reflex,
         ::xml_schema::integer_pskel& will)
{
  this->fortitude_parser_ = &fortitude;
  this->reflex_parser_ = &reflex;
  this->will_parser_ = &will;
}

RPG_Character_SavingThrowModifiers_Type_pskel::
RPG_Character_SavingThrowModifiers_Type_pskel ()
: fortitude_parser_ (0),
  reflex_parser_ (0),
  will_parser_ (0)
{
}

// RPG_Character_Attributes_Type_pskel
//

void RPG_Character_Attributes_Type_pskel::
strength_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->strength_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
dexterity_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->dexterity_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
constitution_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->constitution_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
intelligence_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->intelligence_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
wisdom_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->wisdom_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
charisma_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->charisma_parser_ = &p;
}

void RPG_Character_Attributes_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& strength,
         ::xml_schema::unsigned_int_pskel& dexterity,
         ::xml_schema::unsigned_int_pskel& constitution,
         ::xml_schema::unsigned_int_pskel& intelligence,
         ::xml_schema::unsigned_int_pskel& wisdom,
         ::xml_schema::unsigned_int_pskel& charisma)
{
  this->strength_parser_ = &strength;
  this->dexterity_parser_ = &dexterity;
  this->constitution_parser_ = &constitution;
  this->intelligence_parser_ = &intelligence;
  this->wisdom_parser_ = &wisdom;
  this->charisma_parser_ = &charisma;
}

RPG_Character_Attributes_Type_pskel::
RPG_Character_Attributes_Type_pskel ()
: strength_parser_ (0),
  dexterity_parser_ (0),
  constitution_parser_ (0),
  intelligence_parser_ (0),
  wisdom_parser_ (0),
  charisma_parser_ (0)
{
}

// RPG_Character_SkillValue_Type_pskel
//

void RPG_Character_SkillValue_Type_pskel::
skill_parser (::RPG_Character_Skill_Type_pskel& p)
{
  this->skill_parser_ = &p;
}

void RPG_Character_SkillValue_Type_pskel::
rank_parser (::xml_schema::integer_pskel& p)
{
  this->rank_parser_ = &p;
}

void RPG_Character_SkillValue_Type_pskel::
parsers (::RPG_Character_Skill_Type_pskel& skill,
         ::xml_schema::integer_pskel& rank)
{
  this->skill_parser_ = &skill;
  this->rank_parser_ = &rank;
}

RPG_Character_SkillValue_Type_pskel::
RPG_Character_SkillValue_Type_pskel ()
: skill_parser_ (0),
  rank_parser_ (0)
{
}

// RPG_Character_Skills_Type_pskel
//

void RPG_Character_Skills_Type_pskel::
skill_parser (::RPG_Character_SkillValue_Type_pskel& p)
{
  this->skill_parser_ = &p;
}

void RPG_Character_Skills_Type_pskel::
parsers (::RPG_Character_SkillValue_Type_pskel& skill)
{
  this->skill_parser_ = &skill;
}

RPG_Character_Skills_Type_pskel::
RPG_Character_Skills_Type_pskel ()
: skill_parser_ (0)
{
}

// RPG_Character_Feats_Type_pskel
//

void RPG_Character_Feats_Type_pskel::
feat_parser (::RPG_Character_Feat_Type_pskel& p)
{
  this->feat_parser_ = &p;
}

void RPG_Character_Feats_Type_pskel::
parsers (::RPG_Character_Feat_Type_pskel& feat)
{
  this->feat_parser_ = &feat;
}

RPG_Character_Feats_Type_pskel::
RPG_Character_Feats_Type_pskel ()
: feat_parser_ (0)
{
}

// RPG_Character_Alignment_Type_pskel
//

void RPG_Character_Alignment_Type_pskel::
civic_parser (::RPG_Character_AlignmentCivic_Type_pskel& p)
{
  this->civic_parser_ = &p;
}

void RPG_Character_Alignment_Type_pskel::
ethic_parser (::RPG_Character_AlignmentEthic_Type_pskel& p)
{
  this->ethic_parser_ = &p;
}

void RPG_Character_Alignment_Type_pskel::
parsers (::RPG_Character_AlignmentCivic_Type_pskel& civic,
         ::RPG_Character_AlignmentEthic_Type_pskel& ethic)
{
  this->civic_parser_ = &civic;
  this->ethic_parser_ = &ethic;
}

RPG_Character_Alignment_Type_pskel::
RPG_Character_Alignment_Type_pskel ()
: civic_parser_ (0),
  ethic_parser_ (0)
{
}

// RPG_Character_MonsterAdvancementStep_Type_pskel
//

void RPG_Character_MonsterAdvancementStep_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
range_parser (::RPG_Chance_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
parsers (::RPG_Character_Size_Type_pskel& size,
         ::RPG_Chance_ValueRange_Type_pskel& range)
{
  this->size_parser_ = &size;
  this->range_parser_ = &range;
}

RPG_Character_MonsterAdvancementStep_Type_pskel::
RPG_Character_MonsterAdvancementStep_Type_pskel ()
: size_parser_ (0),
  range_parser_ (0)
{
}

// RPG_Character_MonsterAdvancement_Type_pskel
//

void RPG_Character_MonsterAdvancement_Type_pskel::
step_parser (::RPG_Character_MonsterAdvancementStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Character_MonsterAdvancement_Type_pskel::
parsers (::RPG_Character_MonsterAdvancementStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Character_MonsterAdvancement_Type_pskel::
RPG_Character_MonsterAdvancement_Type_pskel ()
: step_parser_ (0)
{
}

// RPG_Character_MonsterProperties_Type_pskel
//

void RPG_Character_MonsterProperties_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
type_parser (::RPG_Character_MonsterType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
hitDice_parser (::RPG_Chance_DiceRoll_Type_pskel& p)
{
  this->hitDice_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
initiative_parser (::xml_schema::integer_pskel& p)
{
  this->initiative_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
speed_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->speed_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
armorClass_parser (::RPG_Character_MonsterArmorClass_Type_pskel& p)
{
  this->armorClass_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
attack_parser (::RPG_Character_MonsterAttack_Type_pskel& p)
{
  this->attack_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
space_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->space_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
reach_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->reach_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
saves_parser (::RPG_Character_SavingThrowModifiers_Type_pskel& p)
{
  this->saves_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
attributes_parser (::RPG_Character_Attributes_Type_pskel& p)
{
  this->attributes_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
skills_parser (::RPG_Character_Skills_Type_pskel& p)
{
  this->skills_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
feats_parser (::RPG_Character_Feats_Type_pskel& p)
{
  this->feats_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
environment_parser (::RPG_Character_Environment_Type_pskel& p)
{
  this->environment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
organization_parser (::RPG_Character_Organization_Type_pskel& p)
{
  this->organization_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
challengeRating_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->challengeRating_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
treasureModifier_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->treasureModifier_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
alignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->alignment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
advancement_parser (::RPG_Character_MonsterAdvancement_Type_pskel& p)
{
  this->advancement_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
levelAdjustment_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->levelAdjustment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Character_Size_Type_pskel& size,
         ::RPG_Character_MonsterType_Type_pskel& type,
         ::RPG_Chance_DiceRoll_Type_pskel& hitDice,
         ::xml_schema::integer_pskel& initiative,
         ::xml_schema::unsigned_int_pskel& speed,
         ::RPG_Character_MonsterArmorClass_Type_pskel& armorClass,
         ::RPG_Character_MonsterAttack_Type_pskel& attack,
         ::xml_schema::unsigned_int_pskel& space,
         ::xml_schema::unsigned_int_pskel& reach,
         ::RPG_Character_SavingThrowModifiers_Type_pskel& saves,
         ::RPG_Character_Attributes_Type_pskel& attributes,
         ::RPG_Character_Skills_Type_pskel& skills,
         ::RPG_Character_Feats_Type_pskel& feats,
         ::RPG_Character_Environment_Type_pskel& environment,
         ::RPG_Character_Organization_Type_pskel& organization,
         ::xml_schema::unsigned_int_pskel& challengeRating,
         ::xml_schema::unsigned_int_pskel& treasureModifier,
         ::RPG_Character_Alignment_Type_pskel& alignment,
         ::RPG_Character_MonsterAdvancement_Type_pskel& advancement,
         ::xml_schema::unsigned_int_pskel& levelAdjustment)
{
  this->name_parser_ = &name;
  this->size_parser_ = &size;
  this->type_parser_ = &type;
  this->hitDice_parser_ = &hitDice;
  this->initiative_parser_ = &initiative;
  this->speed_parser_ = &speed;
  this->armorClass_parser_ = &armorClass;
  this->attack_parser_ = &attack;
  this->space_parser_ = &space;
  this->reach_parser_ = &reach;
  this->saves_parser_ = &saves;
  this->attributes_parser_ = &attributes;
  this->skills_parser_ = &skills;
  this->feats_parser_ = &feats;
  this->environment_parser_ = &environment;
  this->organization_parser_ = &organization;
  this->challengeRating_parser_ = &challengeRating;
  this->treasureModifier_parser_ = &treasureModifier;
  this->alignment_parser_ = &alignment;
  this->advancement_parser_ = &advancement;
  this->levelAdjustment_parser_ = &levelAdjustment;
}

RPG_Character_MonsterProperties_Type_pskel::
RPG_Character_MonsterProperties_Type_pskel ()
: name_parser_ (0),
  size_parser_ (0),
  type_parser_ (0),
  hitDice_parser_ (0),
  initiative_parser_ (0),
  speed_parser_ (0),
  armorClass_parser_ (0),
  attack_parser_ (0),
  space_parser_ (0),
  reach_parser_ (0),
  saves_parser_ (0),
  attributes_parser_ (0),
  skills_parser_ (0),
  feats_parser_ (0),
  environment_parser_ (0),
  organization_parser_ (0),
  challengeRating_parser_ (0),
  treasureModifier_parser_ (0),
  alignment_parser_ (0),
  advancement_parser_ (0),
  levelAdjustment_parser_ (0)
{
}

// RPG_Character_MonsterDictionary_Type_pskel
//

void RPG_Character_MonsterDictionary_Type_pskel::
monster_parser (::RPG_Character_MonsterProperties_Type_pskel& p)
{
  this->monster_parser_ = &p;
}

void RPG_Character_MonsterDictionary_Type_pskel::
parsers (::RPG_Character_MonsterProperties_Type_pskel& monster)
{
  this->monster_parser_ = &monster;
}

RPG_Character_MonsterDictionary_Type_pskel::
RPG_Character_MonsterDictionary_Type_pskel ()
: monster_parser_ (0)
{
}

// RPG_Character_Dictionary_Type_pskel
//

void RPG_Character_Dictionary_Type_pskel::
RPG_Character_MonsterDictionary_parser (::RPG_Character_MonsterDictionary_Type_pskel& p)
{
  this->RPG_Character_MonsterDictionary_parser_ = &p;
}

void RPG_Character_Dictionary_Type_pskel::
parsers (::RPG_Character_MonsterDictionary_Type_pskel& RPG_Character_MonsterDictionary)
{
  this->RPG_Character_MonsterDictionary_parser_ = &RPG_Character_MonsterDictionary;
}

RPG_Character_Dictionary_Type_pskel::
RPG_Character_Dictionary_Type_pskel ()
: RPG_Character_MonsterDictionary_parser_ (0)
{
}

// RPG_Character_MonsterType_Type_pskel
//

void RPG_Character_MonsterType_Type_pskel::
metaType (const RPG_Character_MonsterMetaType&)
{
}

void RPG_Character_MonsterType_Type_pskel::
subType (const RPG_Character_MonsterSubType&)
{
}

bool RPG_Character_MonsterType_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "metaType" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->metaType_parser_;

    if (this->metaType_parser_)
      this->metaType_parser_->pre ();

    return true;
  }

  if (n == "subType" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->subType_parser_;

    if (this->subType_parser_)
      this->subType_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterType_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "metaType" && ns.empty ())
  {
    if (this->metaType_parser_)
      this->metaType (this->metaType_parser_->post_RPG_Character_MonsterMetaType_Type ());

    return true;
  }

  if (n == "subType" && ns.empty ())
  {
    if (this->subType_parser_)
      this->subType (this->subType_parser_->post_RPG_Character_MonsterSubType_Type ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterArmorClass_Type_pskel
//

void RPG_Character_MonsterArmorClass_Type_pskel::
normal (unsigned int)
{
}

void RPG_Character_MonsterArmorClass_Type_pskel::
touch (unsigned int)
{
}

void RPG_Character_MonsterArmorClass_Type_pskel::
flatFooted (unsigned int)
{
}

bool RPG_Character_MonsterArmorClass_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "normal" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->normal_parser_;

    if (this->normal_parser_)
      this->normal_parser_->pre ();

    return true;
  }

  if (n == "touch" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->touch_parser_;

    if (this->touch_parser_)
      this->touch_parser_->pre ();

    return true;
  }

  if (n == "flatFooted" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->flatFooted_parser_;

    if (this->flatFooted_parser_)
      this->flatFooted_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterArmorClass_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "normal" && ns.empty ())
  {
    if (this->normal_parser_)
      this->normal (this->normal_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "touch" && ns.empty ())
  {
    if (this->touch_parser_)
      this->touch (this->touch_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "flatFooted" && ns.empty ())
  {
    if (this->flatFooted_parser_)
      this->flatFooted (this->flatFooted_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterAttackAction_Type_pskel
//

void RPG_Character_MonsterAttackAction_Type_pskel::
monsterWeapon (const RPG_Character_MonsterWeapon&)
{
}

void RPG_Character_MonsterAttackAction_Type_pskel::
attackBonus (long long)
{
}

void RPG_Character_MonsterAttackAction_Type_pskel::
attackForm (const RPG_Character_MonsterAttackForm&)
{
}

void RPG_Character_MonsterAttackAction_Type_pskel::
damage (const RPG_Chance_DiceRoll&)
{
}

void RPG_Character_MonsterAttackAction_Type_pskel::
numAttacksPerRound (unsigned int)
{
}

bool RPG_Character_MonsterAttackAction_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "monsterWeapon" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->monsterWeapon_parser_;

    if (this->monsterWeapon_parser_)
      this->monsterWeapon_parser_->pre ();

    return true;
  }

  if (n == "attackBonus" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackBonus_parser_;

    if (this->attackBonus_parser_)
      this->attackBonus_parser_->pre ();

    return true;
  }

  if (n == "attackForm" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackForm_parser_;

    if (this->attackForm_parser_)
      this->attackForm_parser_->pre ();

    return true;
  }

  if (n == "damage" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

    if (this->damage_parser_)
      this->damage_parser_->pre ();

    return true;
  }

  if (n == "numAttacksPerRound" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->numAttacksPerRound_parser_;

    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterAttackAction_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "monsterWeapon" && ns.empty ())
  {
    if (this->monsterWeapon_parser_)
      this->monsterWeapon (this->monsterWeapon_parser_->post_RPG_Character_MonsterWeapon_Type ());

    return true;
  }

  if (n == "attackBonus" && ns.empty ())
  {
    if (this->attackBonus_parser_)
      this->attackBonus (this->attackBonus_parser_->post_integer ());

    return true;
  }

  if (n == "attackForm" && ns.empty ())
  {
    if (this->attackForm_parser_)
      this->attackForm (this->attackForm_parser_->post_RPG_Character_MonsterAttackForm_Type ());

    return true;
  }

  if (n == "damage" && ns.empty ())
  {
    if (this->damage_parser_)
      this->damage (this->damage_parser_->post_RPG_Chance_DiceRoll_Type ());

    return true;
  }

  if (n == "numAttacksPerRound" && ns.empty ())
  {
    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound (this->numAttacksPerRound_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterAttack_Type_pskel
//

void RPG_Character_MonsterAttack_Type_pskel::
baseAttackBonus (long long)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
grappleBonus (long long)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
attackAction (const RPG_Character_MonsterAttackAction&)
{
}

bool RPG_Character_MonsterAttack_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "baseAttackBonus" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->baseAttackBonus_parser_;

    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus_parser_->pre ();

    return true;
  }

  if (n == "grappleBonus" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->grappleBonus_parser_;

    if (this->grappleBonus_parser_)
      this->grappleBonus_parser_->pre ();

    return true;
  }

  if (n == "attackAction" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackAction_parser_;

    if (this->attackAction_parser_)
      this->attackAction_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterAttack_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "baseAttackBonus" && ns.empty ())
  {
    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus (this->baseAttackBonus_parser_->post_integer ());

    return true;
  }

  if (n == "grappleBonus" && ns.empty ())
  {
    if (this->grappleBonus_parser_)
      this->grappleBonus (this->grappleBonus_parser_->post_integer ());

    return true;
  }

  if (n == "attackAction" && ns.empty ())
  {
    if (this->attackAction_parser_)
      this->attackAction (this->attackAction_parser_->post_RPG_Character_MonsterAttackAction_Type ());

    return true;
  }

  return false;
}

// RPG_Character_SavingThrowModifiers_Type_pskel
//

void RPG_Character_SavingThrowModifiers_Type_pskel::
fortitude (long long)
{
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
reflex (long long)
{
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
will (long long)
{
}

bool RPG_Character_SavingThrowModifiers_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "fortitude" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fortitude_parser_;

    if (this->fortitude_parser_)
      this->fortitude_parser_->pre ();

    return true;
  }

  if (n == "reflex" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reflex_parser_;

    if (this->reflex_parser_)
      this->reflex_parser_->pre ();

    return true;
  }

  if (n == "will" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->will_parser_;

    if (this->will_parser_)
      this->will_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_SavingThrowModifiers_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "fortitude" && ns.empty ())
  {
    if (this->fortitude_parser_)
      this->fortitude (this->fortitude_parser_->post_integer ());

    return true;
  }

  if (n == "reflex" && ns.empty ())
  {
    if (this->reflex_parser_)
      this->reflex (this->reflex_parser_->post_integer ());

    return true;
  }

  if (n == "will" && ns.empty ())
  {
    if (this->will_parser_)
      this->will (this->will_parser_->post_integer ());

    return true;
  }

  return false;
}

// RPG_Character_Attributes_Type_pskel
//

void RPG_Character_Attributes_Type_pskel::
strength (unsigned int)
{
}

void RPG_Character_Attributes_Type_pskel::
dexterity (unsigned int)
{
}

void RPG_Character_Attributes_Type_pskel::
constitution (unsigned int)
{
}

void RPG_Character_Attributes_Type_pskel::
intelligence (unsigned int)
{
}

void RPG_Character_Attributes_Type_pskel::
wisdom (unsigned int)
{
}

void RPG_Character_Attributes_Type_pskel::
charisma (unsigned int)
{
}

bool RPG_Character_Attributes_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "strength" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->strength_parser_;

    if (this->strength_parser_)
      this->strength_parser_->pre ();

    return true;
  }

  if (n == "dexterity" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->dexterity_parser_;

    if (this->dexterity_parser_)
      this->dexterity_parser_->pre ();

    return true;
  }

  if (n == "constitution" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->constitution_parser_;

    if (this->constitution_parser_)
      this->constitution_parser_->pre ();

    return true;
  }

  if (n == "intelligence" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->intelligence_parser_;

    if (this->intelligence_parser_)
      this->intelligence_parser_->pre ();

    return true;
  }

  if (n == "wisdom" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->wisdom_parser_;

    if (this->wisdom_parser_)
      this->wisdom_parser_->pre ();

    return true;
  }

  if (n == "charisma" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->charisma_parser_;

    if (this->charisma_parser_)
      this->charisma_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_Attributes_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "strength" && ns.empty ())
  {
    if (this->strength_parser_)
      this->strength (this->strength_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "dexterity" && ns.empty ())
  {
    if (this->dexterity_parser_)
      this->dexterity (this->dexterity_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "constitution" && ns.empty ())
  {
    if (this->constitution_parser_)
      this->constitution (this->constitution_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "intelligence" && ns.empty ())
  {
    if (this->intelligence_parser_)
      this->intelligence (this->intelligence_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "wisdom" && ns.empty ())
  {
    if (this->wisdom_parser_)
      this->wisdom (this->wisdom_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "charisma" && ns.empty ())
  {
    if (this->charisma_parser_)
      this->charisma (this->charisma_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

// RPG_Character_SkillValue_Type_pskel
//

void RPG_Character_SkillValue_Type_pskel::
skill (const RPG_Character_Skill&)
{
}

void RPG_Character_SkillValue_Type_pskel::
rank (long long)
{
}

bool RPG_Character_SkillValue_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "skill" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->skill_parser_;

    if (this->skill_parser_)
      this->skill_parser_->pre ();

    return true;
  }

  if (n == "rank" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->rank_parser_;

    if (this->rank_parser_)
      this->rank_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_SkillValue_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "skill" && ns.empty ())
  {
    if (this->skill_parser_)
      this->skill (this->skill_parser_->post_RPG_Character_Skill_Type ());

    return true;
  }

  if (n == "rank" && ns.empty ())
  {
    if (this->rank_parser_)
      this->rank (this->rank_parser_->post_integer ());

    return true;
  }

  return false;
}

// RPG_Character_Skills_Type_pskel
//

void RPG_Character_Skills_Type_pskel::
skill (const RPG_Character_SkillsItem_t&)
{
}

bool RPG_Character_Skills_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "skill" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->skill_parser_;

    if (this->skill_parser_)
      this->skill_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_Skills_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "skill" && ns.empty ())
  {
    if (this->skill_parser_)
      this->skill (this->skill_parser_->post_RPG_Character_SkillValue_Type ());

    return true;
  }

  return false;
}

// RPG_Character_Feats_Type_pskel
//

void RPG_Character_Feats_Type_pskel::
feat (const RPG_Character_Feat&)
{
}

bool RPG_Character_Feats_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "feat" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->feat_parser_;

    if (this->feat_parser_)
      this->feat_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_Feats_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "feat" && ns.empty ())
  {
    if (this->feat_parser_)
      this->feat (this->feat_parser_->post_RPG_Character_Feat_Type ());

    return true;
  }

  return false;
}

// RPG_Character_Alignment_Type_pskel
//

void RPG_Character_Alignment_Type_pskel::
civic (const RPG_Character_AlignmentCivic&)
{
}

void RPG_Character_Alignment_Type_pskel::
ethic (const RPG_Character_AlignmentEthic&)
{
}

bool RPG_Character_Alignment_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "civic" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->civic_parser_;

    if (this->civic_parser_)
      this->civic_parser_->pre ();

    return true;
  }

  if (n == "ethic" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->ethic_parser_;

    if (this->ethic_parser_)
      this->ethic_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_Alignment_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "civic" && ns.empty ())
  {
    if (this->civic_parser_)
      this->civic (this->civic_parser_->post_RPG_Character_AlignmentCivic_Type ());

    return true;
  }

  if (n == "ethic" && ns.empty ())
  {
    if (this->ethic_parser_)
      this->ethic (this->ethic_parser_->post_RPG_Character_AlignmentEthic_Type ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterAdvancementStep_Type_pskel
//

void RPG_Character_MonsterAdvancementStep_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
range (const RPG_Chance_ValueRange&)
{
}

bool RPG_Character_MonsterAdvancementStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "size" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "range" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterAdvancementStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "size" && ns.empty ())
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Character_Size_Type ());

    return true;
  }

  if (n == "range" && ns.empty ())
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Chance_ValueRange_Type ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterAdvancement_Type_pskel
//

void RPG_Character_MonsterAdvancement_Type_pskel::
step (const RPG_Character_MonsterAdvancementStep_t&)
{
}

bool RPG_Character_MonsterAdvancement_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "step" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

    if (this->step_parser_)
      this->step_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterAdvancement_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "step" && ns.empty ())
  {
    if (this->step_parser_)
      this->step (this->step_parser_->post_RPG_Character_MonsterAdvancementStep_Type ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterProperties_Type_pskel
//

void RPG_Character_MonsterProperties_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
type (const RPG_Character_MonsterType&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
hitDice (const RPG_Chance_DiceRoll&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
initiative (long long)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
speed (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
armorClass (const RPG_Character_MonsterArmorClass&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
attack (const RPG_Character_MonsterAttack&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
space (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
reach (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
saves (const RPG_Character_SavingThrowModifiers&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
attributes (const RPG_Character_Attributes&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
skills (const RPG_Character_Skills_t&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
feats (const RPG_Character_Feats_t&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
environment (const RPG_Character_Environment&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
organization (const RPG_Character_Organization&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
challengeRating (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
treasureModifier (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
alignment (const RPG_Character_Alignment&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
advancement (const RPG_Character_MonsterAdvancement_t&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
levelAdjustment (unsigned int)
{
}

bool RPG_Character_MonsterProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "size" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "type" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "hitDice" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->hitDice_parser_;

    if (this->hitDice_parser_)
      this->hitDice_parser_->pre ();

    return true;
  }

  if (n == "initiative" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->initiative_parser_;

    if (this->initiative_parser_)
      this->initiative_parser_->pre ();

    return true;
  }

  if (n == "speed" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->speed_parser_;

    if (this->speed_parser_)
      this->speed_parser_->pre ();

    return true;
  }

  if (n == "armorClass" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->armorClass_parser_;

    if (this->armorClass_parser_)
      this->armorClass_parser_->pre ();

    return true;
  }

  if (n == "attack" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attack_parser_;

    if (this->attack_parser_)
      this->attack_parser_->pre ();

    return true;
  }

  if (n == "space" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->space_parser_;

    if (this->space_parser_)
      this->space_parser_->pre ();

    return true;
  }

  if (n == "reach" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reach_parser_;

    if (this->reach_parser_)
      this->reach_parser_->pre ();

    return true;
  }

  if (n == "saves" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->saves_parser_;

    if (this->saves_parser_)
      this->saves_parser_->pre ();

    return true;
  }

  if (n == "attributes" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attributes_parser_;

    if (this->attributes_parser_)
      this->attributes_parser_->pre ();

    return true;
  }

  if (n == "skills" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->skills_parser_;

    if (this->skills_parser_)
      this->skills_parser_->pre ();

    return true;
  }

  if (n == "feats" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->feats_parser_;

    if (this->feats_parser_)
      this->feats_parser_->pre ();

    return true;
  }

  if (n == "environment" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->environment_parser_;

    if (this->environment_parser_)
      this->environment_parser_->pre ();

    return true;
  }

  if (n == "organization" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->organization_parser_;

    if (this->organization_parser_)
      this->organization_parser_->pre ();

    return true;
  }

  if (n == "challengeRating" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->challengeRating_parser_;

    if (this->challengeRating_parser_)
      this->challengeRating_parser_->pre ();

    return true;
  }

  if (n == "treasureModifier" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->treasureModifier_parser_;

    if (this->treasureModifier_parser_)
      this->treasureModifier_parser_->pre ();

    return true;
  }

  if (n == "alignment" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alignment_parser_;

    if (this->alignment_parser_)
      this->alignment_parser_->pre ();

    return true;
  }

  if (n == "advancement" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->advancement_parser_;

    if (this->advancement_parser_)
      this->advancement_parser_->pre ();

    return true;
  }

  if (n == "levelAdjustment" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelAdjustment_parser_;

    if (this->levelAdjustment_parser_)
      this->levelAdjustment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns.empty ())
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "size" && ns.empty ())
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Character_Size_Type ());

    return true;
  }

  if (n == "type" && ns.empty ())
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Character_MonsterType_Type ());

    return true;
  }

  if (n == "hitDice" && ns.empty ())
  {
    if (this->hitDice_parser_)
      this->hitDice (this->hitDice_parser_->post_RPG_Chance_DiceRoll_Type ());

    return true;
  }

  if (n == "initiative" && ns.empty ())
  {
    if (this->initiative_parser_)
      this->initiative (this->initiative_parser_->post_integer ());

    return true;
  }

  if (n == "speed" && ns.empty ())
  {
    if (this->speed_parser_)
      this->speed (this->speed_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "armorClass" && ns.empty ())
  {
    if (this->armorClass_parser_)
      this->armorClass (this->armorClass_parser_->post_RPG_Character_MonsterArmorClass_Type ());

    return true;
  }

  if (n == "attack" && ns.empty ())
  {
    if (this->attack_parser_)
      this->attack (this->attack_parser_->post_RPG_Character_MonsterAttack_Type ());

    return true;
  }

  if (n == "space" && ns.empty ())
  {
    if (this->space_parser_)
      this->space (this->space_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "reach" && ns.empty ())
  {
    if (this->reach_parser_)
      this->reach (this->reach_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "saves" && ns.empty ())
  {
    if (this->saves_parser_)
      this->saves (this->saves_parser_->post_RPG_Character_SavingThrowModifiers_Type ());

    return true;
  }

  if (n == "attributes" && ns.empty ())
  {
    if (this->attributes_parser_)
      this->attributes (this->attributes_parser_->post_RPG_Character_Attributes_Type ());

    return true;
  }

  if (n == "skills" && ns.empty ())
  {
    if (this->skills_parser_)
      this->skills (this->skills_parser_->post_RPG_Character_Skills_Type ());

    return true;
  }

  if (n == "feats" && ns.empty ())
  {
    if (this->feats_parser_)
      this->feats (this->feats_parser_->post_RPG_Character_Feats_Type ());

    return true;
  }

  if (n == "environment" && ns.empty ())
  {
    if (this->environment_parser_)
      this->environment (this->environment_parser_->post_RPG_Character_Environment_Type ());

    return true;
  }

  if (n == "organization" && ns.empty ())
  {
    if (this->organization_parser_)
      this->organization (this->organization_parser_->post_RPG_Character_Organization_Type ());

    return true;
  }

  if (n == "challengeRating" && ns.empty ())
  {
    if (this->challengeRating_parser_)
      this->challengeRating (this->challengeRating_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "treasureModifier" && ns.empty ())
  {
    if (this->treasureModifier_parser_)
      this->treasureModifier (this->treasureModifier_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "alignment" && ns.empty ())
  {
    if (this->alignment_parser_)
      this->alignment (this->alignment_parser_->post_RPG_Character_Alignment_Type ());

    return true;
  }

  if (n == "advancement" && ns.empty ())
  {
    if (this->advancement_parser_)
      this->advancement (this->advancement_parser_->post_RPG_Character_MonsterAdvancement_Type ());

    return true;
  }

  if (n == "levelAdjustment" && ns.empty ())
  {
    if (this->levelAdjustment_parser_)
      this->levelAdjustment (this->levelAdjustment_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

// RPG_Character_MonsterDictionary_Type_pskel
//

void RPG_Character_MonsterDictionary_Type_pskel::
monster (const RPG_Character_MonsterProperties_XML&)
{
}

void RPG_Character_MonsterDictionary_Type_pskel::
post_RPG_Character_MonsterDictionary_Type ()
{
}

bool RPG_Character_MonsterDictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "monster" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->monster_parser_;

    if (this->monster_parser_)
      this->monster_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_MonsterDictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "monster" && ns.empty ())
  {
    if (this->monster_parser_)
      this->monster (this->monster_parser_->post_RPG_Character_MonsterProperties_Type ());

    return true;
  }

  return false;
}

// RPG_Character_Dictionary_Type_pskel
//

void RPG_Character_Dictionary_Type_pskel::
RPG_Character_MonsterDictionary ()
{
}

void RPG_Character_Dictionary_Type_pskel::
post_RPG_Character_Dictionary_Type ()
{
}

bool RPG_Character_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "RPG_Character_MonsterDictionary" && ns.empty ())
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->RPG_Character_MonsterDictionary_parser_;

    if (this->RPG_Character_MonsterDictionary_parser_)
      this->RPG_Character_MonsterDictionary_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Character_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "RPG_Character_MonsterDictionary" && ns.empty ())
  {
    if (this->RPG_Character_MonsterDictionary_parser_)
    {
      this->RPG_Character_MonsterDictionary_parser_->post_RPG_Character_MonsterDictionary_Type ();
      this->RPG_Character_MonsterDictionary ();
    }

    return true;
  }

  return false;
}

// Begin epilogue.
//
//
// End epilogue.

