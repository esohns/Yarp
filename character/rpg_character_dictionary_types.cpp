// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_character_dictionary_types.h"

// RPG_Character_Dictionary_Type_pskel
//

void RPG_Character_Dictionary_Type_pskel::
RPG_Character_MonsterDictionary_parser (::RPG_Character_MonsterDictionary_Type_pskel& p)
{
  this->RPG_Character_MonsterDictionary_parser_ = &p;
}

void RPG_Character_Dictionary_Type_pskel::
parsers (::RPG_Character_MonsterDictionary_Type_pskel& RPG_Character_MonsterDictionary)
{
  this->RPG_Character_MonsterDictionary_parser_ = &RPG_Character_MonsterDictionary;
}

RPG_Character_Dictionary_Type_pskel::
RPG_Character_Dictionary_Type_pskel ()
: RPG_Character_MonsterDictionary_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterDictionary_Type_pskel
//

void RPG_Character_MonsterDictionary_Type_pskel::
monster_parser (::RPG_Character_MonsterProperties_Type_pskel& p)
{
  this->monster_parser_ = &p;
}

void RPG_Character_MonsterDictionary_Type_pskel::
parsers (::RPG_Character_MonsterProperties_Type_pskel& monster)
{
  this->monster_parser_ = &monster;
}

RPG_Character_MonsterDictionary_Type_pskel::
RPG_Character_MonsterDictionary_Type_pskel ()
: monster_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterType_Type_pskel
//

void RPG_Character_MonsterType_Type_pskel::
metaType_parser (::RPG_Character_MonsterMetaType_Type_pskel& p)
{
  this->metaType_parser_ = &p;
}

void RPG_Character_MonsterType_Type_pskel::
subType_parser (::RPG_Character_MonsterSubType_Type_pskel& p)
{
  this->subType_parser_ = &p;
}

void RPG_Character_MonsterType_Type_pskel::
parsers (::RPG_Character_MonsterMetaType_Type_pskel& metaType,
         ::RPG_Character_MonsterSubType_Type_pskel& subType)
{
  this->metaType_parser_ = &metaType;
  this->subType_parser_ = &subType;
}

RPG_Character_MonsterType_Type_pskel::
RPG_Character_MonsterType_Type_pskel ()
: metaType_parser_ (0),
  subType_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterArmorClass_Type_pskel
//

void RPG_Character_MonsterArmorClass_Type_pskel::
normal_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->normal_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
touch_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->touch_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
flatFooted_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->flatFooted_parser_ = &p;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& normal,
         ::xml_schema::unsigned_int_pskel& touch,
         ::xml_schema::unsigned_int_pskel& flatFooted)
{
  this->normal_parser_ = &normal;
  this->touch_parser_ = &touch;
  this->flatFooted_parser_ = &flatFooted;
}

RPG_Character_MonsterArmorClass_Type_pskel::
RPG_Character_MonsterArmorClass_Type_pskel ()
: normal_parser_ (0),
  touch_parser_ (0),
  flatFooted_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Chance_Roll_Type_pskel
//

void RPG_Chance_Roll_Type_pskel::
numDice_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->numDice_parser_ = &p;
}

void RPG_Chance_Roll_Type_pskel::
typeDice_parser (::RPG_Chance_DiceType_Type_pskel& p)
{
  this->typeDice_parser_ = &p;
}

void RPG_Chance_Roll_Type_pskel::
modifier_parser (::xml_schema::integer_pskel& p)
{
  this->modifier_parser_ = &p;
}

void RPG_Chance_Roll_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& numDice,
         ::RPG_Chance_DiceType_Type_pskel& typeDice,
         ::xml_schema::integer_pskel& modifier)
{
  this->numDice_parser_ = &numDice;
  this->typeDice_parser_ = &typeDice;
  this->modifier_parser_ = &modifier;
}

RPG_Chance_Roll_Type_pskel::
RPG_Chance_Roll_Type_pskel ()
: numDice_parser_ (0),
  typeDice_parser_ (0),
  modifier_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterAttack_Type_pskel
//

void RPG_Character_MonsterAttack_Type_pskel::
baseAttackBonus_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->baseAttackBonus_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
grappleBonus_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->grappleBonus_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
naturalWeapon_parser (::RPG_Character_NaturalWeapon_Type_pskel& p)
{
  this->naturalWeapon_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
attackBonus_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->attackBonus_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
attackForm_parser (::RPG_Character_MonsterAttackForm_Type_pskel& p)
{
  this->attackForm_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
damage_parser (::RPG_Chance_Roll_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
numAttacksPerRound_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->numAttacksPerRound_parser_ = &p;
}

void RPG_Character_MonsterAttack_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& baseAttackBonus,
         ::xml_schema::unsigned_int_pskel& grappleBonus,
         ::RPG_Character_NaturalWeapon_Type_pskel& naturalWeapon,
         ::xml_schema::unsigned_int_pskel& attackBonus,
         ::RPG_Character_MonsterAttackForm_Type_pskel& attackForm,
         ::RPG_Chance_Roll_Type_pskel& damage,
         ::xml_schema::unsigned_int_pskel& numAttacksPerRound)
{
  this->baseAttackBonus_parser_ = &baseAttackBonus;
  this->grappleBonus_parser_ = &grappleBonus;
  this->naturalWeapon_parser_ = &naturalWeapon;
  this->attackBonus_parser_ = &attackBonus;
  this->attackForm_parser_ = &attackForm;
  this->damage_parser_ = &damage;
  this->numAttacksPerRound_parser_ = &numAttacksPerRound;
}

RPG_Character_MonsterAttack_Type_pskel::
RPG_Character_MonsterAttack_Type_pskel ()
: baseAttackBonus_parser_ (0),
  grappleBonus_parser_ (0),
  naturalWeapon_parser_ (0),
  attackBonus_parser_ (0),
  attackForm_parser_ (0),
  damage_parser_ (0),
  numAttacksPerRound_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_SavingThrowModifiers_Type_pskel
//

void RPG_Character_SavingThrowModifiers_Type_pskel::
fortitude_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->fortitude_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
reflex_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->reflex_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
will_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->will_parser_ = &p;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& fortitude,
         ::xml_schema::unsigned_int_pskel& reflex,
         ::xml_schema::unsigned_int_pskel& will)
{
  this->fortitude_parser_ = &fortitude;
  this->reflex_parser_ = &reflex;
  this->will_parser_ = &will;
}

RPG_Character_SavingThrowModifiers_Type_pskel::
RPG_Character_SavingThrowModifiers_Type_pskel ()
: fortitude_parser_ (0),
  reflex_parser_ (0),
  will_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_Alignment_Type_pskel
//

void RPG_Character_Alignment_Type_pskel::
civic_parser (::RPG_Character_AlignmentCivic_Type_pskel& p)
{
  this->civic_parser_ = &p;
}

void RPG_Character_Alignment_Type_pskel::
ethic_parser (::RPG_Character_AlignmentEthic_Type_pskel& p)
{
  this->ethic_parser_ = &p;
}

void RPG_Character_Alignment_Type_pskel::
parsers (::RPG_Character_AlignmentCivic_Type_pskel& civic,
         ::RPG_Character_AlignmentEthic_Type_pskel& ethic)
{
  this->civic_parser_ = &civic;
  this->ethic_parser_ = &ethic;
}

RPG_Character_Alignment_Type_pskel::
RPG_Character_Alignment_Type_pskel ()
: civic_parser_ (0),
  ethic_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterAdvancementStep_Type_pskel
//

void RPG_Character_MonsterAdvancementStep_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
range_parser (::RPG_Chance_Roll_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
parsers (::RPG_Character_Size_Type_pskel& size,
         ::RPG_Chance_Roll_Type_pskel& range)
{
  this->size_parser_ = &size;
  this->range_parser_ = &range;
}

RPG_Character_MonsterAdvancementStep_Type_pskel::
RPG_Character_MonsterAdvancementStep_Type_pskel ()
: size_parser_ (0),
  range_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterAdvancement_Type_pskel
//

void RPG_Character_MonsterAdvancement_Type_pskel::
step_parser (::RPG_Character_MonsterAdvancementStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Character_MonsterAdvancement_Type_pskel::
parsers (::RPG_Character_MonsterAdvancementStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Character_MonsterAdvancement_Type_pskel::
RPG_Character_MonsterAdvancement_Type_pskel ()
: step_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_MonsterProperties_Type_pskel
//

void RPG_Character_MonsterProperties_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
type_parser (::RPG_Character_MonsterType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
hitDice_parser (::RPG_Chance_Roll_Type_pskel& p)
{
  this->hitDice_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
initiative_parser (::xml_schema::integer_pskel& p)
{
  this->initiative_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
speed_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->speed_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
armorClass_parser (::RPG_Character_MonsterArmorClass_Type_pskel& p)
{
  this->armorClass_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
attack_parser (::RPG_Character_MonsterAttack_Type_pskel& p)
{
  this->attack_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
space_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->space_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
reach_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->reach_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
saves_parser (::RPG_Character_SavingThrowModifiers_Type_pskel& p)
{
  this->saves_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
environment_parser (::RPG_Character_Environment_Type_pskel& p)
{
  this->environment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
organization_parser (::RPG_Character_Organization_Type_pskel& p)
{
  this->organization_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
challengeRating_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->challengeRating_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
treasureModifier_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->treasureModifier_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
alignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->alignment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
advancement_parser (::RPG_Character_MonsterAdvancement_Type_pskel& p)
{
  this->advancement_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
levelAdjustment_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->levelAdjustment_parser_ = &p;
}

void RPG_Character_MonsterProperties_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Character_Size_Type_pskel& size,
         ::RPG_Character_MonsterType_Type_pskel& type,
         ::RPG_Chance_Roll_Type_pskel& hitDice,
         ::xml_schema::integer_pskel& initiative,
         ::xml_schema::unsigned_int_pskel& speed,
         ::RPG_Character_MonsterArmorClass_Type_pskel& armorClass,
         ::RPG_Character_MonsterAttack_Type_pskel& attack,
         ::xml_schema::unsigned_int_pskel& space,
         ::xml_schema::unsigned_int_pskel& reach,
         ::RPG_Character_SavingThrowModifiers_Type_pskel& saves,
         ::RPG_Character_Environment_Type_pskel& environment,
         ::RPG_Character_Organization_Type_pskel& organization,
         ::xml_schema::unsigned_int_pskel& challengeRating,
         ::xml_schema::unsigned_int_pskel& treasureModifier,
         ::RPG_Character_Alignment_Type_pskel& alignment,
         ::RPG_Character_MonsterAdvancement_Type_pskel& advancement,
         ::xml_schema::unsigned_int_pskel& levelAdjustment)
{
  this->name_parser_ = &name;
  this->size_parser_ = &size;
  this->type_parser_ = &type;
  this->hitDice_parser_ = &hitDice;
  this->initiative_parser_ = &initiative;
  this->speed_parser_ = &speed;
  this->armorClass_parser_ = &armorClass;
  this->attack_parser_ = &attack;
  this->space_parser_ = &space;
  this->reach_parser_ = &reach;
  this->saves_parser_ = &saves;
  this->environment_parser_ = &environment;
  this->organization_parser_ = &organization;
  this->challengeRating_parser_ = &challengeRating;
  this->treasureModifier_parser_ = &treasureModifier;
  this->alignment_parser_ = &alignment;
  this->advancement_parser_ = &advancement;
  this->levelAdjustment_parser_ = &levelAdjustment;
}

RPG_Character_MonsterProperties_Type_pskel::
RPG_Character_MonsterProperties_Type_pskel ()
: name_parser_ (0),
  size_parser_ (0),
  type_parser_ (0),
  hitDice_parser_ (0),
  initiative_parser_ (0),
  speed_parser_ (0),
  armorClass_parser_ (0),
  attack_parser_ (0),
  space_parser_ (0),
  reach_parser_ (0),
  saves_parser_ (0),
  environment_parser_ (0),
  organization_parser_ (0),
  challengeRating_parser_ (0),
  treasureModifier_parser_ (0),
  alignment_parser_ (0),
  advancement_parser_ (0),
  levelAdjustment_parser_ (0),
  v_state_stack_ (sizeof (v_state_), &v_state_first_)
{
}

// RPG_Character_Dictionary_Type_pskel
//

void RPG_Character_Dictionary_Type_pskel::
RPG_Character_MonsterDictionary ()
{
}

void RPG_Character_Dictionary_Type_pskel::
post_RPG_Character_Dictionary_Type ()
{
}

// RPG_Character_MonsterDictionary_Type_pskel
//

void RPG_Character_MonsterDictionary_Type_pskel::
monster (const RPG_Character_MonsterProperties_XML&)
{
}

void RPG_Character_MonsterDictionary_Type_pskel::
post_RPG_Character_MonsterDictionary_Type ()
{
}

// RPG_Character_MonsterType_Type_pskel
//

void RPG_Character_MonsterType_Type_pskel::
metaType (const RPG_Character_MonsterMetaType&)
{
}

void RPG_Character_MonsterType_Type_pskel::
subType (const RPG_Character_MonsterSubType&)
{
}

// RPG_Character_MonsterArmorClass_Type_pskel
//

void RPG_Character_MonsterArmorClass_Type_pskel::
normal (unsigned int)
{
}

void RPG_Character_MonsterArmorClass_Type_pskel::
touch (unsigned int)
{
}

void RPG_Character_MonsterArmorClass_Type_pskel::
flatFooted (unsigned int)
{
}

// RPG_Chance_Roll_Type_pskel
//

void RPG_Chance_Roll_Type_pskel::
numDice (unsigned int)
{
}

void RPG_Chance_Roll_Type_pskel::
typeDice (const RPG_Chance_DiceType&)
{
}

void RPG_Chance_Roll_Type_pskel::
modifier (long long)
{
}

// RPG_Character_MonsterAttack_Type_pskel
//

void RPG_Character_MonsterAttack_Type_pskel::
baseAttackBonus (unsigned int)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
grappleBonus (unsigned int)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
naturalWeapon (const RPG_Character_NaturalWeapon&)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
attackBonus (unsigned int)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
attackForm (const RPG_Character_MonsterAttackForm&)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
damage (const RPG_Chance_Roll&)
{
}

void RPG_Character_MonsterAttack_Type_pskel::
numAttacksPerRound (unsigned int)
{
}

// RPG_Character_SavingThrowModifiers_Type_pskel
//

void RPG_Character_SavingThrowModifiers_Type_pskel::
fortitude (unsigned int)
{
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
reflex (unsigned int)
{
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
will (unsigned int)
{
}

// RPG_Character_Alignment_Type_pskel
//

void RPG_Character_Alignment_Type_pskel::
civic (const RPG_Character_AlignmentCivic&)
{
}

void RPG_Character_Alignment_Type_pskel::
ethic (const RPG_Character_AlignmentEthic&)
{
}

// RPG_Character_MonsterAdvancementStep_Type_pskel
//

void RPG_Character_MonsterAdvancementStep_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
range (const RPG_Chance_Roll&)
{
}

// RPG_Character_MonsterAdvancement_Type_pskel
//

void RPG_Character_MonsterAdvancement_Type_pskel::
step (const RPG_Character_MonsterAdvancementStep_t&)
{
}

// RPG_Character_MonsterProperties_Type_pskel
//

void RPG_Character_MonsterProperties_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
type (const RPG_Character_MonsterType&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
hitDice (const RPG_Chance_Roll&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
initiative (long long)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
speed (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
armorClass (const RPG_Character_MonsterArmorClass&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
attack (const RPG_Character_MonsterAttack&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
space (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
reach (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
saves (const RPG_Character_SavingThrowModifiers&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
environment (const RPG_Character_Environment&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
organization (const RPG_Character_Organization&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
challengeRating (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
treasureModifier (unsigned int)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
alignment (const RPG_Character_Alignment&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
advancement (const RPG_Character_MonsterAdvancement_t&)
{
}

void RPG_Character_MonsterProperties_Type_pskel::
levelAdjustment (unsigned int)
{
}

#include <cassert>

// Element validation and dispatch functions for RPG_Character_Dictionary_Type_pskel.
//
bool RPG_Character_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "RPG_Character_MonsterDictionary" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_Dictionary_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "RPG_Character_MonsterDictionary",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_Dictionary_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_Dictionary_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "RPG_Character_MonsterDictionary");

  this->v_state_stack_.pop ();
}

void RPG_Character_Dictionary_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "RPG_Character_MonsterDictionary" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->RPG_Character_MonsterDictionary_parser_;

          if (this->RPG_Character_MonsterDictionary_parser_)
            this->RPG_Character_MonsterDictionary_parser_->pre ();
        }
        else
        {
          if (this->RPG_Character_MonsterDictionary_parser_)
          {
            this->RPG_Character_MonsterDictionary_parser_->post_RPG_Character_MonsterDictionary_Type ();
            this->RPG_Character_MonsterDictionary ();
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "RPG_Character_MonsterDictionary",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterDictionary_Type_pskel.
//
bool RPG_Character_MonsterDictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "monster" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterDictionary_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "monster",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterDictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterDictionary_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterDictionary_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "monster");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterDictionary_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "monster" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->monster_parser_;

          if (this->monster_parser_)
            this->monster_parser_->pre ();
        }
        else
        {
          if (this->monster_parser_)
          {
            const RPG_Character_MonsterProperties_XML& tmp (this->monster_parser_->post_RPG_Character_MonsterProperties_Type ());
            this->monster (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "monster",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterType_Type_pskel.
//
bool RPG_Character_MonsterType_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "metaType" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterType_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "metaType",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterType_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterType_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterType_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "metaType");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterType_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "metaType" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->metaType_parser_;

          if (this->metaType_parser_)
            this->metaType_parser_->pre ();
        }
        else
        {
          if (this->metaType_parser_)
          {
            const RPG_Character_MonsterMetaType& tmp (this->metaType_parser_->post_RPG_Character_MonsterMetaType_Type ());
            this->metaType (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "metaType",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "subType" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->subType_parser_;

          if (this->subType_parser_)
            this->subType_parser_->pre ();
        }
        else
        {
          if (this->subType_parser_)
          {
            const RPG_Character_MonsterSubType& tmp (this->subType_parser_->post_RPG_Character_MonsterSubType_Type ());
            this->subType (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "subType",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterArmorClass_Type_pskel.
//
bool RPG_Character_MonsterArmorClass_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "normal" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterArmorClass_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "normal",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterArmorClass_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterArmorClass_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "normal");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterArmorClass_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "normal" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->normal_parser_;

          if (this->normal_parser_)
            this->normal_parser_->pre ();
        }
        else
        {
          if (this->normal_parser_)
          {
            unsigned int tmp (this->normal_parser_->post_unsigned_int ());
            this->normal (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "normal",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "touch" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->touch_parser_;

          if (this->touch_parser_)
            this->touch_parser_->pre ();
        }
        else
        {
          if (this->touch_parser_)
          {
            unsigned int tmp (this->touch_parser_->post_unsigned_int ());
            this->touch (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "touch",
            ns, n);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "flatFooted" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->flatFooted_parser_;

          if (this->flatFooted_parser_)
            this->flatFooted_parser_->pre ();
        }
        else
        {
          if (this->flatFooted_parser_)
          {
            unsigned int tmp (this->flatFooted_parser_->post_unsigned_int ());
            this->flatFooted (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "flatFooted",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Chance_Roll_Type_pskel.
//
bool RPG_Chance_Roll_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "numDice" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Chance_Roll_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "numDice",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Chance_Roll_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Chance_Roll_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Chance_Roll_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "numDice");

  this->v_state_stack_.pop ();
}

void RPG_Chance_Roll_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "numDice" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->numDice_parser_;

          if (this->numDice_parser_)
            this->numDice_parser_->pre ();
        }
        else
        {
          if (this->numDice_parser_)
          {
            unsigned int tmp (this->numDice_parser_->post_unsigned_int ());
            this->numDice (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "numDice",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "typeDice" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->typeDice_parser_;

          if (this->typeDice_parser_)
            this->typeDice_parser_->pre ();
        }
        else
        {
          if (this->typeDice_parser_)
          {
            const RPG_Chance_DiceType& tmp (this->typeDice_parser_->post_RPG_Chance_DiceType_Type ());
            this->typeDice (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "typeDice",
            ns, n);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "modifier" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->modifier_parser_;

          if (this->modifier_parser_)
            this->modifier_parser_->pre ();
        }
        else
        {
          if (this->modifier_parser_)
          {
            long long tmp (this->modifier_parser_->post_integer ());
            this->modifier (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "modifier",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterAttack_Type_pskel.
//
bool RPG_Character_MonsterAttack_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "baseAttackBonus" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterAttack_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "baseAttackBonus",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterAttack_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterAttack_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterAttack_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "baseAttackBonus");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterAttack_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "baseAttackBonus" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->baseAttackBonus_parser_;

          if (this->baseAttackBonus_parser_)
            this->baseAttackBonus_parser_->pre ();
        }
        else
        {
          if (this->baseAttackBonus_parser_)
          {
            unsigned int tmp (this->baseAttackBonus_parser_->post_unsigned_int ());
            this->baseAttackBonus (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "baseAttackBonus",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "grappleBonus" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->grappleBonus_parser_;

          if (this->grappleBonus_parser_)
            this->grappleBonus_parser_->pre ();
        }
        else
        {
          if (this->grappleBonus_parser_)
          {
            unsigned int tmp (this->grappleBonus_parser_->post_unsigned_int ());
            this->grappleBonus (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "grappleBonus",
            ns, n);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "naturalWeapon" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->naturalWeapon_parser_;

          if (this->naturalWeapon_parser_)
            this->naturalWeapon_parser_->pre ();
        }
        else
        {
          if (this->naturalWeapon_parser_)
          {
            const RPG_Character_NaturalWeapon& tmp (this->naturalWeapon_parser_->post_RPG_Character_NaturalWeapon_Type ());
            this->naturalWeapon (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "naturalWeapon",
            ns, n);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "attackBonus" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->attackBonus_parser_;

          if (this->attackBonus_parser_)
            this->attackBonus_parser_->pre ();
        }
        else
        {
          if (this->attackBonus_parser_)
          {
            unsigned int tmp (this->attackBonus_parser_->post_unsigned_int ());
            this->attackBonus (tmp);
          }

          count = 0;
          state = 4UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "attackBonus",
            ns, n);
        count = 0;
        state = 4UL;
        // Fall through.
      }
    }
    case 4UL:
    {
      if (n == "attackForm" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->attackForm_parser_;

          if (this->attackForm_parser_)
            this->attackForm_parser_->pre ();
        }
        else
        {
          if (this->attackForm_parser_)
          {
            const RPG_Character_MonsterAttackForm& tmp (this->attackForm_parser_->post_RPG_Character_MonsterAttackForm_Type ());
            this->attackForm (tmp);
          }

          count = 0;
          state = 5UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "attackForm",
            ns, n);
        count = 0;
        state = 5UL;
        // Fall through.
      }
    }
    case 5UL:
    {
      if (n == "damage" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

          if (this->damage_parser_)
            this->damage_parser_->pre ();
        }
        else
        {
          if (this->damage_parser_)
          {
            const RPG_Chance_Roll& tmp (this->damage_parser_->post_RPG_Chance_Roll_Type ());
            this->damage (tmp);
          }

          count = 0;
          state = 6UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "damage",
            ns, n);
        count = 0;
        state = 6UL;
        // Fall through.
      }
    }
    case 6UL:
    {
      if (n == "numAttacksPerRound" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->numAttacksPerRound_parser_;

          if (this->numAttacksPerRound_parser_)
            this->numAttacksPerRound_parser_->pre ();
        }
        else
        {
          if (this->numAttacksPerRound_parser_)
          {
            unsigned int tmp (this->numAttacksPerRound_parser_->post_unsigned_int ());
            this->numAttacksPerRound (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "numAttacksPerRound",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_SavingThrowModifiers_Type_pskel.
//
bool RPG_Character_SavingThrowModifiers_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "fortitude" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_SavingThrowModifiers_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "fortitude",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_SavingThrowModifiers_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "fortitude");

  this->v_state_stack_.pop ();
}

void RPG_Character_SavingThrowModifiers_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "fortitude" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->fortitude_parser_;

          if (this->fortitude_parser_)
            this->fortitude_parser_->pre ();
        }
        else
        {
          if (this->fortitude_parser_)
          {
            unsigned int tmp (this->fortitude_parser_->post_unsigned_int ());
            this->fortitude (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "fortitude",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "reflex" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->reflex_parser_;

          if (this->reflex_parser_)
            this->reflex_parser_->pre ();
        }
        else
        {
          if (this->reflex_parser_)
          {
            unsigned int tmp (this->reflex_parser_->post_unsigned_int ());
            this->reflex (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "reflex",
            ns, n);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "will" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->will_parser_;

          if (this->will_parser_)
            this->will_parser_->pre ();
        }
        else
        {
          if (this->will_parser_)
          {
            unsigned int tmp (this->will_parser_->post_unsigned_int ());
            this->will (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "will",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_Alignment_Type_pskel.
//
bool RPG_Character_Alignment_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "civic" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_Alignment_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "civic",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_Alignment_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_Alignment_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_Alignment_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "civic");

  this->v_state_stack_.pop ();
}

void RPG_Character_Alignment_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "civic" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->civic_parser_;

          if (this->civic_parser_)
            this->civic_parser_->pre ();
        }
        else
        {
          if (this->civic_parser_)
          {
            const RPG_Character_AlignmentCivic& tmp (this->civic_parser_->post_RPG_Character_AlignmentCivic_Type ());
            this->civic (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "civic",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "ethic" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->ethic_parser_;

          if (this->ethic_parser_)
            this->ethic_parser_->pre ();
        }
        else
        {
          if (this->ethic_parser_)
          {
            const RPG_Character_AlignmentEthic& tmp (this->ethic_parser_->post_RPG_Character_AlignmentEthic_Type ());
            this->ethic (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "ethic",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterAdvancementStep_Type_pskel.
//
bool RPG_Character_MonsterAdvancementStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "size" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterAdvancementStep_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "size",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterAdvancementStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "size");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterAdvancementStep_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "size" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

          if (this->size_parser_)
            this->size_parser_->pre ();
        }
        else
        {
          if (this->size_parser_)
          {
            const RPG_Character_Size& tmp (this->size_parser_->post_RPG_Character_Size_Type ());
            this->size (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "size",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "range" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

          if (this->range_parser_)
            this->range_parser_->pre ();
        }
        else
        {
          if (this->range_parser_)
          {
            const RPG_Chance_Roll& tmp (this->range_parser_->post_RPG_Chance_Roll_Type ());
            this->range (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "range",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterAdvancement_Type_pskel.
//
bool RPG_Character_MonsterAdvancement_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "step" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterAdvancement_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "step",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterAdvancement_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterAdvancement_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterAdvancement_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "step");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterAdvancement_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "step" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

          if (this->step_parser_)
            this->step_parser_->pre ();
        }
        else
        {
          if (this->step_parser_)
          {
            const RPG_Character_MonsterAdvancementStep_t& tmp (this->step_parser_->post_RPG_Character_MonsterAdvancementStep_Type ());
            this->step (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "step",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Element validation and dispatch functions for RPG_Character_MonsterProperties_Type_pskel.
//
bool RPG_Character_MonsterProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  if (vd->func == 0 && vd->state == 0)
  {
    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;
    else
      vd->state = 1;
  }

  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

    vd = vs.data + (vs.size - 1);

    if (vd->state == ~0UL)
      vd = vs.data + (--vs.size - 1);
    else
      break;
  }

  if (vd->func == 0)
  {
    if (vd->state != ~0UL)
    {
      unsigned long s = ~0UL;

      if (n == "name" && ns.empty ())
        s = 0UL;

      if (s != ~0UL)
      {
        vd->count++;
        vd->state = ~0UL;

        vd = vs.data + vs.size++;
        vd->func = &RPG_Character_MonsterProperties_Type_pskel::sequence_0;
        vd->state = s;
        vd->count = 0;

        this->sequence_0 (vd->state, vd->count, ns, n, t, true);
      }
      else
      {
        if (vd->count < 1UL)
          this->_expected_element (
            "", "name",
            ns, n);
        return false;
      }
    }
    else
      return false;
  }

  return true;
}

bool RPG_Character_MonsterProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size - 1];

  if (vd.func == 0 && vd.state == 0)
  {
    if (!::xml_schema::complex_content::_end_element_impl (ns, n))
      assert (false);
    return true;
  }

  assert (vd.func != 0);
  (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

  if (vd.state == ~0UL)
    vs.size--;

  return true;
}

void RPG_Character_MonsterProperties_Type_pskel::
_pre_e_validate ()
{
  this->v_state_stack_.push ();
  static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_& vd = vs.data[vs.size++];

  vd.func = 0;
  vd.state = 0;
  vd.count = 0;
}

void RPG_Character_MonsterProperties_Type_pskel::
_post_e_validate ()
{
  v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
  v_state_descr_* vd = vs.data + (vs.size - 1);

  ::xml_schema::ro_string empty;
  while (vd->func != 0)
  {
    (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
    assert (vd->state == ~0UL);
    vd = vs.data + (--vs.size - 1);
  }

  if (vd->count < 1UL)
    this->_expected_element (
      "", "name");

  this->v_state_stack_.pop ();
}

void RPG_Character_MonsterProperties_Type_pskel::
sequence_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
{
  XSD_UNUSED (t);

  switch (state)
  {
    case 0UL:
    {
      if (n == "name" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

          if (this->name_parser_)
            this->name_parser_->pre ();
        }
        else
        {
          if (this->name_parser_)
          {
            const ::std::string& tmp (this->name_parser_->post_string ());
            this->name (tmp);
          }

          count = 0;
          state = 1UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "name",
            ns, n);
        count = 0;
        state = 1UL;
        // Fall through.
      }
    }
    case 1UL:
    {
      if (n == "size" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

          if (this->size_parser_)
            this->size_parser_->pre ();
        }
        else
        {
          if (this->size_parser_)
          {
            const RPG_Character_Size& tmp (this->size_parser_->post_RPG_Character_Size_Type ());
            this->size (tmp);
          }

          count = 0;
          state = 2UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "size",
            ns, n);
        count = 0;
        state = 2UL;
        // Fall through.
      }
    }
    case 2UL:
    {
      if (n == "type" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

          if (this->type_parser_)
            this->type_parser_->pre ();
        }
        else
        {
          if (this->type_parser_)
          {
            const RPG_Character_MonsterType& tmp (this->type_parser_->post_RPG_Character_MonsterType_Type ());
            this->type (tmp);
          }

          count = 0;
          state = 3UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "type",
            ns, n);
        count = 0;
        state = 3UL;
        // Fall through.
      }
    }
    case 3UL:
    {
      if (n == "hitDice" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->hitDice_parser_;

          if (this->hitDice_parser_)
            this->hitDice_parser_->pre ();
        }
        else
        {
          if (this->hitDice_parser_)
          {
            const RPG_Chance_Roll& tmp (this->hitDice_parser_->post_RPG_Chance_Roll_Type ());
            this->hitDice (tmp);
          }

          count = 0;
          state = 4UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "hitDice",
            ns, n);
        count = 0;
        state = 4UL;
        // Fall through.
      }
    }
    case 4UL:
    {
      if (n == "initiative" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->initiative_parser_;

          if (this->initiative_parser_)
            this->initiative_parser_->pre ();
        }
        else
        {
          if (this->initiative_parser_)
          {
            long long tmp (this->initiative_parser_->post_integer ());
            this->initiative (tmp);
          }

          count = 0;
          state = 5UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "initiative",
            ns, n);
        count = 0;
        state = 5UL;
        // Fall through.
      }
    }
    case 5UL:
    {
      if (n == "speed" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->speed_parser_;

          if (this->speed_parser_)
            this->speed_parser_->pre ();
        }
        else
        {
          if (this->speed_parser_)
          {
            unsigned int tmp (this->speed_parser_->post_unsigned_int ());
            this->speed (tmp);
          }

          count = 0;
          state = 6UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "speed",
            ns, n);
        count = 0;
        state = 6UL;
        // Fall through.
      }
    }
    case 6UL:
    {
      if (n == "armorClass" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->armorClass_parser_;

          if (this->armorClass_parser_)
            this->armorClass_parser_->pre ();
        }
        else
        {
          if (this->armorClass_parser_)
          {
            const RPG_Character_MonsterArmorClass& tmp (this->armorClass_parser_->post_RPG_Character_MonsterArmorClass_Type ());
            this->armorClass (tmp);
          }

          count = 0;
          state = 7UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "armorClass",
            ns, n);
        count = 0;
        state = 7UL;
        // Fall through.
      }
    }
    case 7UL:
    {
      if (n == "attack" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->attack_parser_;

          if (this->attack_parser_)
            this->attack_parser_->pre ();
        }
        else
        {
          if (this->attack_parser_)
          {
            const RPG_Character_MonsterAttack& tmp (this->attack_parser_->post_RPG_Character_MonsterAttack_Type ());
            this->attack (tmp);
          }

          count = 0;
          state = 8UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "attack",
            ns, n);
        count = 0;
        state = 8UL;
        // Fall through.
      }
    }
    case 8UL:
    {
      if (n == "space" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->space_parser_;

          if (this->space_parser_)
            this->space_parser_->pre ();
        }
        else
        {
          if (this->space_parser_)
          {
            unsigned int tmp (this->space_parser_->post_unsigned_int ());
            this->space (tmp);
          }

          count = 0;
          state = 9UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "space",
            ns, n);
        count = 0;
        state = 9UL;
        // Fall through.
      }
    }
    case 9UL:
    {
      if (n == "reach" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->reach_parser_;

          if (this->reach_parser_)
            this->reach_parser_->pre ();
        }
        else
        {
          if (this->reach_parser_)
          {
            unsigned int tmp (this->reach_parser_->post_unsigned_int ());
            this->reach (tmp);
          }

          count = 0;
          state = 10UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "reach",
            ns, n);
        count = 0;
        state = 10UL;
        // Fall through.
      }
    }
    case 10UL:
    {
      if (n == "saves" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->saves_parser_;

          if (this->saves_parser_)
            this->saves_parser_->pre ();
        }
        else
        {
          if (this->saves_parser_)
          {
            const RPG_Character_SavingThrowModifiers& tmp (this->saves_parser_->post_RPG_Character_SavingThrowModifiers_Type ());
            this->saves (tmp);
          }

          count = 0;
          state = 11UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "saves",
            ns, n);
        count = 0;
        state = 11UL;
        // Fall through.
      }
    }
    case 11UL:
    {
      if (n == "environment" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->environment_parser_;

          if (this->environment_parser_)
            this->environment_parser_->pre ();
        }
        else
        {
          if (this->environment_parser_)
          {
            const RPG_Character_Environment& tmp (this->environment_parser_->post_RPG_Character_Environment_Type ());
            this->environment (tmp);
          }

          count = 0;
          state = 12UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "environment",
            ns, n);
        count = 0;
        state = 12UL;
        // Fall through.
      }
    }
    case 12UL:
    {
      if (n == "organization" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->organization_parser_;

          if (this->organization_parser_)
            this->organization_parser_->pre ();
        }
        else
        {
          if (this->organization_parser_)
          {
            const RPG_Character_Organization& tmp (this->organization_parser_->post_RPG_Character_Organization_Type ());
            this->organization (tmp);
          }

          count++;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "organization",
            ns, n);
        count = 0;
        state = 13UL;
        // Fall through.
      }
    }
    case 13UL:
    {
      if (n == "challengeRating" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->challengeRating_parser_;

          if (this->challengeRating_parser_)
            this->challengeRating_parser_->pre ();
        }
        else
        {
          if (this->challengeRating_parser_)
          {
            unsigned int tmp (this->challengeRating_parser_->post_unsigned_int ());
            this->challengeRating (tmp);
          }

          count = 0;
          state = 14UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "challengeRating",
            ns, n);
        count = 0;
        state = 14UL;
        // Fall through.
      }
    }
    case 14UL:
    {
      if (n == "treasureModifier" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->treasureModifier_parser_;

          if (this->treasureModifier_parser_)
            this->treasureModifier_parser_->pre ();
        }
        else
        {
          if (this->treasureModifier_parser_)
          {
            unsigned int tmp (this->treasureModifier_parser_->post_unsigned_int ());
            this->treasureModifier (tmp);
          }

          count = 0;
          state = 15UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "treasureModifier",
            ns, n);
        count = 0;
        state = 15UL;
        // Fall through.
      }
    }
    case 15UL:
    {
      if (n == "alignment" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->alignment_parser_;

          if (this->alignment_parser_)
            this->alignment_parser_->pre ();
        }
        else
        {
          if (this->alignment_parser_)
          {
            const RPG_Character_Alignment& tmp (this->alignment_parser_->post_RPG_Character_Alignment_Type ());
            this->alignment (tmp);
          }

          count = 0;
          state = 16UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "alignment",
            ns, n);
        count = 0;
        state = 16UL;
        // Fall through.
      }
    }
    case 16UL:
    {
      if (n == "advancement" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->advancement_parser_;

          if (this->advancement_parser_)
            this->advancement_parser_->pre ();
        }
        else
        {
          if (this->advancement_parser_)
          {
            const RPG_Character_MonsterAdvancement_t& tmp (this->advancement_parser_->post_RPG_Character_MonsterAdvancement_Type ());
            this->advancement (tmp);
          }

          count = 0;
          state = 17UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "advancement",
            ns, n);
        count = 0;
        state = 17UL;
        // Fall through.
      }
    }
    case 17UL:
    {
      if (n == "levelAdjustment" && ns.empty ())
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->levelAdjustment_parser_;

          if (this->levelAdjustment_parser_)
            this->levelAdjustment_parser_->pre ();
        }
        else
        {
          if (this->levelAdjustment_parser_)
          {
            unsigned int tmp (this->levelAdjustment_parser_->post_unsigned_int ());
            this->levelAdjustment (tmp);
          }

          count = 0;
          state = ~0UL;
        }

        break;
      }
      else
      {
        assert (start);
        if (count < 1UL)
          this->_expected_element (
            "", "levelAdjustment",
            ns, n);
        count = 0;
        state = ~0UL;
        // Fall through.
      }
    }
    case ~0UL:
      break;
  }
}

// Begin epilogue.
//
//
// End epilogue.

