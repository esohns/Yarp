// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpg_magic_XML_tree.h"

// RPG_Magic_School_XMLTree_Type
// 

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_School_XMLTree_Type_literals_[v])
{
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const RPG_Magic_School_XMLTree_Type& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_School_XMLTree_Type& RPG_Magic_School_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_School_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_SubSchool_XMLTree_Type
// 

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[v])
{
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const RPG_Magic_SubSchool_XMLTree_Type& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_SubSchool_XMLTree_Type& RPG_Magic_SubSchool_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Descriptor_XMLTree_Type
// 

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const RPG_Magic_Descriptor_XMLTree_Type& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Descriptor_XMLTree_Type& RPG_Magic_Descriptor_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Domain_XMLTree_Type
// 

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Domain_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const RPG_Magic_Domain_XMLTree_Type& v,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Domain_XMLTree_Type& RPG_Magic_Domain_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Domain_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_SpellType_XMLTree_Type
// 

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[v])
{
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const RPG_Magic_SpellType_XMLTree_Type& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_SpellType_XMLTree_Type& RPG_Magic_SpellType_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_AbilityClass_XMLTree_Type
// 

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[v])
{
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const RPG_Magic_AbilityClass_XMLTree_Type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_AbilityClass_XMLTree_Type& RPG_Magic_AbilityClass_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_AbilityType_XMLTree_Type
// 

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[v])
{
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const RPG_Magic_AbilityType_XMLTree_Type& v,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_AbilityType_XMLTree_Type& RPG_Magic_AbilityType_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_Type_XMLTree_Type
// 

const RPG_Magic_Spell_Type_XMLTree_Type::type_type& RPG_Magic_Spell_Type_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_Spell_Type_XMLTree_Type::type_type& RPG_Magic_Spell_Type_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_Spell_Type_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_Spell_Type_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_Spell_Type_XMLTree_Type::school_type& RPG_Magic_Spell_Type_XMLTree_Type::
school () const
{
  return this->school_.get ();
}

RPG_Magic_Spell_Type_XMLTree_Type::school_type& RPG_Magic_Spell_Type_XMLTree_Type::
school ()
{
  return this->school_.get ();
}

void RPG_Magic_Spell_Type_XMLTree_Type::
school (const school_type& x)
{
  this->school_.set (x);
}

void RPG_Magic_Spell_Type_XMLTree_Type::
school (::std::auto_ptr< school_type > x)
{
  this->school_.set (x);
}

const RPG_Magic_Spell_Type_XMLTree_Type::subSchool_optional& RPG_Magic_Spell_Type_XMLTree_Type::
subSchool () const
{
  return this->subSchool_;
}

RPG_Magic_Spell_Type_XMLTree_Type::subSchool_optional& RPG_Magic_Spell_Type_XMLTree_Type::
subSchool ()
{
  return this->subSchool_;
}

void RPG_Magic_Spell_Type_XMLTree_Type::
subSchool (const subSchool_type& x)
{
  this->subSchool_.set (x);
}

void RPG_Magic_Spell_Type_XMLTree_Type::
subSchool (const subSchool_optional& x)
{
  this->subSchool_ = x;
}

void RPG_Magic_Spell_Type_XMLTree_Type::
subSchool (::std::auto_ptr< subSchool_type > x)
{
  this->subSchool_.set (x);
}

const RPG_Magic_Spell_Type_XMLTree_Type::descriptor_sequence& RPG_Magic_Spell_Type_XMLTree_Type::
descriptor () const
{
  return this->descriptor_;
}

RPG_Magic_Spell_Type_XMLTree_Type::descriptor_sequence& RPG_Magic_Spell_Type_XMLTree_Type::
descriptor ()
{
  return this->descriptor_;
}

void RPG_Magic_Spell_Type_XMLTree_Type::
descriptor (const descriptor_sequence& s)
{
  this->descriptor_ = s;
}

const RPG_Magic_Spell_Type_XMLTree_Type::counterSpell_type& RPG_Magic_Spell_Type_XMLTree_Type::
counterSpell () const
{
  return this->counterSpell_.get ();
}

RPG_Magic_Spell_Type_XMLTree_Type::counterSpell_type& RPG_Magic_Spell_Type_XMLTree_Type::
counterSpell ()
{
  return this->counterSpell_.get ();
}

void RPG_Magic_Spell_Type_XMLTree_Type::
counterSpell (const counterSpell_type& x)
{
  this->counterSpell_.set (x);
}

void RPG_Magic_Spell_Type_XMLTree_Type::
counterSpell (::std::auto_ptr< counterSpell_type > x)
{
  this->counterSpell_.set (x);
}

const RPG_Magic_Spell_Type_XMLTree_Type::counterSpell_type& RPG_Magic_Spell_Type_XMLTree_Type::
counterSpell_default_value ()
{
  return counterSpell_default_value_;
}


// RPG_Magic_CasterClassUnion_XMLTree_Type
// 

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[v])
{
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const RPG_Magic_CasterClassUnion_XMLTree_Type& v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_CasterClassUnion_XMLTree_Type& RPG_Magic_CasterClassUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_Level_XMLTree_Type
// 

const RPG_Magic_Spell_Level_XMLTree_Type::casterClass_type& RPG_Magic_Spell_Level_XMLTree_Type::
casterClass () const
{
  return this->casterClass_.get ();
}

RPG_Magic_Spell_Level_XMLTree_Type::casterClass_type& RPG_Magic_Spell_Level_XMLTree_Type::
casterClass ()
{
  return this->casterClass_.get ();
}

void RPG_Magic_Spell_Level_XMLTree_Type::
casterClass (const casterClass_type& x)
{
  this->casterClass_.set (x);
}

void RPG_Magic_Spell_Level_XMLTree_Type::
casterClass (::std::auto_ptr< casterClass_type > x)
{
  this->casterClass_.set (x);
}

const RPG_Magic_Spell_Level_XMLTree_Type::level_type& RPG_Magic_Spell_Level_XMLTree_Type::
level () const
{
  return this->level_.get ();
}

RPG_Magic_Spell_Level_XMLTree_Type::level_type& RPG_Magic_Spell_Level_XMLTree_Type::
level ()
{
  return this->level_.get ();
}

void RPG_Magic_Spell_Level_XMLTree_Type::
level (const level_type& x)
{
  this->level_.set (x);
}


// RPG_Magic_Spell_CastingTime_XMLTree_Type
// 

const RPG_Magic_Spell_CastingTime_XMLTree_Type::rounds_optional& RPG_Magic_Spell_CastingTime_XMLTree_Type::
rounds () const
{
  return this->rounds_;
}

RPG_Magic_Spell_CastingTime_XMLTree_Type::rounds_optional& RPG_Magic_Spell_CastingTime_XMLTree_Type::
rounds ()
{
  return this->rounds_;
}

void RPG_Magic_Spell_CastingTime_XMLTree_Type::
rounds (const rounds_type& x)
{
  this->rounds_.set (x);
}

void RPG_Magic_Spell_CastingTime_XMLTree_Type::
rounds (const rounds_optional& x)
{
  this->rounds_ = x;
}

const RPG_Magic_Spell_CastingTime_XMLTree_Type::action_type& RPG_Magic_Spell_CastingTime_XMLTree_Type::
action () const
{
  return this->action_.get ();
}

RPG_Magic_Spell_CastingTime_XMLTree_Type::action_type& RPG_Magic_Spell_CastingTime_XMLTree_Type::
action ()
{
  return this->action_.get ();
}

void RPG_Magic_Spell_CastingTime_XMLTree_Type::
action (const action_type& x)
{
  this->action_.set (x);
}

void RPG_Magic_Spell_CastingTime_XMLTree_Type::
action (::std::auto_ptr< action_type > x)
{
  this->action_.set (x);
}

const RPG_Magic_Spell_CastingTime_XMLTree_Type::action_type& RPG_Magic_Spell_CastingTime_XMLTree_Type::
action_default_value ()
{
  return action_default_value_;
}


// RPG_Magic_Spell_RangeEffect_XMLTree_Type
// 

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const RPG_Magic_Spell_RangeEffect_XMLTree_Type& v,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type& RPG_Magic_Spell_RangeEffect_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_RangeProperties_XMLTree_Type
// 

const RPG_Magic_Spell_RangeProperties_XMLTree_Type::maximum_optional& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
maximum () const
{
  return this->maximum_;
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::maximum_optional& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
maximum ()
{
  return this->maximum_;
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
maximum (const maximum_type& x)
{
  this->maximum_.set (x);
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
maximum (const maximum_optional& x)
{
  this->maximum_ = x;
}

const RPG_Magic_Spell_RangeProperties_XMLTree_Type::increment_optional& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
increment () const
{
  return this->increment_;
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::increment_optional& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
increment ()
{
  return this->increment_;
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
increment (const increment_type& x)
{
  this->increment_.set (x);
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
increment (const increment_optional& x)
{
  this->increment_ = x;
}

const RPG_Magic_Spell_RangeProperties_XMLTree_Type::effect_type& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
effect () const
{
  return this->effect_.get ();
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::effect_type& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
effect ()
{
  return this->effect_.get ();
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
effect (const effect_type& x)
{
  this->effect_.set (x);
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
effect (::std::auto_ptr< effect_type > x)
{
  this->effect_.set (x);
}

const RPG_Magic_Spell_RangeProperties_XMLTree_Type::effect_type& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
effect_default_value ()
{
  return effect_default_value_;
}


// RPG_Magic_Spell_Target_XMLTree_Type
// 

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const RPG_Magic_Spell_Target_XMLTree_Type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_Target_XMLTree_Type& RPG_Magic_Spell_Target_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_AreaOfEffect_XMLTree_Type
// 

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_TargetProperties_XMLTree_Type
// 

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::base_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
base () const
{
  return this->base_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::base_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
base ()
{
  return this->base_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
base (const base_type& x)
{
  this->base_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
base (const base_optional& x)
{
  this->base_ = x;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
base (::std::auto_ptr< base_type > x)
{
  this->base_.set (x);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrement () const
{
  return this->levelIncrement_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrement ()
{
  return this->levelIncrement_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrement (const levelIncrement_type& x)
{
  this->levelIncrement_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrement (const levelIncrement_optional& x)
{
  this->levelIncrement_ = x;
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrementMax () const
{
  return this->levelIncrementMax_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrementMax ()
{
  return this->levelIncrementMax_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_type& x)
{
  this->levelIncrementMax_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_optional& x)
{
  this->levelIncrementMax_ = x;
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::effect_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
effect () const
{
  return this->effect_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::effect_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
effect ()
{
  return this->effect_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
effect (const effect_type& x)
{
  this->effect_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
effect (const effect_optional& x)
{
  this->effect_ = x;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
effect (::std::auto_ptr< effect_type > x)
{
  this->effect_.set (x);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::shape_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shape () const
{
  return this->shape_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::shape_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shape ()
{
  return this->shape_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shape (const shape_type& x)
{
  this->shape_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shape (const shape_optional& x)
{
  this->shape_ = x;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shape (::std::auto_ptr< shape_type > x)
{
  this->shape_.set (x);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::radius_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
radius () const
{
  return this->radius_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::radius_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
radius ()
{
  return this->radius_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
radius (const radius_optional& x)
{
  this->radius_ = x;
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::height_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
height () const
{
  return this->height_;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::height_optional& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
height ()
{
  return this->height_;
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
height (const height_type& x)
{
  this->height_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
height (const height_optional& x)
{
  this->height_ = x;
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::target_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
target () const
{
  return this->target_.get ();
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::target_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
target ()
{
  return this->target_.get ();
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
target (const target_type& x)
{
  this->target_.set (x);
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
target (::std::auto_ptr< target_type > x)
{
  this->target_.set (x);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::target_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
target_default_value ()
{
  return target_default_value_;
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::shapeable_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shapeable () const
{
  return this->shapeable_.get ();
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::shapeable_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shapeable ()
{
  return this->shapeable_.get ();
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shapeable (const shapeable_type& x)
{
  this->shapeable_.set (x);
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::shapeable_type RPG_Magic_Spell_TargetProperties_XMLTree_Type::
shapeable_default_value ()
{
  return shapeable_type (false);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::rangeIsInHD_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
rangeIsInHD () const
{
  return this->rangeIsInHD_.get ();
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::rangeIsInHD_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
rangeIsInHD ()
{
  return this->rangeIsInHD_.get ();
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
rangeIsInHD (const rangeIsInHD_type& x)
{
  this->rangeIsInHD_.set (x);
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::rangeIsInHD_type RPG_Magic_Spell_TargetProperties_XMLTree_Type::
rangeIsInHD_default_value ()
{
  return rangeIsInHD_type (false);
}

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::incrementIsReciprocal_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
incrementIsReciprocal () const
{
  return this->incrementIsReciprocal_.get ();
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::incrementIsReciprocal_type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
incrementIsReciprocal ()
{
  return this->incrementIsReciprocal_.get ();
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
incrementIsReciprocal (const incrementIsReciprocal_type& x)
{
  this->incrementIsReciprocal_.set (x);
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::incrementIsReciprocal_type RPG_Magic_Spell_TargetProperties_XMLTree_Type::
incrementIsReciprocal_default_value ()
{
  return incrementIsReciprocal_type (false);
}


// RPG_Magic_Spell_Duration_XMLTree_Type
// 

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const RPG_Magic_Spell_Duration_XMLTree_Type& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_Duration_XMLTree_Type& RPG_Magic_Spell_Duration_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_DurationProperties_XMLTree_Type
// 

const RPG_Magic_Spell_DurationProperties_XMLTree_Type::duration_type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
duration () const
{
  return this->duration_.get ();
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::duration_type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
duration ()
{
  return this->duration_.get ();
}

void RPG_Magic_Spell_DurationProperties_XMLTree_Type::
duration (const duration_type& x)
{
  this->duration_.set (x);
}

void RPG_Magic_Spell_DurationProperties_XMLTree_Type::
duration (::std::auto_ptr< duration_type > x)
{
  this->duration_.set (x);
}

const RPG_Magic_Spell_DurationProperties_XMLTree_Type::duration_type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
duration_default_value ()
{
  return duration_default_value_;
}

const RPG_Magic_Spell_DurationProperties_XMLTree_Type::dismissible_type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
dismissible () const
{
  return this->dismissible_.get ();
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::dismissible_type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
dismissible ()
{
  return this->dismissible_.get ();
}

void RPG_Magic_Spell_DurationProperties_XMLTree_Type::
dismissible (const dismissible_type& x)
{
  this->dismissible_.set (x);
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::dismissible_type RPG_Magic_Spell_DurationProperties_XMLTree_Type::
dismissible_default_value ()
{
  return dismissible_type (false);
}


// RPG_Magic_Spell_Precondition_XMLTree_Type
// 

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const RPG_Magic_Spell_Precondition_XMLTree_Type& v,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_Precondition_XMLTree_Type& RPG_Magic_Spell_Precondition_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_PreconditionProperties_XMLTree_Type
// 

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::type_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::type_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::value_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
value () const
{
  return this->value_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::value_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
value ()
{
  return this->value_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
value (const value_type& x)
{
  this->value_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
value (const value_optional& x)
{
  this->value_ = x;
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrement () const
{
  return this->levelIncrement_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrement ()
{
  return this->levelIncrement_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrement (const levelIncrement_type& x)
{
  this->levelIncrement_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrement (const levelIncrement_optional& x)
{
  this->levelIncrement_ = x;
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrementMax () const
{
  return this->levelIncrementMax_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrementMax ()
{
  return this->levelIncrementMax_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_type& x)
{
  this->levelIncrementMax_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_optional& x)
{
  this->levelIncrementMax_ = x;
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::alignment_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
alignment () const
{
  return this->alignment_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::alignment_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
alignment ()
{
  return this->alignment_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
alignment (const alignment_type& x)
{
  this->alignment_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
alignment (const alignment_optional& x)
{
  this->alignment_ = x;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
alignment (::std::auto_ptr< alignment_type > x)
{
  this->alignment_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::attribute_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
attribute () const
{
  return this->attribute_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::attribute_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
attribute ()
{
  return this->attribute_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
attribute (const attribute_type& x)
{
  this->attribute_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
attribute (const attribute_optional& x)
{
  this->attribute_ = x;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
attribute (::std::auto_ptr< attribute_type > x)
{
  this->attribute_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::condition_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
condition () const
{
  return this->condition_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::condition_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
condition ()
{
  return this->condition_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
condition (const condition_type& x)
{
  this->condition_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
condition (const condition_optional& x)
{
  this->condition_ = x;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
condition (::std::auto_ptr< condition_type > x)
{
  this->condition_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::creature_sequence& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
creature () const
{
  return this->creature_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::creature_sequence& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
creature ()
{
  return this->creature_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
creature (const creature_sequence& s)
{
  this->creature_ = s;
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::size_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
size () const
{
  return this->size_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::size_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
size ()
{
  return this->size_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
size (const size_type& x)
{
  this->size_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
size (const size_optional& x)
{
  this->size_ = x;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::environment_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
environment () const
{
  return this->environment_;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::environment_optional& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
environment ()
{
  return this->environment_;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
environment (const environment_type& x)
{
  this->environment_.set (x);
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
environment (const environment_optional& x)
{
  this->environment_ = x;
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
environment (::std::auto_ptr< environment_type > x)
{
  this->environment_.set (x);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::reverse_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
reverse () const
{
  return this->reverse_.get ();
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::reverse_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
reverse ()
{
  return this->reverse_.get ();
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
reverse (const reverse_type& x)
{
  this->reverse_.set (x);
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::reverse_type RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
reverse_default_value ()
{
  return reverse_type (false);
}

const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::baseIsCasterLevel_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
baseIsCasterLevel () const
{
  return this->baseIsCasterLevel_.get ();
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::baseIsCasterLevel_type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
baseIsCasterLevel ()
{
  return this->baseIsCasterLevel_.get ();
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
baseIsCasterLevel (const baseIsCasterLevel_type& x)
{
  this->baseIsCasterLevel_.set (x);
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::baseIsCasterLevel_type RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
baseIsCasterLevel_default_value ()
{
  return baseIsCasterLevel_type (false);
}


// RPG_Magic_Spell_Effect_XMLTree_Type
// 

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const RPG_Magic_Spell_Effect_XMLTree_Type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_Effect_XMLTree_Type& RPG_Magic_Spell_Effect_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type
// 

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_[v])
{
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& v,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_CheckTypeUnion_XMLTree_Type
// 

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[v])
{
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const RPG_Magic_CheckTypeUnion_XMLTree_Type& v,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Magic_CheckTypeUnion_XMLTree_Type& RPG_Magic_CheckTypeUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Magic_Check_XMLTree_Type
// 

const RPG_Magic_Check_XMLTree_Type::type_optional& RPG_Magic_Check_XMLTree_Type::
type () const
{
  return this->type_;
}

RPG_Magic_Check_XMLTree_Type::type_optional& RPG_Magic_Check_XMLTree_Type::
type ()
{
  return this->type_;
}

void RPG_Magic_Check_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_Check_XMLTree_Type::
type (const type_optional& x)
{
  this->type_ = x;
}

void RPG_Magic_Check_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_Check_XMLTree_Type::difficultyClass_optional& RPG_Magic_Check_XMLTree_Type::
difficultyClass () const
{
  return this->difficultyClass_;
}

RPG_Magic_Check_XMLTree_Type::difficultyClass_optional& RPG_Magic_Check_XMLTree_Type::
difficultyClass ()
{
  return this->difficultyClass_;
}

void RPG_Magic_Check_XMLTree_Type::
difficultyClass (const difficultyClass_type& x)
{
  this->difficultyClass_.set (x);
}

void RPG_Magic_Check_XMLTree_Type::
difficultyClass (const difficultyClass_optional& x)
{
  this->difficultyClass_ = x;
}

const RPG_Magic_Check_XMLTree_Type::modifier_optional& RPG_Magic_Check_XMLTree_Type::
modifier () const
{
  return this->modifier_;
}

RPG_Magic_Check_XMLTree_Type::modifier_optional& RPG_Magic_Check_XMLTree_Type::
modifier ()
{
  return this->modifier_;
}

void RPG_Magic_Check_XMLTree_Type::
modifier (const modifier_type& x)
{
  this->modifier_.set (x);
}

void RPG_Magic_Check_XMLTree_Type::
modifier (const modifier_optional& x)
{
  this->modifier_ = x;
}

const RPG_Magic_Check_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Check_XMLTree_Type::
levelIncrementMax () const
{
  return this->levelIncrementMax_;
}

RPG_Magic_Check_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Check_XMLTree_Type::
levelIncrementMax ()
{
  return this->levelIncrementMax_;
}

void RPG_Magic_Check_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_type& x)
{
  this->levelIncrementMax_.set (x);
}

void RPG_Magic_Check_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_optional& x)
{
  this->levelIncrementMax_ = x;
}

const RPG_Magic_Check_XMLTree_Type::baseIsCasterLevel_type& RPG_Magic_Check_XMLTree_Type::
baseIsCasterLevel () const
{
  return this->baseIsCasterLevel_.get ();
}

RPG_Magic_Check_XMLTree_Type::baseIsCasterLevel_type& RPG_Magic_Check_XMLTree_Type::
baseIsCasterLevel ()
{
  return this->baseIsCasterLevel_.get ();
}

void RPG_Magic_Check_XMLTree_Type::
baseIsCasterLevel (const baseIsCasterLevel_type& x)
{
  this->baseIsCasterLevel_.set (x);
}

RPG_Magic_Check_XMLTree_Type::baseIsCasterLevel_type RPG_Magic_Check_XMLTree_Type::
baseIsCasterLevel_default_value ()
{
  return baseIsCasterLevel_type (false);
}


// RPG_Magic_CounterMeasure_XMLTree_Type
// 

const RPG_Magic_CounterMeasure_XMLTree_Type::type_type& RPG_Magic_CounterMeasure_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_CounterMeasure_XMLTree_Type::type_type& RPG_Magic_CounterMeasure_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_CounterMeasure_XMLTree_Type::check_optional& RPG_Magic_CounterMeasure_XMLTree_Type::
check () const
{
  return this->check_;
}

RPG_Magic_CounterMeasure_XMLTree_Type::check_optional& RPG_Magic_CounterMeasure_XMLTree_Type::
check ()
{
  return this->check_;
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
check (const check_type& x)
{
  this->check_.set (x);
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
check (const check_optional& x)
{
  this->check_ = x;
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
check (::std::auto_ptr< check_type > x)
{
  this->check_.set (x);
}

const RPG_Magic_CounterMeasure_XMLTree_Type::spell_sequence& RPG_Magic_CounterMeasure_XMLTree_Type::
spell () const
{
  return this->spell_;
}

RPG_Magic_CounterMeasure_XMLTree_Type::spell_sequence& RPG_Magic_CounterMeasure_XMLTree_Type::
spell ()
{
  return this->spell_;
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
spell (const spell_sequence& s)
{
  this->spell_ = s;
}

const RPG_Magic_CounterMeasure_XMLTree_Type::reduction_type& RPG_Magic_CounterMeasure_XMLTree_Type::
reduction () const
{
  return this->reduction_.get ();
}

RPG_Magic_CounterMeasure_XMLTree_Type::reduction_type& RPG_Magic_CounterMeasure_XMLTree_Type::
reduction ()
{
  return this->reduction_.get ();
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
reduction (const reduction_type& x)
{
  this->reduction_.set (x);
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
reduction (::std::auto_ptr< reduction_type > x)
{
  this->reduction_.set (x);
}

const RPG_Magic_CounterMeasure_XMLTree_Type::reduction_type& RPG_Magic_CounterMeasure_XMLTree_Type::
reduction_default_value ()
{
  return reduction_default_value_;
}


// RPG_Magic_Spell_EffectProperties_XMLTree_Type
// 

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::type_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::type_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::damage_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
damage () const
{
  return this->damage_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::damage_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
damage ()
{
  return this->damage_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
damage (const damage_type& x)
{
  this->damage_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
damage (const damage_optional& x)
{
  this->damage_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
damage (::std::auto_ptr< damage_type > x)
{
  this->damage_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::base_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
base () const
{
  return this->base_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::base_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
base ()
{
  return this->base_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
base (const base_type& x)
{
  this->base_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
base (const base_optional& x)
{
  this->base_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
base (::std::auto_ptr< base_type > x)
{
  this->base_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::increment_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
increment () const
{
  return this->increment_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::increment_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
increment ()
{
  return this->increment_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
increment (const increment_type& x)
{
  this->increment_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
increment (const increment_optional& x)
{
  this->increment_ = x;
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrement () const
{
  return this->levelIncrement_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::levelIncrement_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrement ()
{
  return this->levelIncrement_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrement (const levelIncrement_type& x)
{
  this->levelIncrement_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrement (const levelIncrement_optional& x)
{
  this->levelIncrement_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrement (::std::auto_ptr< levelIncrement_type > x)
{
  this->levelIncrement_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrementMax () const
{
  return this->levelIncrementMax_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::levelIncrementMax_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrementMax ()
{
  return this->levelIncrementMax_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_type& x)
{
  this->levelIncrementMax_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
levelIncrementMax (const levelIncrementMax_optional& x)
{
  this->levelIncrementMax_ = x;
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::attribute_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
attribute () const
{
  return this->attribute_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::attribute_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
attribute ()
{
  return this->attribute_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
attribute (const attribute_type& x)
{
  this->attribute_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
attribute (const attribute_optional& x)
{
  this->attribute_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
attribute (::std::auto_ptr< attribute_type > x)
{
  this->attribute_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::domain_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
domain () const
{
  return this->domain_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::domain_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
domain ()
{
  return this->domain_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
domain (const domain_type& x)
{
  this->domain_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
domain (const domain_optional& x)
{
  this->domain_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
domain (::std::auto_ptr< domain_type > x)
{
  this->domain_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::creature_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
creature () const
{
  return this->creature_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::creature_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
creature ()
{
  return this->creature_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
creature (const creature_type& x)
{
  this->creature_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
creature (const creature_optional& x)
{
  this->creature_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
creature (::std::auto_ptr< creature_type > x)
{
  this->creature_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::duration_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
duration () const
{
  return this->duration_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::duration_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
duration ()
{
  return this->duration_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
duration (const duration_type& x)
{
  this->duration_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
duration (const duration_optional& x)
{
  this->duration_ = x;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
duration (::std::auto_ptr< duration_type > x)
{
  this->duration_.set (x);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::precondition_sequence& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
precondition () const
{
  return this->precondition_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::precondition_sequence& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
precondition ()
{
  return this->precondition_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
precondition (const precondition_sequence& s)
{
  this->precondition_ = s;
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::maxRange_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
maxRange () const
{
  return this->maxRange_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::maxRange_optional& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
maxRange ()
{
  return this->maxRange_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
maxRange (const maxRange_type& x)
{
  this->maxRange_.set (x);
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
maxRange (const maxRange_optional& x)
{
  this->maxRange_ = x;
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::counterMeasure_sequence& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
counterMeasure () const
{
  return this->counterMeasure_;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::counterMeasure_sequence& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
counterMeasure ()
{
  return this->counterMeasure_;
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
counterMeasure (const counterMeasure_sequence& s)
{
  this->counterMeasure_ = s;
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::includeAdjacent_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
includeAdjacent () const
{
  return this->includeAdjacent_.get ();
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::includeAdjacent_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
includeAdjacent ()
{
  return this->includeAdjacent_.get ();
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
includeAdjacent (const includeAdjacent_type& x)
{
  this->includeAdjacent_.set (x);
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::includeAdjacent_type RPG_Magic_Spell_EffectProperties_XMLTree_Type::
includeAdjacent_default_value ()
{
  return includeAdjacent_type (false);
}

const RPG_Magic_Spell_EffectProperties_XMLTree_Type::incrementIsReciprocal_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
incrementIsReciprocal () const
{
  return this->incrementIsReciprocal_.get ();
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::incrementIsReciprocal_type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
incrementIsReciprocal ()
{
  return this->incrementIsReciprocal_.get ();
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
incrementIsReciprocal (const incrementIsReciprocal_type& x)
{
  this->incrementIsReciprocal_.set (x);
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::incrementIsReciprocal_type RPG_Magic_Spell_EffectProperties_XMLTree_Type::
incrementIsReciprocal_default_value ()
{
  return incrementIsReciprocal_type (false);
}


// RPG_Magic_Spell_PropertiesXML_XMLTree_Type
// 

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::name_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
name () const
{
  return this->name_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::name_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
name ()
{
  return this->name_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
name (const name_type& x)
{
  this->name_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::type_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::type_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::level_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
level () const
{
  return this->level_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::level_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
level ()
{
  return this->level_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
level (const level_sequence& s)
{
  this->level_ = s;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::cost_optional& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
cost () const
{
  return this->cost_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::cost_optional& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
cost ()
{
  return this->cost_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
cost (const cost_type& x)
{
  this->cost_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
cost (const cost_optional& x)
{
  this->cost_ = x;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::time_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
time () const
{
  return this->time_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::time_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
time ()
{
  return this->time_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
time (const time_type& x)
{
  this->time_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
time (::std::auto_ptr< time_type > x)
{
  this->time_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::range_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
range () const
{
  return this->range_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::range_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
range ()
{
  return this->range_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
range (const range_type& x)
{
  this->range_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
range (::std::auto_ptr< range_type > x)
{
  this->range_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::target_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
target () const
{
  return this->target_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::target_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
target ()
{
  return this->target_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
target (const target_sequence& s)
{
  this->target_ = s;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::duration_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
duration () const
{
  return this->duration_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::duration_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
duration ()
{
  return this->duration_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
duration (const duration_type& x)
{
  this->duration_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
duration (::std::auto_ptr< duration_type > x)
{
  this->duration_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::precondition_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
precondition () const
{
  return this->precondition_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::precondition_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
precondition ()
{
  return this->precondition_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
precondition (const precondition_sequence& s)
{
  this->precondition_ = s;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effect_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effect () const
{
  return this->effect_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effect_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effect ()
{
  return this->effect_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effect (const effect_sequence& s)
{
  this->effect_ = s;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::counterMeasure_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
counterMeasure () const
{
  return this->counterMeasure_;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::counterMeasure_sequence& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
counterMeasure ()
{
  return this->counterMeasure_;
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
counterMeasure (const counterMeasure_sequence& s)
{
  this->counterMeasure_ = s;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::saveable_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
saveable () const
{
  return this->saveable_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::saveable_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
saveable ()
{
  return this->saveable_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
saveable (const saveable_type& x)
{
  this->saveable_.set (x);
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
saveable (::std::auto_ptr< saveable_type > x)
{
  this->saveable_.set (x);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::saveable_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
saveable_default_value ()
{
  return saveable_default_value_;
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::resistible_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
resistible () const
{
  return this->resistible_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::resistible_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
resistible ()
{
  return this->resistible_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
resistible (const resistible_type& x)
{
  this->resistible_.set (x);
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::resistible_type RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
resistible_default_value ()
{
  return resistible_type (false);
}

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effectsAreInclusive_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effectsAreInclusive () const
{
  return this->effectsAreInclusive_.get ();
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effectsAreInclusive_type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effectsAreInclusive ()
{
  return this->effectsAreInclusive_.get ();
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effectsAreInclusive (const effectsAreInclusive_type& x)
{
  this->effectsAreInclusive_.set (x);
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effectsAreInclusive_type RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
effectsAreInclusive_default_value ()
{
  return effectsAreInclusive_type (true);
}


// RPG_Magic_SpellLikeProperties_XMLTree_Type
// 

const RPG_Magic_SpellLikeProperties_XMLTree_Type::type_type& RPG_Magic_SpellLikeProperties_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::type_type& RPG_Magic_SpellLikeProperties_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Magic_SpellLikeProperties_XMLTree_Type::casterLevel_type& RPG_Magic_SpellLikeProperties_XMLTree_Type::
casterLevel () const
{
  return this->casterLevel_.get ();
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::casterLevel_type& RPG_Magic_SpellLikeProperties_XMLTree_Type::
casterLevel ()
{
  return this->casterLevel_.get ();
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
casterLevel (const casterLevel_type& x)
{
  this->casterLevel_.set (x);
}

const RPG_Magic_SpellLikeProperties_XMLTree_Type::duration_optional& RPG_Magic_SpellLikeProperties_XMLTree_Type::
duration () const
{
  return this->duration_;
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::duration_optional& RPG_Magic_SpellLikeProperties_XMLTree_Type::
duration ()
{
  return this->duration_;
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
duration (const duration_type& x)
{
  this->duration_.set (x);
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
duration (const duration_optional& x)
{
  this->duration_ = x;
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
duration (::std::auto_ptr< duration_type > x)
{
  this->duration_.set (x);
}

const RPG_Magic_SpellLikeProperties_XMLTree_Type::save_optional& RPG_Magic_SpellLikeProperties_XMLTree_Type::
save () const
{
  return this->save_;
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::save_optional& RPG_Magic_SpellLikeProperties_XMLTree_Type::
save ()
{
  return this->save_;
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
save (const save_type& x)
{
  this->save_.set (x);
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
save (const save_optional& x)
{
  this->save_ = x;
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
save (::std::auto_ptr< save_type > x)
{
  this->save_.set (x);
}


// RPG_Magic_Dictionary_XMLTree_Type
// 

const RPG_Magic_Dictionary_XMLTree_Type::spell_sequence& RPG_Magic_Dictionary_XMLTree_Type::
spell () const
{
  return this->spell_;
}

RPG_Magic_Dictionary_XMLTree_Type::spell_sequence& RPG_Magic_Dictionary_XMLTree_Type::
spell ()
{
  return this->spell_;
}

void RPG_Magic_Dictionary_XMLTree_Type::
spell (const spell_sequence& s)
{
  this->spell_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RPG_Magic_School_XMLTree_Type
//

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_School_XMLTree_Type_convert ();
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_School_XMLTree_Type_convert ();
}

RPG_Magic_School_XMLTree_Type::
RPG_Magic_School_XMLTree_Type (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_School_XMLTree_Type_convert ();
}

RPG_Magic_School_XMLTree_Type* RPG_Magic_School_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_School_XMLTree_Type (*this, f, c);
}

RPG_Magic_School_XMLTree_Type::value RPG_Magic_School_XMLTree_Type::
_xsd_RPG_Magic_School_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_School_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_School_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_School_XMLTree_Type_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_School_XMLTree_Type_indexes_ + 9 || _xsd_RPG_Magic_School_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_School_XMLTree_Type::
_xsd_RPG_Magic_School_XMLTree_Type_literals_[9] =
{
  "SCHOOL_NONE",
  "SCHOOL_ABJURATION",
  "SCHOOL_CONJURATION",
  "SCHOOL_DIVINATION",
  "SCHOOL_ENCHANTMENT",
  "SCHOOL_EVOCATION",
  "SCHOOL_ILLUSION",
  "SCHOOL_NECROMANCY",
  "SCHOOL_TRANSMUTATION"
};

const RPG_Magic_School_XMLTree_Type::value RPG_Magic_School_XMLTree_Type::
_xsd_RPG_Magic_School_XMLTree_Type_indexes_[9] =
{
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_ABJURATION,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_CONJURATION,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_DIVINATION,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_ENCHANTMENT,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_EVOCATION,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_ILLUSION,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_NECROMANCY,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_NONE,
  ::RPG_Magic_School_XMLTree_Type::SCHOOL_TRANSMUTATION
};

// RPG_Magic_SubSchool_XMLTree_Type
//

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_SubSchool_XMLTree_Type_convert ();
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_SubSchool_XMLTree_Type_convert ();
}

RPG_Magic_SubSchool_XMLTree_Type::
RPG_Magic_SubSchool_XMLTree_Type (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_SubSchool_XMLTree_Type_convert ();
}

RPG_Magic_SubSchool_XMLTree_Type* RPG_Magic_SubSchool_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_SubSchool_XMLTree_Type (*this, f, c);
}

RPG_Magic_SubSchool_XMLTree_Type::value RPG_Magic_SubSchool_XMLTree_Type::
_xsd_RPG_Magic_SubSchool_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_SubSchool_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_SubSchool_XMLTree_Type_indexes_ + 13,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_SubSchool_XMLTree_Type_indexes_ + 13 || _xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_SubSchool_XMLTree_Type::
_xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[13] =
{
  "SUBSCHOOL_SUMMONING",
  "SUBSCHOOL_CALLING",
  "SUBSCHOOL_HEALING",
  "SUBSCHOOL_TELEPORTATION",
  "SUBSCHOOL_CREATION",
  "SUBSCHOOL_SCRYING",
  "SUBSCHOOL_CHARM",
  "SUBSCHOOL_COMPULSION",
  "SUBSCHOOL_FIGMENT",
  "SUBSCHOOL_GLAMER",
  "SUBSCHOOL_PATTERN",
  "SUBSCHOOL_PHANTASM",
  "SUBSCHOOL_SHADOW"
};

const RPG_Magic_SubSchool_XMLTree_Type::value RPG_Magic_SubSchool_XMLTree_Type::
_xsd_RPG_Magic_SubSchool_XMLTree_Type_indexes_[13] =
{
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_CALLING,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_CHARM,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_COMPULSION,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_CREATION,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_FIGMENT,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_GLAMER,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_HEALING,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_PATTERN,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_PHANTASM,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_SCRYING,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_SHADOW,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_SUMMONING,
  ::RPG_Magic_SubSchool_XMLTree_Type::SUBSCHOOL_TELEPORTATION
};

// RPG_Magic_Descriptor_XMLTree_Type
//

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Descriptor_XMLTree_Type_convert ();
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Descriptor_XMLTree_Type_convert ();
}

RPG_Magic_Descriptor_XMLTree_Type::
RPG_Magic_Descriptor_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Descriptor_XMLTree_Type_convert ();
}

RPG_Magic_Descriptor_XMLTree_Type* RPG_Magic_Descriptor_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Descriptor_XMLTree_Type (*this, f, c);
}

RPG_Magic_Descriptor_XMLTree_Type::value RPG_Magic_Descriptor_XMLTree_Type::
_xsd_RPG_Magic_Descriptor_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Descriptor_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Descriptor_XMLTree_Type_indexes_ + 19,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Descriptor_XMLTree_Type_indexes_ + 19 || _xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Descriptor_XMLTree_Type::
_xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[19] =
{
  "DESCRIPTOR_ACID",
  "DESCRIPTOR_AIR",
  "DESCRIPTOR_CHAOTIC",
  "DESCRIPTOR_COLD",
  "DESCRIPTOR_DARKNESS",
  "DESCRIPTOR_DEATH",
  "DESCRIPTOR_EARTH",
  "DESCRIPTOR_ELECTRICITY",
  "DESCRIPTOR_EVIL",
  "DESCRIPTOR_FEAR",
  "DESCRIPTOR_FIRE",
  "DESCRIPTOR_FORCE",
  "DESCRIPTOR_GOOD",
  "DESCRIPTOR_LANGUAGE_DEPENDENT",
  "DESCRIPTOR_LAWFUL",
  "DESCRIPTOR_LIGHT",
  "DESCRIPTOR_MIND_AFFECTING",
  "DESCRIPTOR_SONIC",
  "DESCRIPTOR_WATER"
};

const RPG_Magic_Descriptor_XMLTree_Type::value RPG_Magic_Descriptor_XMLTree_Type::
_xsd_RPG_Magic_Descriptor_XMLTree_Type_indexes_[19] =
{
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_ACID,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_AIR,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_CHAOTIC,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_COLD,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_DARKNESS,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_DEATH,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_EARTH,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_ELECTRICITY,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_EVIL,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_FEAR,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_FIRE,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_FORCE,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_GOOD,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_LANGUAGE_DEPENDENT,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_LAWFUL,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_LIGHT,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_MIND_AFFECTING,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_SONIC,
  ::RPG_Magic_Descriptor_XMLTree_Type::DESCRIPTOR_WATER
};

// RPG_Magic_Domain_XMLTree_Type
//

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Domain_XMLTree_Type_convert ();
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Domain_XMLTree_Type_convert ();
}

RPG_Magic_Domain_XMLTree_Type::
RPG_Magic_Domain_XMLTree_Type (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Domain_XMLTree_Type_convert ();
}

RPG_Magic_Domain_XMLTree_Type* RPG_Magic_Domain_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Domain_XMLTree_Type (*this, f, c);
}

RPG_Magic_Domain_XMLTree_Type::value RPG_Magic_Domain_XMLTree_Type::
_xsd_RPG_Magic_Domain_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Domain_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Domain_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Domain_XMLTree_Type_indexes_ + 23,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Domain_XMLTree_Type_indexes_ + 23 || _xsd_RPG_Magic_Domain_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Domain_XMLTree_Type::
_xsd_RPG_Magic_Domain_XMLTree_Type_literals_[23] =
{
  "DOMAIN_NONE",
  "DOMAIN_AIR",
  "DOMAIN_ANIMAL",
  "DOMAIN_CHAOS",
  "DOMAIN_DEATH",
  "DOMAIN_DESTRUCTION",
  "DOMAIN_EARTH",
  "DOMAIN_EVIL",
  "DOMAIN_FIRE",
  "DOMAIN_GOOD",
  "DOMAIN_HEALING",
  "DOMAIN_KNOWLEDGE",
  "DOMAIN_LAW",
  "DOMAIN_LUCK",
  "DOMAIN_MAGIC",
  "DOMAIN_PLANT",
  "DOMAIN_PROTECTION",
  "DOMAIN_STRENGTH",
  "DOMAIN_SUN",
  "DOMAIN_TRAVEL",
  "DOMAIN_TRICKERY",
  "DOMAIN_WAR",
  "DOMAIN_WATER"
};

const RPG_Magic_Domain_XMLTree_Type::value RPG_Magic_Domain_XMLTree_Type::
_xsd_RPG_Magic_Domain_XMLTree_Type_indexes_[23] =
{
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_AIR,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_ANIMAL,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_CHAOS,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_DEATH,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_DESTRUCTION,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_EARTH,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_EVIL,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_FIRE,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_GOOD,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_HEALING,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_KNOWLEDGE,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_LAW,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_LUCK,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_MAGIC,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_NONE,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_PLANT,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_PROTECTION,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_STRENGTH,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_SUN,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_TRAVEL,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_TRICKERY,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_WAR,
  ::RPG_Magic_Domain_XMLTree_Type::DOMAIN_WATER
};

// RPG_Magic_SpellType_XMLTree_Type
//

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_SpellType_XMLTree_Type_convert ();
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_SpellType_XMLTree_Type_convert ();
}

RPG_Magic_SpellType_XMLTree_Type::
RPG_Magic_SpellType_XMLTree_Type (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_SpellType_XMLTree_Type_convert ();
}

RPG_Magic_SpellType_XMLTree_Type* RPG_Magic_SpellType_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_SpellType_XMLTree_Type (*this, f, c);
}

RPG_Magic_SpellType_XMLTree_Type::value RPG_Magic_SpellType_XMLTree_Type::
_xsd_RPG_Magic_SpellType_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_SpellType_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_SpellType_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_SpellType_XMLTree_Type_indexes_ + 235,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_SpellType_XMLTree_Type_indexes_ + 235 || _xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_SpellType_XMLTree_Type::
_xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[235] =
{
  "SPELL_NONE",
  "SPELL_ACID_ARROW",
  "SPELL_ACID_FOG",
  "SPELL_ACID_SPLASH",
  "SPELL_AID",
  "SPELL_AIR_WALK",
  "SPELL_ALARM",
  "SPELL_ALIGN_WEAPON",
  "SPELL_ALTER_SELF",
  "SPELL_ANALYZE_DWEOMER",
  "SPELL_ANIMAL_GROWTH",
  "SPELL_ANIMAL_MESSENGER",
  "SPELL_ANIMAL_SHAPES",
  "SPELL_ANIMAL_TRANCE",
  "SPELL_ANIMATE_DEAD",
  "SPELL_ANIMATE_OBJECTS",
  "SPELL_ANIMATE_PLANTS",
  "SPELL_ANIMATE_ROPE",
  "SPELL_ANTILIFE_SHELL",
  "SPELL_ANTIMAGIC_FIELD",
  "SPELL_ANTIPATHY",
  "SPELL_ANTIPLANT_SHELL",
  "SPELL_ARCANE_EYE",
  "SPELL_ARCANE_LOCK",
  "SPELL_ARCANE_MARK",
  "SPELL_ARCANE_SIGHT",
  "SPELL_ARCANE_SIGHT_GREATER",
  "SPELL_ASTRAL_PROJECTION",
  "SPELL_ATONEMENT",
  "SPELL_AUGURY",
  "SPELL_AWAKEN",
  "SPELL_BALEFUL_POLYMORPH",
  "SPELL_BANE",
  "SPELL_BANISHMENT",
  "SPELL_BARKSKIN",
  "SPELL_BEARS_ENDURANCE",
  "SPELL_BEARS_ENDURANCE_MASS",
  "SPELL_BESTOW_CURSE",
  "SPELL_BINDING",
  "SPELL_BLACK_TENTACLES",
  "SPELL_BLADE_BARRIER",
  "SPELL_BLASPHEMY",
  "SPELL_BLESS",
  "SPELL_BLESS_WATER",
  "SPELL_BLESS_WEAPON",
  "SPELL_BLIGHT",
  "SPELL_BLINDNESS_DEAFNESS",
  "SPELL_BLINK",
  "SPELL_BLUR",
  "SPELL_BREAK_ENCHANTMENT",
  "SPELL_BULLS_STRENGTH",
  "SPELL_BULLS_STRENGTH_MASS",
  "SPELL_BURNING_HANDS",
  "SPELL_CALL_LIGHTNING",
  "SPELL_CALL_LIGHTNING_STORM",
  "SPELL_CALM_ANIMALS",
  "SPELL_CALM_EMOTIONS",
  "SPELL_CATS_GRACE",
  "SPELL_CATS_GRACE_MASS",
  "SPELL_CAUSE_FEAR",
  "SPELL_CHAIN_LIGHTNING",
  "SPELL_CHANGESTAFF",
  "SPELL_CHAOS_HAMMER",
  "SPELL_CHARM_ANIMAL",
  "SPELL_CHARM_MONSTER",
  "SPELL_CHARM_MONSTER_MASS",
  "SPELL_CHARM_PERSON",
  "SPELL_CHILL_METAL",
  "SPELL_CHILL_TOUCH",
  "SPELL_CIRCLE_OF_DEATH",
  "SPELL_CLAIRAUDIENCE_CLAIRVOYANCE",
  "SPELL_CLENCHED_FIST",
  "SPELL_CLOAK_OF_CHAOS",
  "SPELL_CLONE",
  "SPELL_CLOUDKILL",
  "SPELL_COLOR_SPRAY",
  "SPELL_COMMAND",
  "SPELL_COMMAND_GREATER",
  "SPELL_COMMAND_PLANTS",
  "SPELL_COMMAND_UNDEAD",
  "SPELL_COMMUNE",
  "SPELL_COMMUNE_WITH_NATURE",
  "SPELL_COMPREHEND_LANGUAGES",
  "SPELL_CONE_OF_COLD",
  "SPELL_CONFUSION",
  "SPELL_CONFUSION_LESSER",
  "SPELL_CONSECRATE",
  "SPELL_CONTACT_OTHER_PLANE",
  "SPELL_CONTAGION",
  "SPELL_CONTINGENCY",
  "SPELL_CONTINUAL_FLAME",
  "SPELL_CONTROL_PLANTS",
  "SPELL_CONTROL_UNDEAD",
  "SPELL_CONTROL_WATER",
  "SPELL_CONTROL_WEATHER",
  "SPELL_CONTROL_WINDS",
  "SPELL_CREATE_FOOD_AND_WATER",
  "SPELL_CREATE_UNDEAD",
  "SPELL_CREATE_UNDEAD_GREATER",
  "SPELL_CREATE_WATER",
  "SPELL_CREEPING_DOOM",
  "SPELL_CRUSHING_DESPAIR",
  "SPELL_CRUSHING_HAND",
  "SPELL_CURE_WOUNDS_CRITICAL",
  "SPELL_CURE_WOUNDS_CRITICAL_MASS",
  "SPELL_CURE_WOUNDS_LIGHT",
  "SPELL_CURE_WOUNDS_LIGHT_MASS",
  "SPELL_CURE_WOUNDS_MINOR",
  "SPELL_CURE_WOUNDS_MODERATE",
  "SPELL_CURE_WOUNDS_MODERATE_MASS",
  "SPELL_CURE_WOUNDS_SERIOUS",
  "SPELL_CURE_WOUNDS_SERIOUS_MASS",
  "SPELL_CURSE_WATER",
  "SPELL_DANCING_LIGHTS",
  "SPELL_DARKNESS",
  "SPELL_DARKNESS_DEEPER",
  "SPELL_DARKVISION",
  "SPELL_DAYLIGHT",
  "SPELL_DAZE",
  "SPELL_DAZE_MONSTER",
  "SPELL_DEATH_KNELL",
  "SPELL_DEATH_WARD",
  "SPELL_DEATHWATCH",
  "SPELL_DEEP_SLUMBER",
  "SPELL_DELAY_POISON",
  "SPELL_DELAYED_BLAST_FIREBALL",
  "SPELL_DEMAND",
  "SPELL_DESECRATE",
  "SPELL_DESTRUCTION",
  "SPELL_DETECT_ANIMALS_PLANTS",
  "SPELL_DETECT_CHAOS",
  "SPELL_DETECT_EVIL",
  "SPELL_DETECT_GOOD",
  "SPELL_DETECT_LAW",
  "SPELL_DETECT_MAGIC",
  "SPELL_DETECT_POISON",
  "SPELL_DETECT_SCRYING",
  "SPELL_DETECT_SECRET_DOORS",
  "SPELL_DETECT_SNARES_AND_PITS",
  "SPELL_DETECT_THOUGHTS",
  "SPELL_DETECT_UNDEAD",
  "SPELL_DICTUM",
  "SPELL_DIMENSION_DOOR",
  "SPELL_DIMENSIONAL_ANCHOR",
  "SPELL_DIMENSIONAL_LOCK",
  "SPELL_DIMINISH_PLANTS",
  "SPELL_DISCERN_LIES",
  "SPELL_DISCERN_LOCATION",
  "SPELL_DISGUISE_SELF",
  "SPELL_DISINTEGRATE",
  "SPELL_DISMISSAL",
  "SPELL_DISPEL_CHAOS",
  "SPELL_DISPEL_EVIL",
  "SPELL_DISPEL_GOOD",
  "SPELL_DISPEL_LAW",
  "SPELL_DISPEL_MAGIC",
  "SPELL_DISPEL_MAGIC_GREATER",
  "SPELL_DISPLACEMENT",
  "SPELL_DISRUPT_UNDEAD",
  "SPELL_DISRUPTING_WEAPON",
  "SPELL_DIVINATION",
  "SPELL_DIVINE_FAVOR",
  "SPELL_DIVINE_POWER",
  "SPELL_DOMINATE_ANIMAL",
  "SPELL_DOMINATE_MONSTER",
  "SPELL_DOMINATE_PERSON",
  "SPELL_DOOM",
  "SPELL_DREAM",
  "SPELL_EAGLES_SPLENDOR",
  "SPELL_EAGLES_SPLENDOR_MASS",
  "SPELL_ELEMENTAL_SWARM",
  "SPELL_ENDURE_ELEMENTS",
  "SPELL_ENERGY_DRAIN",
  "SPELL_ENERVATION",
  "SPELL_ENLARGE_PERSON",
  "SPELL_ENLARGE_PERSON_MASS",
  "SPELL_ENTANGLE",
  "SPELL_ENTHRALL",
  "SPELL_ENTROPIC_SHIELD",
  "SPELL_ERASE",
  "SPELL_ETHEREAL_JAUNT",
  "SPELL_ETHEREALNESS",
  "SPELL_EXPEDITIOUS_RETREAT",
  "SPELL_EXPLOSIVE_RUNES",
  "SPELL_EYEBITE",
  "SPELL_FEAR",
  "SPELL_FEEBLEMIND",
  "SPELL_FIRE_STORM",
  "SPELL_GASEOUS_FORM",
  "SPELL_GOOD_HOPE",
  "SPELL_HEAL",
  "SPELL_HEAL_MASS",
  "SPELL_HEAT_METAL",
  "SPELL_HEROISM",
  "SPELL_HOLD_MONSTER",
  "SPELL_IMPLOSION",
  "SPELL_INSANITY",
  "SPELL_INVISIBILITY",
  "SPELL_MAGIC_WEAPON",
  "SPELL_MIRACLE",
  "SPELL_MIRROR_IMAGE",
  "SPELL_NEUTRALIZE_POISON",
  "SPELL_PLANE_SHIFT",
  "SPELL_PLANT_GROWTH",
  "SPELL_POLYMORPH",
  "SPELL_POWER_WORD_STUN",
  "SPELL_PROJECT_IMAGE",
  "SPELL_REMOVE_CURSE",
  "SPELL_REMOVE_DISEASE",
  "SPELL_REMOVE_FEAR",
  "SPELL_RESTORATION",
  "SPELL_RESTORATION_GREATER",
  "SPELL_REVERSE_GRAVITY",
  "SPELL_SCARE",
  "SPELL_SEE_INVISIBILITY",
  "SPELL_SILENT_IMAGE",
  "SPELL_SLOW",
  "SPELL_STINKING_CLOUD",
  "SPELL_STONE_SHAPE",
  "SPELL_SUGGESTION",
  "SPELL_SUMMON_MONSTER_I",
  "SPELL_SUMMON_MONSTER_III",
  "SPELL_SUMMON_MONSTER_IV",
  "SPELL_SUMMON_MONSTER_V",
  "SPELL_SUMMON_MONSTER_IX",
  "SPELL_SYMPATHY",
  "SPELL_TELEKINESIS",
  "SPELL_TELEPATHY",
  "SPELL_TELEPORT_GREATER",
  "SPELL_TONGUES",
  "SPELL_TRUE_SEEING",
  "SPELL_UNHOLY_AURA",
  "SPELL_UNHOLY_BLIGHT",
  "SPELL_WISH",
  "SPELL_WISH_LIMITED"
};

const RPG_Magic_SpellType_XMLTree_Type::value RPG_Magic_SpellType_XMLTree_Type::
_xsd_RPG_Magic_SpellType_XMLTree_Type_indexes_[235] =
{
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ACID_ARROW,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ACID_FOG,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ACID_SPLASH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_AID,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_AIR_WALK,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ALARM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ALIGN_WEAPON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ALTER_SELF,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANALYZE_DWEOMER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMAL_GROWTH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMAL_MESSENGER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMAL_SHAPES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMAL_TRANCE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMATE_DEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMATE_OBJECTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMATE_PLANTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANIMATE_ROPE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANTILIFE_SHELL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANTIMAGIC_FIELD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANTIPATHY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ANTIPLANT_SHELL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ARCANE_EYE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ARCANE_LOCK,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ARCANE_MARK,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ARCANE_SIGHT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ARCANE_SIGHT_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ASTRAL_PROJECTION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ATONEMENT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_AUGURY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_AWAKEN,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BALEFUL_POLYMORPH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BANE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BANISHMENT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BARKSKIN,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BEARS_ENDURANCE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BEARS_ENDURANCE_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BESTOW_CURSE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BINDING,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLACK_TENTACLES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLADE_BARRIER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLASPHEMY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLESS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLESS_WATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLESS_WEAPON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLIGHT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLINDNESS_DEAFNESS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLINK,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BLUR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BREAK_ENCHANTMENT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BULLS_STRENGTH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BULLS_STRENGTH_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_BURNING_HANDS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CALL_LIGHTNING,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CALL_LIGHTNING_STORM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CALM_ANIMALS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CALM_EMOTIONS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CATS_GRACE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CATS_GRACE_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CAUSE_FEAR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHAIN_LIGHTNING,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHANGESTAFF,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHAOS_HAMMER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHARM_ANIMAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHARM_MONSTER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHARM_MONSTER_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHARM_PERSON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHILL_METAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CHILL_TOUCH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CIRCLE_OF_DEATH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CLAIRAUDIENCE_CLAIRVOYANCE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CLENCHED_FIST,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CLOAK_OF_CHAOS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CLONE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CLOUDKILL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COLOR_SPRAY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMAND,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMAND_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMAND_PLANTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMAND_UNDEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMUNE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMMUNE_WITH_NATURE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_COMPREHEND_LANGUAGES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONE_OF_COLD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONFUSION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONFUSION_LESSER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONSECRATE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTACT_OTHER_PLANE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTAGION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTINGENCY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTINUAL_FLAME,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTROL_PLANTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTROL_UNDEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTROL_WATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTROL_WEATHER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CONTROL_WINDS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CREATE_FOOD_AND_WATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CREATE_UNDEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CREATE_UNDEAD_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CREATE_WATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CREEPING_DOOM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CRUSHING_DESPAIR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CRUSHING_HAND,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_CRITICAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_CRITICAL_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_LIGHT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_LIGHT_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_MINOR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_MODERATE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_MODERATE_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_SERIOUS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURE_WOUNDS_SERIOUS_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_CURSE_WATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DANCING_LIGHTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DARKNESS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DARKNESS_DEEPER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DARKVISION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DAYLIGHT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DAZE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DAZE_MONSTER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DEATHWATCH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DEATH_KNELL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DEATH_WARD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DEEP_SLUMBER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DELAYED_BLAST_FIREBALL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DELAY_POISON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DEMAND,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DESECRATE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DESTRUCTION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_ANIMALS_PLANTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_CHAOS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_EVIL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_GOOD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_LAW,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_MAGIC,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_POISON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_SCRYING,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_SECRET_DOORS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_SNARES_AND_PITS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_THOUGHTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DETECT_UNDEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DICTUM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIMENSIONAL_ANCHOR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIMENSIONAL_LOCK,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIMENSION_DOOR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIMINISH_PLANTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISCERN_LIES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISCERN_LOCATION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISGUISE_SELF,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISINTEGRATE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISMISSAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_CHAOS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_EVIL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_GOOD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_LAW,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_MAGIC,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPEL_MAGIC_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISPLACEMENT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISRUPTING_WEAPON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DISRUPT_UNDEAD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIVINATION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIVINE_FAVOR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DIVINE_POWER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DOMINATE_ANIMAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DOMINATE_MONSTER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DOMINATE_PERSON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DOOM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_DREAM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_EAGLES_SPLENDOR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_EAGLES_SPLENDOR_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ELEMENTAL_SWARM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENDURE_ELEMENTS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENERGY_DRAIN,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENERVATION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENLARGE_PERSON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENLARGE_PERSON_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENTANGLE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENTHRALL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ENTROPIC_SHIELD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ERASE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ETHEREALNESS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_ETHEREAL_JAUNT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_EXPEDITIOUS_RETREAT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_EXPLOSIVE_RUNES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_EYEBITE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_FEAR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_FEEBLEMIND,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_FIRE_STORM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_GASEOUS_FORM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_GOOD_HOPE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_HEAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_HEAL_MASS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_HEAT_METAL,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_HEROISM,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_HOLD_MONSTER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_IMPLOSION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_INSANITY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_INVISIBILITY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_MAGIC_WEAPON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_MIRACLE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_MIRROR_IMAGE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_NEUTRALIZE_POISON,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_NONE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_PLANE_SHIFT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_PLANT_GROWTH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_POLYMORPH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_POWER_WORD_STUN,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_PROJECT_IMAGE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_REMOVE_CURSE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_REMOVE_DISEASE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_REMOVE_FEAR,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_RESTORATION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_RESTORATION_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_REVERSE_GRAVITY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SCARE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SEE_INVISIBILITY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SILENT_IMAGE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SLOW,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_STINKING_CLOUD,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_STONE_SHAPE,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUGGESTION,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUMMON_MONSTER_I,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUMMON_MONSTER_III,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUMMON_MONSTER_IV,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUMMON_MONSTER_IX,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SUMMON_MONSTER_V,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_SYMPATHY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_TELEKINESIS,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_TELEPATHY,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_TELEPORT_GREATER,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_TONGUES,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_TRUE_SEEING,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_UNHOLY_AURA,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_UNHOLY_BLIGHT,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_WISH,
  ::RPG_Magic_SpellType_XMLTree_Type::SPELL_WISH_LIMITED
};

// RPG_Magic_AbilityClass_XMLTree_Type
//

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert ();
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert ();
}

RPG_Magic_AbilityClass_XMLTree_Type::
RPG_Magic_AbilityClass_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert ();
}

RPG_Magic_AbilityClass_XMLTree_Type* RPG_Magic_AbilityClass_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_AbilityClass_XMLTree_Type (*this, f, c);
}

RPG_Magic_AbilityClass_XMLTree_Type::value RPG_Magic_AbilityClass_XMLTree_Type::
_xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_AbilityClass_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_AbilityClass_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_AbilityClass_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_AbilityClass_XMLTree_Type::
_xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[3] =
{
  "ABILITYCLASS_EXTRAORDINARY",
  "ABILITYCLASS_SPELLLIKE",
  "ABILITYCLASS_SUPERNATURAL"
};

const RPG_Magic_AbilityClass_XMLTree_Type::value RPG_Magic_AbilityClass_XMLTree_Type::
_xsd_RPG_Magic_AbilityClass_XMLTree_Type_indexes_[3] =
{
  ::RPG_Magic_AbilityClass_XMLTree_Type::ABILITYCLASS_EXTRAORDINARY,
  ::RPG_Magic_AbilityClass_XMLTree_Type::ABILITYCLASS_SPELLLIKE,
  ::RPG_Magic_AbilityClass_XMLTree_Type::ABILITYCLASS_SUPERNATURAL
};

// RPG_Magic_AbilityType_XMLTree_Type
//

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_AbilityType_XMLTree_Type_convert ();
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_AbilityType_XMLTree_Type_convert ();
}

RPG_Magic_AbilityType_XMLTree_Type::
RPG_Magic_AbilityType_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_AbilityType_XMLTree_Type_convert ();
}

RPG_Magic_AbilityType_XMLTree_Type* RPG_Magic_AbilityType_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_AbilityType_XMLTree_Type (*this, f, c);
}

RPG_Magic_AbilityType_XMLTree_Type::value RPG_Magic_AbilityType_XMLTree_Type::
_xsd_RPG_Magic_AbilityType_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_AbilityType_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_AbilityType_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_AbilityType_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_AbilityType_XMLTree_Type::
_xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[3] =
{
  "ABILITYTYPE_SMITE",
  "ABILITYTYPE_SMOKE_CLAWS",
  "ABILITYTYPE_WHIRLWIND_BLAST"
};

const RPG_Magic_AbilityType_XMLTree_Type::value RPG_Magic_AbilityType_XMLTree_Type::
_xsd_RPG_Magic_AbilityType_XMLTree_Type_indexes_[3] =
{
  ::RPG_Magic_AbilityType_XMLTree_Type::ABILITYTYPE_SMITE,
  ::RPG_Magic_AbilityType_XMLTree_Type::ABILITYTYPE_SMOKE_CLAWS,
  ::RPG_Magic_AbilityType_XMLTree_Type::ABILITYTYPE_WHIRLWIND_BLAST
};

// RPG_Magic_Spell_Type_XMLTree_Type
//

const RPG_Magic_Spell_Type_XMLTree_Type::counterSpell_type RPG_Magic_Spell_Type_XMLTree_Type::counterSpell_default_value_ (
  "SPELL_NONE");

RPG_Magic_Spell_Type_XMLTree_Type::
RPG_Magic_Spell_Type_XMLTree_Type (const type_type& type,
                                   const school_type& school)
: ::xml_schema::type (),
  type_ (type, this),
  school_ (school, this),
  subSchool_ (this),
  descriptor_ (this),
  counterSpell_ (counterSpell_default_value (), this)
{
}

RPG_Magic_Spell_Type_XMLTree_Type::
RPG_Magic_Spell_Type_XMLTree_Type (const RPG_Magic_Spell_Type_XMLTree_Type& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  school_ (x.school_, f, this),
  subSchool_ (x.subSchool_, f, this),
  descriptor_ (x.descriptor_, f, this),
  counterSpell_ (x.counterSpell_, f, this)
{
}

RPG_Magic_Spell_Type_XMLTree_Type::
RPG_Magic_Spell_Type_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  school_ (this),
  subSchool_ (this),
  descriptor_ (this),
  counterSpell_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_Type_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // school
    //
    if (n.name () == "school" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< school_type > r (
        school_traits::create (i, f, this));

      if (!school_.present ())
      {
        this->school_.set (r);
        continue;
      }
    }

    // subSchool
    //
    if (n.name () == "subSchool" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< subSchool_type > r (
        subSchool_traits::create (i, f, this));

      if (!this->subSchool_)
      {
        this->subSchool_.set (r);
        continue;
      }
    }

    // descriptor
    //
    if (n.name () == "descriptor" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< descriptor_type > r (
        descriptor_traits::create (i, f, this));

      this->descriptor_.push_back (r);
      continue;
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!school_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "school",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "counterSpell" && n.namespace_ ().empty ())
    {
      this->counterSpell_.set (counterSpell_traits::create (i, f, this));
      continue;
    }
  }

  if (!counterSpell_.present ())
  {
    this->counterSpell_.set (counterSpell_default_value ());
  }
}

RPG_Magic_Spell_Type_XMLTree_Type* RPG_Magic_Spell_Type_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Type_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Type_XMLTree_Type& RPG_Magic_Spell_Type_XMLTree_Type::
operator= (const RPG_Magic_Spell_Type_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->school_ = x.school_;
    this->subSchool_ = x.subSchool_;
    this->descriptor_ = x.descriptor_;
    this->counterSpell_ = x.counterSpell_;
  }

  return *this;
}

RPG_Magic_Spell_Type_XMLTree_Type::
~RPG_Magic_Spell_Type_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_Type_XMLTree_Type& x, const RPG_Magic_Spell_Type_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.school () == y.school ()))
    return false;

  if (!(x.subSchool () == y.subSchool ()))
    return false;

  if (!(x.descriptor () == y.descriptor ()))
    return false;

  if (!(x.counterSpell () == y.counterSpell ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_Type_XMLTree_Type& x, const RPG_Magic_Spell_Type_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_CasterClassUnion_XMLTree_Type
//

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert ();
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert ();
}

RPG_Magic_CasterClassUnion_XMLTree_Type::
RPG_Magic_CasterClassUnion_XMLTree_Type (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert ();
}

RPG_Magic_CasterClassUnion_XMLTree_Type* RPG_Magic_CasterClassUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_CasterClassUnion_XMLTree_Type (*this, f, c);
}

RPG_Magic_CasterClassUnion_XMLTree_Type::value RPG_Magic_CasterClassUnion_XMLTree_Type::
_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_indexes_ + 33,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_indexes_ + 33 || _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_CasterClassUnion_XMLTree_Type::
_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[33] =
{
  "SUBCLASS_NONE",
  "SUBCLASS_BARD",
  "SUBCLASS_CLERIC",
  "SUBCLASS_DRUID",
  "SUBCLASS_FIGHTER",
  "SUBCLASS_PALADIN",
  "SUBCLASS_RANGER",
  "SUBCLASS_SORCERER",
  "SUBCLASS_THIEF",
  "SUBCLASS_WIZARD",
  "DOMAIN_NONE",
  "DOMAIN_AIR",
  "DOMAIN_ANIMAL",
  "DOMAIN_CHAOS",
  "DOMAIN_DEATH",
  "DOMAIN_DESTRUCTION",
  "DOMAIN_EARTH",
  "DOMAIN_EVIL",
  "DOMAIN_FIRE",
  "DOMAIN_GOOD",
  "DOMAIN_HEALING",
  "DOMAIN_KNOWLEDGE",
  "DOMAIN_LAW",
  "DOMAIN_LUCK",
  "DOMAIN_MAGIC",
  "DOMAIN_PLANT",
  "DOMAIN_PROTECTION",
  "DOMAIN_STRENGTH",
  "DOMAIN_SUN",
  "DOMAIN_TRAVEL",
  "DOMAIN_TRICKERY",
  "DOMAIN_WAR",
  "DOMAIN_WATER"
};

const RPG_Magic_CasterClassUnion_XMLTree_Type::value RPG_Magic_CasterClassUnion_XMLTree_Type::
_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_indexes_[33] =
{
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_AIR,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_ANIMAL,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_CHAOS,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_DEATH,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_DESTRUCTION,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_EARTH,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_EVIL,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_FIRE,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_GOOD,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_HEALING,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_KNOWLEDGE,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_LAW,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_LUCK,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_MAGIC,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_NONE,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_PLANT,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_PROTECTION,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_STRENGTH,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_SUN,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_TRAVEL,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_TRICKERY,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_WAR,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::DOMAIN_WATER,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_BARD,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_CLERIC,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_DRUID,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_FIGHTER,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_NONE,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_PALADIN,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_RANGER,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_SORCERER,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_THIEF,
  ::RPG_Magic_CasterClassUnion_XMLTree_Type::SUBCLASS_WIZARD
};

// RPG_Magic_Spell_Level_XMLTree_Type
//

RPG_Magic_Spell_Level_XMLTree_Type::
RPG_Magic_Spell_Level_XMLTree_Type (const casterClass_type& casterClass,
                                    const level_type& level)
: ::xml_schema::type (),
  casterClass_ (casterClass, this),
  level_ (level, this)
{
}

RPG_Magic_Spell_Level_XMLTree_Type::
RPG_Magic_Spell_Level_XMLTree_Type (const RPG_Magic_Spell_Level_XMLTree_Type& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  casterClass_ (x.casterClass_, f, this),
  level_ (x.level_, f, this)
{
}

RPG_Magic_Spell_Level_XMLTree_Type::
RPG_Magic_Spell_Level_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  casterClass_ (this),
  level_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_Level_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // casterClass
    //
    if (n.name () == "casterClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< casterClass_type > r (
        casterClass_traits::create (i, f, this));

      if (!casterClass_.present ())
      {
        this->casterClass_.set (r);
        continue;
      }
    }

    // level
    //
    if (n.name () == "level" && n.namespace_ () == "urn:rpg")
    {
      if (!level_.present ())
      {
        this->level_.set (level_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!casterClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "casterClass",
      "urn:rpg");
  }

  if (!level_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "level",
      "urn:rpg");
  }
}

RPG_Magic_Spell_Level_XMLTree_Type* RPG_Magic_Spell_Level_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Level_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Level_XMLTree_Type& RPG_Magic_Spell_Level_XMLTree_Type::
operator= (const RPG_Magic_Spell_Level_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->casterClass_ = x.casterClass_;
    this->level_ = x.level_;
  }

  return *this;
}

RPG_Magic_Spell_Level_XMLTree_Type::
~RPG_Magic_Spell_Level_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_Level_XMLTree_Type& x, const RPG_Magic_Spell_Level_XMLTree_Type& y)
{
  if (!(x.casterClass () == y.casterClass ()))
    return false;

  if (!(x.level () == y.level ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_Level_XMLTree_Type& x, const RPG_Magic_Spell_Level_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_CastingTime_XMLTree_Type
//

const RPG_Magic_Spell_CastingTime_XMLTree_Type::action_type RPG_Magic_Spell_CastingTime_XMLTree_Type::action_default_value_ (
  "ACTION_STANDARD");

RPG_Magic_Spell_CastingTime_XMLTree_Type::
RPG_Magic_Spell_CastingTime_XMLTree_Type ()
: ::xml_schema::type (),
  rounds_ (this),
  action_ (action_default_value (), this)
{
}

RPG_Magic_Spell_CastingTime_XMLTree_Type::
RPG_Magic_Spell_CastingTime_XMLTree_Type (const RPG_Magic_Spell_CastingTime_XMLTree_Type& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  rounds_ (x.rounds_, f, this),
  action_ (x.action_, f, this)
{
}

RPG_Magic_Spell_CastingTime_XMLTree_Type::
RPG_Magic_Spell_CastingTime_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  rounds_ (this),
  action_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_CastingTime_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // rounds
    //
    if (n.name () == "rounds" && n.namespace_ () == "urn:rpg")
    {
      if (!this->rounds_)
      {
        this->rounds_.set (rounds_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "action" && n.namespace_ ().empty ())
    {
      this->action_.set (action_traits::create (i, f, this));
      continue;
    }
  }

  if (!action_.present ())
  {
    this->action_.set (action_default_value ());
  }
}

RPG_Magic_Spell_CastingTime_XMLTree_Type* RPG_Magic_Spell_CastingTime_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_CastingTime_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_CastingTime_XMLTree_Type& RPG_Magic_Spell_CastingTime_XMLTree_Type::
operator= (const RPG_Magic_Spell_CastingTime_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->rounds_ = x.rounds_;
    this->action_ = x.action_;
  }

  return *this;
}

RPG_Magic_Spell_CastingTime_XMLTree_Type::
~RPG_Magic_Spell_CastingTime_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_CastingTime_XMLTree_Type& x, const RPG_Magic_Spell_CastingTime_XMLTree_Type& y)
{
  if (!(x.rounds () == y.rounds ()))
    return false;

  if (!(x.action () == y.action ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_CastingTime_XMLTree_Type& x, const RPG_Magic_Spell_CastingTime_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_RangeEffect_XMLTree_Type
//

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::
RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type* RPG_Magic_Spell_RangeEffect_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_RangeEffect_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_RangeEffect_XMLTree_Type::value RPG_Magic_Spell_RangeEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_indexes_ + 7 || _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_RangeEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[7] =
{
  "RANGEEFFECT_PERSONAL",
  "RANGEEFFECT_TOUCH",
  "RANGEEFFECT_CLOSE",
  "RANGEEFFECT_MEDIUM",
  "RANGEEFFECT_LONG",
  "RANGEEFFECT_UNLIMITED",
  "RANGEEFFECT_RANGED"
};

const RPG_Magic_Spell_RangeEffect_XMLTree_Type::value RPG_Magic_Spell_RangeEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_indexes_[7] =
{
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_CLOSE,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_LONG,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_MEDIUM,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_PERSONAL,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_RANGED,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_TOUCH,
  ::RPG_Magic_Spell_RangeEffect_XMLTree_Type::RANGEEFFECT_UNLIMITED
};

// RPG_Magic_Spell_RangeProperties_XMLTree_Type
//

const RPG_Magic_Spell_RangeProperties_XMLTree_Type::effect_type RPG_Magic_Spell_RangeProperties_XMLTree_Type::effect_default_value_ (
  "RANGEEFFECT_PERSONAL");

RPG_Magic_Spell_RangeProperties_XMLTree_Type::
RPG_Magic_Spell_RangeProperties_XMLTree_Type ()
: ::xml_schema::type (),
  maximum_ (this),
  increment_ (this),
  effect_ (effect_default_value (), this)
{
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::
RPG_Magic_Spell_RangeProperties_XMLTree_Type (const RPG_Magic_Spell_RangeProperties_XMLTree_Type& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  maximum_ (x.maximum_, f, this),
  increment_ (x.increment_, f, this),
  effect_ (x.effect_, f, this)
{
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::
RPG_Magic_Spell_RangeProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  maximum_ (this),
  increment_ (this),
  effect_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_RangeProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // maximum
    //
    if (n.name () == "maximum" && n.namespace_ () == "urn:rpg")
    {
      if (!this->maximum_)
      {
        this->maximum_.set (maximum_traits::create (i, f, this));
        continue;
      }
    }

    // increment
    //
    if (n.name () == "increment" && n.namespace_ () == "urn:rpg")
    {
      if (!this->increment_)
      {
        this->increment_.set (increment_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "effect" && n.namespace_ ().empty ())
    {
      this->effect_.set (effect_traits::create (i, f, this));
      continue;
    }
  }

  if (!effect_.present ())
  {
    this->effect_.set (effect_default_value ());
  }
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type* RPG_Magic_Spell_RangeProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_RangeProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type& RPG_Magic_Spell_RangeProperties_XMLTree_Type::
operator= (const RPG_Magic_Spell_RangeProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->maximum_ = x.maximum_;
    this->increment_ = x.increment_;
    this->effect_ = x.effect_;
  }

  return *this;
}

RPG_Magic_Spell_RangeProperties_XMLTree_Type::
~RPG_Magic_Spell_RangeProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_RangeProperties_XMLTree_Type& x, const RPG_Magic_Spell_RangeProperties_XMLTree_Type& y)
{
  if (!(x.maximum () == y.maximum ()))
    return false;

  if (!(x.increment () == y.increment ()))
    return false;

  if (!(x.effect () == y.effect ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_RangeProperties_XMLTree_Type& x, const RPG_Magic_Spell_RangeProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_Target_XMLTree_Type
//

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Target_XMLTree_Type::
RPG_Magic_Spell_Target_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Target_XMLTree_Type* RPG_Magic_Spell_Target_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Target_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Target_XMLTree_Type::value RPG_Magic_Spell_Target_XMLTree_Type::
_xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_Target_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_Target_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_Target_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_Target_XMLTree_Type::
_xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[5] =
{
  "TARGET_SELF",
  "TARGET_SINGLE",
  "TARGET_SEVERAL",
  "TARGET_LOCATION",
  "TARGET_AREA"
};

const RPG_Magic_Spell_Target_XMLTree_Type::value RPG_Magic_Spell_Target_XMLTree_Type::
_xsd_RPG_Magic_Spell_Target_XMLTree_Type_indexes_[5] =
{
  ::RPG_Magic_Spell_Target_XMLTree_Type::TARGET_AREA,
  ::RPG_Magic_Spell_Target_XMLTree_Type::TARGET_LOCATION,
  ::RPG_Magic_Spell_Target_XMLTree_Type::TARGET_SELF,
  ::RPG_Magic_Spell_Target_XMLTree_Type::TARGET_SEVERAL,
  ::RPG_Magic_Spell_Target_XMLTree_Type::TARGET_SINGLE
};

// RPG_Magic_Spell_AreaOfEffect_XMLTree_Type
//

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type* RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::value RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[3] =
{
  "EFFECT_BURST",
  "EFFECT_EMANATION",
  "EFFECT_SPREAD"
};

const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::value RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::
_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_indexes_[3] =
{
  ::RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::EFFECT_BURST,
  ::RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::EFFECT_EMANATION,
  ::RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::EFFECT_SPREAD
};

// RPG_Magic_Spell_TargetProperties_XMLTree_Type
//

const RPG_Magic_Spell_TargetProperties_XMLTree_Type::target_type RPG_Magic_Spell_TargetProperties_XMLTree_Type::target_default_value_ (
  "TARGET_SELF");

RPG_Magic_Spell_TargetProperties_XMLTree_Type::
RPG_Magic_Spell_TargetProperties_XMLTree_Type ()
: ::xml_schema::type (),
  base_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  effect_ (this),
  shape_ (this),
  radius_ (this),
  height_ (this),
  target_ (target_default_value (), this),
  shapeable_ (shapeable_default_value (), this),
  rangeIsInHD_ (rangeIsInHD_default_value (), this),
  incrementIsReciprocal_ (incrementIsReciprocal_default_value (), this)
{
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::
RPG_Magic_Spell_TargetProperties_XMLTree_Type (const RPG_Magic_Spell_TargetProperties_XMLTree_Type& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_ (x.base_, f, this),
  levelIncrement_ (x.levelIncrement_, f, this),
  levelIncrementMax_ (x.levelIncrementMax_, f, this),
  effect_ (x.effect_, f, this),
  shape_ (x.shape_, f, this),
  radius_ (x.radius_, f, this),
  height_ (x.height_, f, this),
  target_ (x.target_, f, this),
  shapeable_ (x.shapeable_, f, this),
  rangeIsInHD_ (x.rangeIsInHD_, f, this),
  incrementIsReciprocal_ (x.incrementIsReciprocal_, f, this)
{
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::
RPG_Magic_Spell_TargetProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  effect_ (this),
  shape_ (this),
  radius_ (this),
  height_ (this),
  target_ (this),
  shapeable_ (this),
  rangeIsInHD_ (this),
  incrementIsReciprocal_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_TargetProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // base
    //
    if (n.name () == "base" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< base_type > r (
        base_traits::create (i, f, this));

      if (!this->base_)
      {
        this->base_.set (r);
        continue;
      }
    }

    // levelIncrement
    //
    if (n.name () == "levelIncrement" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrement_)
      {
        this->levelIncrement_.set (levelIncrement_traits::create (i, f, this));
        continue;
      }
    }

    // levelIncrementMax
    //
    if (n.name () == "levelIncrementMax" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrementMax_)
      {
        this->levelIncrementMax_.set (levelIncrementMax_traits::create (i, f, this));
        continue;
      }
    }

    // effect
    //
    if (n.name () == "effect" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< effect_type > r (
        effect_traits::create (i, f, this));

      if (!this->effect_)
      {
        this->effect_.set (r);
        continue;
      }
    }

    // shape
    //
    if (n.name () == "shape" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< shape_type > r (
        shape_traits::create (i, f, this));

      if (!this->shape_)
      {
        this->shape_.set (r);
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ () == "urn:rpg")
    {
      if (!this->radius_)
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ () == "urn:rpg")
    {
      if (!this->height_)
      {
        this->height_.set (height_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "target" && n.namespace_ ().empty ())
    {
      this->target_.set (target_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "shapeable" && n.namespace_ ().empty ())
    {
      this->shapeable_.set (shapeable_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rangeIsInHD" && n.namespace_ ().empty ())
    {
      this->rangeIsInHD_.set (rangeIsInHD_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "incrementIsReciprocal" && n.namespace_ ().empty ())
    {
      this->incrementIsReciprocal_.set (incrementIsReciprocal_traits::create (i, f, this));
      continue;
    }
  }

  if (!target_.present ())
  {
    this->target_.set (target_default_value ());
  }

  if (!shapeable_.present ())
  {
    this->shapeable_.set (shapeable_default_value ());
  }

  if (!rangeIsInHD_.present ())
  {
    this->rangeIsInHD_.set (rangeIsInHD_default_value ());
  }

  if (!incrementIsReciprocal_.present ())
  {
    this->incrementIsReciprocal_.set (incrementIsReciprocal_default_value ());
  }
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type* RPG_Magic_Spell_TargetProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_TargetProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type& RPG_Magic_Spell_TargetProperties_XMLTree_Type::
operator= (const RPG_Magic_Spell_TargetProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_ = x.base_;
    this->levelIncrement_ = x.levelIncrement_;
    this->levelIncrementMax_ = x.levelIncrementMax_;
    this->effect_ = x.effect_;
    this->shape_ = x.shape_;
    this->radius_ = x.radius_;
    this->height_ = x.height_;
    this->target_ = x.target_;
    this->shapeable_ = x.shapeable_;
    this->rangeIsInHD_ = x.rangeIsInHD_;
    this->incrementIsReciprocal_ = x.incrementIsReciprocal_;
  }

  return *this;
}

RPG_Magic_Spell_TargetProperties_XMLTree_Type::
~RPG_Magic_Spell_TargetProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_TargetProperties_XMLTree_Type& x, const RPG_Magic_Spell_TargetProperties_XMLTree_Type& y)
{
  if (!(x.base () == y.base ()))
    return false;

  if (!(x.levelIncrement () == y.levelIncrement ()))
    return false;

  if (!(x.levelIncrementMax () == y.levelIncrementMax ()))
    return false;

  if (!(x.effect () == y.effect ()))
    return false;

  if (!(x.shape () == y.shape ()))
    return false;

  if (!(x.radius () == y.radius ()))
    return false;

  if (!(x.height () == y.height ()))
    return false;

  if (!(x.target () == y.target ()))
    return false;

  if (!(x.shapeable () == y.shapeable ()))
    return false;

  if (!(x.rangeIsInHD () == y.rangeIsInHD ()))
    return false;

  if (!(x.incrementIsReciprocal () == y.incrementIsReciprocal ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_TargetProperties_XMLTree_Type& x, const RPG_Magic_Spell_TargetProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_Duration_XMLTree_Type
//

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Duration_XMLTree_Type::
RPG_Magic_Spell_Duration_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Duration_XMLTree_Type* RPG_Magic_Spell_Duration_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Duration_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Duration_XMLTree_Type::value RPG_Magic_Spell_Duration_XMLTree_Type::
_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_Duration_XMLTree_Type::
_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[5] =
{
  "DURATION_CONCENTRATION",
  "DURATION_DISCHARGE",
  "DURATION_INSTANTANEOUS",
  "DURATION_PERMANENT",
  "DURATION_TIMED"
};

const RPG_Magic_Spell_Duration_XMLTree_Type::value RPG_Magic_Spell_Duration_XMLTree_Type::
_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_indexes_[5] =
{
  ::RPG_Magic_Spell_Duration_XMLTree_Type::DURATION_CONCENTRATION,
  ::RPG_Magic_Spell_Duration_XMLTree_Type::DURATION_DISCHARGE,
  ::RPG_Magic_Spell_Duration_XMLTree_Type::DURATION_INSTANTANEOUS,
  ::RPG_Magic_Spell_Duration_XMLTree_Type::DURATION_PERMANENT,
  ::RPG_Magic_Spell_Duration_XMLTree_Type::DURATION_TIMED
};

// RPG_Magic_Spell_DurationProperties_XMLTree_Type
//

const RPG_Magic_Spell_DurationProperties_XMLTree_Type::duration_type RPG_Magic_Spell_DurationProperties_XMLTree_Type::duration_default_value_ (
  "DURATION_INSTANTANEOUS");

RPG_Magic_Spell_DurationProperties_XMLTree_Type::
RPG_Magic_Spell_DurationProperties_XMLTree_Type ()
: ::RPG_Common_EffectDuration_XMLTree_Type (),
  duration_ (duration_default_value (), this),
  dismissible_ (dismissible_default_value (), this)
{
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::
RPG_Magic_Spell_DurationProperties_XMLTree_Type (const RPG_Magic_Spell_DurationProperties_XMLTree_Type& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::RPG_Common_EffectDuration_XMLTree_Type (x, f, c),
  duration_ (x.duration_, f, this),
  dismissible_ (x.dismissible_, f, this)
{
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::
RPG_Magic_Spell_DurationProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
: ::RPG_Common_EffectDuration_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  duration_ (this),
  dismissible_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_DurationProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Common_EffectDuration_XMLTree_Type::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "duration" && n.namespace_ ().empty ())
    {
      this->duration_.set (duration_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dismissible" && n.namespace_ ().empty ())
    {
      this->dismissible_.set (dismissible_traits::create (i, f, this));
      continue;
    }
  }

  if (!duration_.present ())
  {
    this->duration_.set (duration_default_value ());
  }

  if (!dismissible_.present ())
  {
    this->dismissible_.set (dismissible_default_value ());
  }
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type* RPG_Magic_Spell_DurationProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_DurationProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type& RPG_Magic_Spell_DurationProperties_XMLTree_Type::
operator= (const RPG_Magic_Spell_DurationProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::RPG_Common_EffectDuration_XMLTree_Type& > (*this) = x;
    this->duration_ = x.duration_;
    this->dismissible_ = x.dismissible_;
  }

  return *this;
}

RPG_Magic_Spell_DurationProperties_XMLTree_Type::
~RPG_Magic_Spell_DurationProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_DurationProperties_XMLTree_Type& x, const RPG_Magic_Spell_DurationProperties_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Common_EffectDuration_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Common_EffectDuration_XMLTree_Type& > (y)))
    return false;

  if (!(x.duration () == y.duration ()))
    return false;

  if (!(x.dismissible () == y.dismissible ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_DurationProperties_XMLTree_Type& x, const RPG_Magic_Spell_DurationProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_Precondition_XMLTree_Type
//

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Precondition_XMLTree_Type::
RPG_Magic_Spell_Precondition_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Precondition_XMLTree_Type* RPG_Magic_Spell_Precondition_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Precondition_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Precondition_XMLTree_Type::value RPG_Magic_Spell_Precondition_XMLTree_Type::
_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_indexes_ + 19,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_indexes_ + 19 || _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_Precondition_XMLTree_Type::
_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[19] =
{
  "PRECONDITION_ALLY",
  "PRECONDITION_ALIGNMENT",
  "PRECONDITION_ATTACK_MELEE_ANY",
  "PRECONDITION_ATTACK_MELEE_RANGED_TOUCH",
  "PRECONDITION_ATTRIBUTE_MAX",
  "PRECONDITION_CASTER_PLANE",
  "PRECONDITION_CONDITION",
  "PRECONDITION_ENVIRONMENT",
  "PRECONDITION_HD_MAX",
  "PRECONDITION_HD_MIN",
  "PRECONDITION_IMMUNITY_POISON",
  "PRECONDITION_SPELLLEVEL_MAX",
  "PRECONDITION_MANUFACTURED",
  "PRECONDITION_NONMAGICAL",
  "PRECONDITION_OBJECT",
  "PRECONDITION_SIGHTLESS",
  "PRECONDITION_SIZE_MAX",
  "PRECONDITION_SIZE_RELATIVE",
  "PRECONDITION_TYPE"
};

const RPG_Magic_Spell_Precondition_XMLTree_Type::value RPG_Magic_Spell_Precondition_XMLTree_Type::
_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_indexes_[19] =
{
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ALIGNMENT,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ALLY,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ATTACK_MELEE_ANY,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ATTACK_MELEE_RANGED_TOUCH,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ATTRIBUTE_MAX,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_CASTER_PLANE,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_CONDITION,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_ENVIRONMENT,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_HD_MAX,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_HD_MIN,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_IMMUNITY_POISON,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_MANUFACTURED,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_NONMAGICAL,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_OBJECT,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_SIGHTLESS,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_SIZE_MAX,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_SIZE_RELATIVE,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_SPELLLEVEL_MAX,
  ::RPG_Magic_Spell_Precondition_XMLTree_Type::PRECONDITION_TYPE
};

// RPG_Magic_Spell_PreconditionProperties_XMLTree_Type
//

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this),
  value_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  alignment_ (this),
  attribute_ (this),
  condition_ (this),
  creature_ (this),
  size_ (this),
  environment_ (this),
  reverse_ (reverse_default_value (), this),
  baseIsCasterLevel_ (baseIsCasterLevel_default_value (), this)
{
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& x,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  value_ (x.value_, f, this),
  levelIncrement_ (x.levelIncrement_, f, this),
  levelIncrementMax_ (x.levelIncrementMax_, f, this),
  alignment_ (x.alignment_, f, this),
  attribute_ (x.attribute_, f, this),
  condition_ (x.condition_, f, this),
  creature_ (x.creature_, f, this),
  size_ (x.size_, f, this),
  environment_ (x.environment_, f, this),
  reverse_ (x.reverse_, f, this),
  baseIsCasterLevel_ (x.baseIsCasterLevel_, f, this)
{
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::flags f,
                                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  value_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  alignment_ (this),
  attribute_ (this),
  condition_ (this),
  creature_ (this),
  size_ (this),
  environment_ (this),
  reverse_ (this),
  baseIsCasterLevel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // value
    //
    if (n.name () == "value" && n.namespace_ () == "urn:rpg")
    {
      if (!this->value_)
      {
        this->value_.set (value_traits::create (i, f, this));
        continue;
      }
    }

    // levelIncrement
    //
    if (n.name () == "levelIncrement" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrement_)
      {
        this->levelIncrement_.set (levelIncrement_traits::create (i, f, this));
        continue;
      }
    }

    // levelIncrementMax
    //
    if (n.name () == "levelIncrementMax" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrementMax_)
      {
        this->levelIncrementMax_.set (levelIncrementMax_traits::create (i, f, this));
        continue;
      }
    }

    // alignment
    //
    if (n.name () == "alignment" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< alignment_type > r (
        alignment_traits::create (i, f, this));

      if (!this->alignment_)
      {
        this->alignment_.set (r);
        continue;
      }
    }

    // attribute
    //
    if (n.name () == "attribute" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< attribute_type > r (
        attribute_traits::create (i, f, this));

      if (!this->attribute_)
      {
        this->attribute_.set (r);
        continue;
      }
    }

    // condition
    //
    if (n.name () == "condition" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< condition_type > r (
        condition_traits::create (i, f, this));

      if (!this->condition_)
      {
        this->condition_.set (r);
        continue;
      }
    }

    // creature
    //
    if (n.name () == "creature" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< creature_type > r (
        creature_traits::create (i, f, this));

      this->creature_.push_back (r);
      continue;
    }

    // size
    //
    if (n.name () == "size" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!this->size_)
      {
        this->size_.set (r);
        continue;
      }
    }

    // environment
    //
    if (n.name () == "environment" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< environment_type > r (
        environment_traits::create (i, f, this));

      if (!this->environment_)
      {
        this->environment_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "reverse" && n.namespace_ ().empty ())
    {
      this->reverse_.set (reverse_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "baseIsCasterLevel" && n.namespace_ ().empty ())
    {
      this->baseIsCasterLevel_.set (baseIsCasterLevel_traits::create (i, f, this));
      continue;
    }
  }

  if (!reverse_.present ())
  {
    this->reverse_.set (reverse_default_value ());
  }

  if (!baseIsCasterLevel_.present ())
  {
    this->baseIsCasterLevel_.set (baseIsCasterLevel_default_value ());
  }
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type* RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
operator= (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->value_ = x.value_;
    this->levelIncrement_ = x.levelIncrement_;
    this->levelIncrementMax_ = x.levelIncrementMax_;
    this->alignment_ = x.alignment_;
    this->attribute_ = x.attribute_;
    this->condition_ = x.condition_;
    this->creature_ = x.creature_;
    this->size_ = x.size_;
    this->environment_ = x.environment_;
    this->reverse_ = x.reverse_;
    this->baseIsCasterLevel_ = x.baseIsCasterLevel_;
  }

  return *this;
}

RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::
~RPG_Magic_Spell_PreconditionProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& x, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.value () == y.value ()))
    return false;

  if (!(x.levelIncrement () == y.levelIncrement ()))
    return false;

  if (!(x.levelIncrementMax () == y.levelIncrementMax ()))
    return false;

  if (!(x.alignment () == y.alignment ()))
    return false;

  if (!(x.attribute () == y.attribute ()))
    return false;

  if (!(x.condition () == y.condition ()))
    return false;

  if (!(x.creature () == y.creature ()))
    return false;

  if (!(x.size () == y.size ()))
    return false;

  if (!(x.environment () == y.environment ()))
    return false;

  if (!(x.reverse () == y.reverse ()))
    return false;

  if (!(x.baseIsCasterLevel () == y.baseIsCasterLevel ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& x, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_Effect_XMLTree_Type
//

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Effect_XMLTree_Type::
RPG_Magic_Spell_Effect_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert ();
}

RPG_Magic_Spell_Effect_XMLTree_Type* RPG_Magic_Spell_Effect_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_Effect_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_Effect_XMLTree_Type::value RPG_Magic_Spell_Effect_XMLTree_Type::
_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_indexes_ + 100,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_indexes_ + 100 || _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_Effect_XMLTree_Type::
_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[100] =
{
  "SPELLEFFECT_ABILITY_LOSS_MAGICAL_ALL",
  "SPELLEFFECT_ABILITY_LOSS_MAGICAL_EXTRAORDINARY",
  "SPELLEFFECT_ABILITY_LOSS_MAGICAL_SPELLLIKE",
  "SPELLEFFECT_ABILITY_LOSS_MAGICAL_SUPERNATURAL",
  "SPELLEFFECT_ALIGN_WEAPON",
  "SPELLEFFECT_ANIMATE_DEAD",
  "SPELLEFFECT_ANIMATE_OBJECT",
  "SPELLEFFECT_ATONEMENT",
  "SPELLEFFECT_AUGURY",
  "SPELLEFFECT_BANISH_CREATURE",
  "SPELLEFFECT_BARRIER_CREATURE",
  "SPELLEFFECT_BARRIER_MAGIC",
  "SPELLEFFECT_BLESS_WATER",
  "SPELLEFFECT_BLESS_WEAPON",
  "SPELLEFFECT_BLIND",
  "SPELLEFFECT_CALM_CREATURE",
  "SPELLEFFECT_CHARM_CREATURE",
  "SPELLEFFECT_COMMAND",
  "SPELLEFFECT_COMPREHEND_LANGUAGES",
  "SPELLEFFECT_CONFUSE",
  "SPELLEFFECT_CONSUME",
  "SPELLEFFECT_CONTACT_DIETY",
  "SPELLEFFECT_CONTROL_CREATURE",
  "SPELLEFFECT_CONTROL_WATER",
  "SPELLEFFECT_CONTROL_WEATHER",
  "SPELLEFFECT_CONTROL_WINDS",
  "SPELLEFFECT_CONTINGENCY",
  "SPELLEFFECT_CREATE_FOOD_AND_WATER",
  "SPELLEFFECT_CREATE_WATER",
  "SPELLEFFECT_CURSE_WATER",
  "SPELLEFFECT_DAMAGE",
  "SPELLEFFECT_DARKNESS",
  "SPELLEFFECT_DARKVISION",
  "SPELLEFFECT_DAZE",
  "SPELLEFFECT_DEAFEN",
  "SPELLEFFECT_DETECT_ANIMALS_PLANTS",
  "SPELLEFFECT_DETECT_MAGIC",
  "SPELLEFFECT_DETECT_POISON",
  "SPELLEFFECT_DETECT_SCRYING",
  "SPELLEFFECT_DETECT_SECRET_DOORS",
  "SPELLEFFECT_DETECT_SNARES_AND_PITS",
  "SPELLEFFECT_DETECT_THOUGHTS",
  "SPELLEFFECT_DETECT_UNDEAD",
  "SPELLEFFECT_DIMENSIONAL_ANCHOR",
  "SPELLEFFECT_DIMINISH",
  "SPELLEFFECT_DISCERN_LIES",
  "SPELLEFFECT_DISGUISE",
  "SPELLEFFECT_DISINTEGRATE",
  "SPELLEFFECT_DISPEL_MAGIC",
  "SPELLEFFECT_ENTANGLE",
  "SPELLEFFECT_ETHEREAL",
  "SPELLEFFECT_FASCINATE",
  "SPELLEFFECT_FEAR",
  "SPELLEFFECT_GROW",
  "SPELLEFFECT_HEAL",
  "SPELLEFFECT_HOLD_CREATURE",
  "SPELLEFFECT_IDENTIFY",
  "SPELLEFFECT_IDENTIFY_CONDITION",
  "SPELLEFFECT_IMMUNITY_MAGIC_DEATH",
  "SPELLEFFECT_IMMUNITY_MAGIC_MIND_AFFECTING",
  "SPELLEFFECT_IMMUNITY_POISON",
  "SPELLEFFECT_IMMUNITY_POSSESSION",
  "SPELLEFFECT_INVISIBLE",
  "SPELLEFFECT_KILL",
  "SPELLEFFECT_KNOCKOUT",
  "SPELLEFFECT_LEVITATE",
  "SPELLEFFECT_LIGHT_MAGICAL",
  "SPELLEFFECT_LOCATE",
  "SPELLEFFECT_LOCK",
  "SPELLEFFECT_MARK",
  "SPELLEFFECT_MESSENGER",
  "SPELLEFFECT_MISS",
  "SPELLEFFECT_MODIFIER_ARMOR_CLASS",
  "SPELLEFFECT_MODIFIER_ATTACK_ROLL",
  "SPELLEFFECT_MODIFIER_ATTRIBUTE",
  "SPELLEFFECT_MODIFIER_CHECK_ATTRIBUTE_ALL",
  "SPELLEFFECT_MODIFIER_CHECK_ATTRIBUTE_CHARISMA",
  "SPELLEFFECT_MODIFIER_CHECK_SKILL_ALL",
  "SPELLEFFECT_MODIFIER_DAMAGE_ROLL",
  "SPELLEFFECT_MODIFIER_HP",
  "SPELLEFFECT_MODIFIER_LEVEL_CASTER",
  "SPELLEFFECT_MODIFIER_MORALE",
  "SPELLEFFECT_MODIFIER_SAVE_ALL",
  "SPELLEFFECT_MODIFIER_SAVE_FEAR",
  "SPELLEFFECT_MODIFIER_SAVE_REFLEX",
  "SPELLEFFECT_MODIFIER_WEAPON_DAMAGE_ROLL",
  "SPELLEFFECT_PARALYSIS",
  "SPELLEFFECT_POLYMORPH",
  "SPELLEFFECT_RAISE_DEAD",
  "SPELLEFFECT_RESISTANCE_SPELL_LAWFUL",
  "SPELLEFFECT_SENSOR_AUDIAL",
  "SPELLEFFECT_SENSOR_VISUAL",
  "SPELLEFFECT_SLEEP",
  "SPELLEFFECT_SLOW",
  "SPELLEFFECT_STUN",
  "SPELLEFFECT_SUGGESTION",
  "SPELLEFFECT_SUMMON_CREATURE",
  "SPELLEFFECT_TELEPORT",
  "SPELLEFFECT_TELEPORT_INTERPLANAR",
  "SPELLEFFECT_TRIGGER_ALARM"
};

const RPG_Magic_Spell_Effect_XMLTree_Type::value RPG_Magic_Spell_Effect_XMLTree_Type::
_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_indexes_[100] =
{
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ABILITY_LOSS_MAGICAL_ALL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ABILITY_LOSS_MAGICAL_EXTRAORDINARY,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ABILITY_LOSS_MAGICAL_SPELLLIKE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ABILITY_LOSS_MAGICAL_SUPERNATURAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ALIGN_WEAPON,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ANIMATE_DEAD,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ANIMATE_OBJECT,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ATONEMENT,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_AUGURY,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BANISH_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BARRIER_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BARRIER_MAGIC,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BLESS_WATER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BLESS_WEAPON,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_BLIND,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CALM_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CHARM_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_COMMAND,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_COMPREHEND_LANGUAGES,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONFUSE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONSUME,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTACT_DIETY,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTINGENCY,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTROL_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTROL_WATER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTROL_WEATHER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CONTROL_WINDS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CREATE_FOOD_AND_WATER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CREATE_WATER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_CURSE_WATER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DAMAGE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DARKNESS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DARKVISION,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DAZE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DEAFEN,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_ANIMALS_PLANTS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_MAGIC,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_POISON,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_SCRYING,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_SECRET_DOORS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_SNARES_AND_PITS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_THOUGHTS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DETECT_UNDEAD,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DIMENSIONAL_ANCHOR,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DIMINISH,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DISCERN_LIES,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DISGUISE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DISINTEGRATE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_DISPEL_MAGIC,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ENTANGLE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_ETHEREAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_FASCINATE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_FEAR,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_GROW,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_HEAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_HOLD_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IDENTIFY,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IDENTIFY_CONDITION,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IMMUNITY_MAGIC_DEATH,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IMMUNITY_MAGIC_MIND_AFFECTING,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IMMUNITY_POISON,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_IMMUNITY_POSSESSION,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_INVISIBLE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_KILL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_KNOCKOUT,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_LEVITATE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_LIGHT_MAGICAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_LOCATE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_LOCK,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MARK,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MESSENGER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MISS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_ARMOR_CLASS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_ATTACK_ROLL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_ATTRIBUTE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_CHECK_ATTRIBUTE_ALL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_CHECK_ATTRIBUTE_CHARISMA,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_CHECK_SKILL_ALL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_DAMAGE_ROLL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_HP,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_LEVEL_CASTER,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_MORALE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_SAVE_ALL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_SAVE_FEAR,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_SAVE_REFLEX,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_MODIFIER_WEAPON_DAMAGE_ROLL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_PARALYSIS,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_POLYMORPH,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_RAISE_DEAD,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_RESISTANCE_SPELL_LAWFUL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SENSOR_AUDIAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SENSOR_VISUAL,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SLEEP,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SLOW,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_STUN,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SUGGESTION,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_SUMMON_CREATURE,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_TELEPORT,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_TELEPORT_INTERPLANAR,
  ::RPG_Magic_Spell_Effect_XMLTree_Type::SPELLEFFECT_TRIGGER_ALARM
};

// RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type
//

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type* RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::value RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_indexes_ + 25,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_indexes_ + 25 || _xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_[25] =
{
  "PHYSICALDAMAGE_NONE",
  "PHYSICALDAMAGE_BLUDGEONING",
  "PHYSICALDAMAGE_PIERCING",
  "PHYSICALDAMAGE_SLASHING",
  "PHYSICALDAMAGE_CRUSHING",
  "PHYSICALDAMAGE_WITHERING",
  "DESCRIPTOR_ACID",
  "DESCRIPTOR_AIR",
  "DESCRIPTOR_CHAOTIC",
  "DESCRIPTOR_COLD",
  "DESCRIPTOR_DARKNESS",
  "DESCRIPTOR_DEATH",
  "DESCRIPTOR_EARTH",
  "DESCRIPTOR_ELECTRICITY",
  "DESCRIPTOR_EVIL",
  "DESCRIPTOR_FEAR",
  "DESCRIPTOR_FIRE",
  "DESCRIPTOR_FORCE",
  "DESCRIPTOR_GOOD",
  "DESCRIPTOR_LANGUAGE_DEPENDENT",
  "DESCRIPTOR_LAWFUL",
  "DESCRIPTOR_LIGHT",
  "DESCRIPTOR_MIND_AFFECTING",
  "DESCRIPTOR_SONIC",
  "DESCRIPTOR_WATER"
};

const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::value RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_indexes_[25] =
{
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_ACID,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_AIR,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_CHAOTIC,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_COLD,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_DARKNESS,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_DEATH,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_EARTH,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_ELECTRICITY,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_EVIL,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_FEAR,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_FIRE,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_FORCE,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_GOOD,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_LANGUAGE_DEPENDENT,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_LAWFUL,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_LIGHT,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_MIND_AFFECTING,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_SONIC,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::DESCRIPTOR_WATER,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_BLUDGEONING,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_CRUSHING,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_NONE,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_PIERCING,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_SLASHING,
  ::RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::PHYSICALDAMAGE_WITHERING
};

// RPG_Magic_CheckTypeUnion_XMLTree_Type
//

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::
RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert ();
}

RPG_Magic_CheckTypeUnion_XMLTree_Type* RPG_Magic_CheckTypeUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_CheckTypeUnion_XMLTree_Type (*this, f, c);
}

RPG_Magic_CheckTypeUnion_XMLTree_Type::value RPG_Magic_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_indexes_ + 71,
                    *this,
                    c));

  if (i == _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_indexes_ + 71 || _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Magic_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[71] =
{
  "SKILL_APPRAISE",
  "SKILL_BALANCE",
  "SKILL_BLUFF",
  "SKILL_CLIMB",
  "SKILL_CONCENTRATION",
  "SKILL_CRAFT_ANY",
  "SKILL_CRAFT_ALL",
  "SKILL_CRAFT_ALCHEMY",
  "SKILL_CRAFT_FLETCHER",
  "SKILL_CRAFT_BOWYER",
  "SKILL_CRAFT_SMITH_ARMOR",
  "SKILL_CRAFT_SMITH_BLACK",
  "SKILL_CRAFT_SMITH_WEAPON",
  "SKILL_CRAFT_TRAP",
  "SKILL_CRAFT_OTHER",
  "SKILL_DECIPHER_SCRIPT",
  "SKILL_DIPLOMACY",
  "SKILL_DISABLE_DEVICE",
  "SKILL_DISGUISE",
  "SKILL_ESCAPE_ARTIST",
  "SKILL_FORGERY",
  "SKILL_GATHER_INFORMATION",
  "SKILL_HANDLE_ANIMAL",
  "SKILL_HEAL",
  "SKILL_HIDE",
  "SKILL_INTIMIDATE",
  "SKILL_JUMP",
  "SKILL_KNOWLEDGE_ANY",
  "SKILL_KNOWLEDGE_ALL",
  "SKILL_KNOWLEDGE_ARCANA",
  "SKILL_KNOWLEDGE_ARCHITECTURE_ENGINEERING",
  "SKILL_KNOWLEDGE_DUNGEONS",
  "SKILL_KNOWLEDGE_GEOGRAPHY",
  "SKILL_KNOWLEDGE_HISTORY",
  "SKILL_KNOWLEDGE_LOCAL",
  "SKILL_KNOWLEDGE_NATURE",
  "SKILL_KNOWLEDGE_NOBILITY_ROYALTY",
  "SKILL_KNOWLEDGE_RELIGION",
  "SKILL_KNOWLEDGE_PLANES",
  "SKILL_LISTEN",
  "SKILL_MOVE_SILENTLY",
  "SKILL_OPEN_LOCK",
  "SKILL_PERFORM",
  "SKILL_PROFESSION",
  "SKILL_RIDE",
  "SKILL_SEARCH",
  "SKILL_SENSE_MOTIVE",
  "SKILL_SLEIGHT_OF_HAND",
  "SKILL_SPEAK_LANGUAGE",
  "SKILL_SPELLCRAFT",
  "SKILL_SPOT",
  "SKILL_SURVIVAL",
  "SKILL_SWIM",
  "SKILL_TUMBLE",
  "SKILL_USE_MAGIC_DEVICE",
  "SKILL_USE_ROPE",
  "ATTRIBUTE_CHARISMA",
  "ATTRIBUTE_CONSTITUTION",
  "ATTRIBUTE_DEXTERITY",
  "ATTRIBUTE_INTELLIGENCE",
  "ATTRIBUTE_STRENGTH",
  "ATTRIBUTE_WISDOM",
  "ATTRIBUTE_ANY",
  "CHECK_CASTER_LEVEL",
  "CHECK_GRAPPLE",
  "CHECK_HIT_DICE",
  "SAVE_NONE",
  "SAVE_FORTITUDE",
  "SAVE_MAGIC",
  "SAVE_REFLEX",
  "SAVE_WILL"
};

const RPG_Magic_CheckTypeUnion_XMLTree_Type::value RPG_Magic_CheckTypeUnion_XMLTree_Type::
_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_indexes_[71] =
{
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_ANY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_CHARISMA,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_CONSTITUTION,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_DEXTERITY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_INTELLIGENCE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_STRENGTH,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::ATTRIBUTE_WISDOM,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::CHECK_CASTER_LEVEL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::CHECK_GRAPPLE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::CHECK_HIT_DICE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SAVE_FORTITUDE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SAVE_MAGIC,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SAVE_NONE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SAVE_REFLEX,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SAVE_WILL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_APPRAISE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_BALANCE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_BLUFF,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CLIMB,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CONCENTRATION,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ALCHEMY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ALL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_ANY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_BOWYER,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_FLETCHER,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_OTHER,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_ARMOR,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_BLACK,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_SMITH_WEAPON,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_CRAFT_TRAP,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_DECIPHER_SCRIPT,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_DIPLOMACY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_DISABLE_DEVICE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_DISGUISE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_ESCAPE_ARTIST,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_FORGERY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_GATHER_INFORMATION,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_HANDLE_ANIMAL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_HEAL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_HIDE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_INTIMIDATE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_JUMP,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ALL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ANY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ARCANA,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_ARCHITECTURE_ENGINEERING,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_DUNGEONS,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_GEOGRAPHY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_HISTORY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_LOCAL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_NATURE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_NOBILITY_ROYALTY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_PLANES,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_KNOWLEDGE_RELIGION,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_LISTEN,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_MOVE_SILENTLY,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_OPEN_LOCK,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_PERFORM,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_PROFESSION,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_RIDE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SEARCH,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SENSE_MOTIVE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SLEIGHT_OF_HAND,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SPEAK_LANGUAGE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SPELLCRAFT,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SPOT,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SURVIVAL,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_SWIM,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_TUMBLE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_USE_MAGIC_DEVICE,
  ::RPG_Magic_CheckTypeUnion_XMLTree_Type::SKILL_USE_ROPE
};

// RPG_Magic_Check_XMLTree_Type
//

RPG_Magic_Check_XMLTree_Type::
RPG_Magic_Check_XMLTree_Type ()
: ::xml_schema::type (),
  type_ (this),
  difficultyClass_ (this),
  modifier_ (this),
  levelIncrementMax_ (this),
  baseIsCasterLevel_ (baseIsCasterLevel_default_value (), this)
{
}

RPG_Magic_Check_XMLTree_Type::
RPG_Magic_Check_XMLTree_Type (const RPG_Magic_Check_XMLTree_Type& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  difficultyClass_ (x.difficultyClass_, f, this),
  modifier_ (x.modifier_, f, this),
  levelIncrementMax_ (x.levelIncrementMax_, f, this),
  baseIsCasterLevel_ (x.baseIsCasterLevel_, f, this)
{
}

RPG_Magic_Check_XMLTree_Type::
RPG_Magic_Check_XMLTree_Type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  difficultyClass_ (this),
  modifier_ (this),
  levelIncrementMax_ (this),
  baseIsCasterLevel_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Check_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!this->type_)
      {
        this->type_.set (r);
        continue;
      }
    }

    // difficultyClass
    //
    if (n.name () == "difficultyClass" && n.namespace_ () == "urn:rpg")
    {
      if (!this->difficultyClass_)
      {
        this->difficultyClass_.set (difficultyClass_traits::create (i, f, this));
        continue;
      }
    }

    // modifier
    //
    if (n.name () == "modifier" && n.namespace_ () == "urn:rpg")
    {
      if (!this->modifier_)
      {
        this->modifier_.set (modifier_traits::create (i, f, this));
        continue;
      }
    }

    // levelIncrementMax
    //
    if (n.name () == "levelIncrementMax" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrementMax_)
      {
        this->levelIncrementMax_.set (levelIncrementMax_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "baseIsCasterLevel" && n.namespace_ ().empty ())
    {
      this->baseIsCasterLevel_.set (baseIsCasterLevel_traits::create (i, f, this));
      continue;
    }
  }

  if (!baseIsCasterLevel_.present ())
  {
    this->baseIsCasterLevel_.set (baseIsCasterLevel_default_value ());
  }
}

RPG_Magic_Check_XMLTree_Type* RPG_Magic_Check_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Check_XMLTree_Type (*this, f, c);
}

RPG_Magic_Check_XMLTree_Type& RPG_Magic_Check_XMLTree_Type::
operator= (const RPG_Magic_Check_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->difficultyClass_ = x.difficultyClass_;
    this->modifier_ = x.modifier_;
    this->levelIncrementMax_ = x.levelIncrementMax_;
    this->baseIsCasterLevel_ = x.baseIsCasterLevel_;
  }

  return *this;
}

RPG_Magic_Check_XMLTree_Type::
~RPG_Magic_Check_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Check_XMLTree_Type& x, const RPG_Magic_Check_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.difficultyClass () == y.difficultyClass ()))
    return false;

  if (!(x.modifier () == y.modifier ()))
    return false;

  if (!(x.levelIncrementMax () == y.levelIncrementMax ()))
    return false;

  if (!(x.baseIsCasterLevel () == y.baseIsCasterLevel ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Check_XMLTree_Type& x, const RPG_Magic_Check_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_CounterMeasure_XMLTree_Type
//

const RPG_Magic_CounterMeasure_XMLTree_Type::reduction_type RPG_Magic_CounterMeasure_XMLTree_Type::reduction_default_value_ (
  "SAVEREDUCTION_NEGATES");

RPG_Magic_CounterMeasure_XMLTree_Type::
RPG_Magic_CounterMeasure_XMLTree_Type (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this),
  check_ (this),
  spell_ (this),
  reduction_ (reduction_default_value (), this)
{
}

RPG_Magic_CounterMeasure_XMLTree_Type::
RPG_Magic_CounterMeasure_XMLTree_Type (const RPG_Magic_CounterMeasure_XMLTree_Type& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  check_ (x.check_, f, this),
  spell_ (x.spell_, f, this),
  reduction_ (x.reduction_, f, this)
{
}

RPG_Magic_CounterMeasure_XMLTree_Type::
RPG_Magic_CounterMeasure_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  check_ (this),
  spell_ (this),
  reduction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_CounterMeasure_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // check
    //
    if (n.name () == "check" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< check_type > r (
        check_traits::create (i, f, this));

      if (!this->check_)
      {
        this->check_.set (r);
        continue;
      }
    }

    // spell
    //
    if (n.name () == "spell" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< spell_type > r (
        spell_traits::create (i, f, this));

      this->spell_.push_back (r);
      continue;
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "reduction" && n.namespace_ ().empty ())
    {
      this->reduction_.set (reduction_traits::create (i, f, this));
      continue;
    }
  }

  if (!reduction_.present ())
  {
    this->reduction_.set (reduction_default_value ());
  }
}

RPG_Magic_CounterMeasure_XMLTree_Type* RPG_Magic_CounterMeasure_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_CounterMeasure_XMLTree_Type (*this, f, c);
}

RPG_Magic_CounterMeasure_XMLTree_Type& RPG_Magic_CounterMeasure_XMLTree_Type::
operator= (const RPG_Magic_CounterMeasure_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->check_ = x.check_;
    this->spell_ = x.spell_;
    this->reduction_ = x.reduction_;
  }

  return *this;
}

RPG_Magic_CounterMeasure_XMLTree_Type::
~RPG_Magic_CounterMeasure_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_CounterMeasure_XMLTree_Type& x, const RPG_Magic_CounterMeasure_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.check () == y.check ()))
    return false;

  if (!(x.spell () == y.spell ()))
    return false;

  if (!(x.reduction () == y.reduction ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_CounterMeasure_XMLTree_Type& x, const RPG_Magic_CounterMeasure_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_EffectProperties_XMLTree_Type
//

RPG_Magic_Spell_EffectProperties_XMLTree_Type::
RPG_Magic_Spell_EffectProperties_XMLTree_Type (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this),
  damage_ (this),
  base_ (this),
  increment_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  attribute_ (this),
  domain_ (this),
  creature_ (this),
  duration_ (this),
  precondition_ (this),
  maxRange_ (this),
  counterMeasure_ (this),
  includeAdjacent_ (includeAdjacent_default_value (), this),
  incrementIsReciprocal_ (incrementIsReciprocal_default_value (), this)
{
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::
RPG_Magic_Spell_EffectProperties_XMLTree_Type (const RPG_Magic_Spell_EffectProperties_XMLTree_Type& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  damage_ (x.damage_, f, this),
  base_ (x.base_, f, this),
  increment_ (x.increment_, f, this),
  levelIncrement_ (x.levelIncrement_, f, this),
  levelIncrementMax_ (x.levelIncrementMax_, f, this),
  attribute_ (x.attribute_, f, this),
  domain_ (x.domain_, f, this),
  creature_ (x.creature_, f, this),
  duration_ (x.duration_, f, this),
  precondition_ (x.precondition_, f, this),
  maxRange_ (x.maxRange_, f, this),
  counterMeasure_ (x.counterMeasure_, f, this),
  includeAdjacent_ (x.includeAdjacent_, f, this),
  incrementIsReciprocal_ (x.incrementIsReciprocal_, f, this)
{
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::
RPG_Magic_Spell_EffectProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  damage_ (this),
  base_ (this),
  increment_ (this),
  levelIncrement_ (this),
  levelIncrementMax_ (this),
  attribute_ (this),
  domain_ (this),
  creature_ (this),
  duration_ (this),
  precondition_ (this),
  maxRange_ (this),
  counterMeasure_ (this),
  includeAdjacent_ (this),
  incrementIsReciprocal_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_EffectProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // damage
    //
    if (n.name () == "damage" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< damage_type > r (
        damage_traits::create (i, f, this));

      if (!this->damage_)
      {
        this->damage_.set (r);
        continue;
      }
    }

    // base
    //
    if (n.name () == "base" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< base_type > r (
        base_traits::create (i, f, this));

      if (!this->base_)
      {
        this->base_.set (r);
        continue;
      }
    }

    // increment
    //
    if (n.name () == "increment" && n.namespace_ () == "urn:rpg")
    {
      if (!this->increment_)
      {
        this->increment_.set (increment_traits::create (i, f, this));
        continue;
      }
    }

    // levelIncrement
    //
    if (n.name () == "levelIncrement" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< levelIncrement_type > r (
        levelIncrement_traits::create (i, f, this));

      if (!this->levelIncrement_)
      {
        this->levelIncrement_.set (r);
        continue;
      }
    }

    // levelIncrementMax
    //
    if (n.name () == "levelIncrementMax" && n.namespace_ () == "urn:rpg")
    {
      if (!this->levelIncrementMax_)
      {
        this->levelIncrementMax_.set (levelIncrementMax_traits::create (i, f, this));
        continue;
      }
    }

    // attribute
    //
    if (n.name () == "attribute" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< attribute_type > r (
        attribute_traits::create (i, f, this));

      if (!this->attribute_)
      {
        this->attribute_.set (r);
        continue;
      }
    }

    // domain
    //
    if (n.name () == "domain" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< domain_type > r (
        domain_traits::create (i, f, this));

      if (!this->domain_)
      {
        this->domain_.set (r);
        continue;
      }
    }

    // creature
    //
    if (n.name () == "creature" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< creature_type > r (
        creature_traits::create (i, f, this));

      if (!this->creature_)
      {
        this->creature_.set (r);
        continue;
      }
    }

    // duration
    //
    if (n.name () == "duration" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< duration_type > r (
        duration_traits::create (i, f, this));

      if (!this->duration_)
      {
        this->duration_.set (r);
        continue;
      }
    }

    // precondition
    //
    if (n.name () == "precondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< precondition_type > r (
        precondition_traits::create (i, f, this));

      this->precondition_.push_back (r);
      continue;
    }

    // maxRange
    //
    if (n.name () == "maxRange" && n.namespace_ () == "urn:rpg")
    {
      if (!this->maxRange_)
      {
        this->maxRange_.set (maxRange_traits::create (i, f, this));
        continue;
      }
    }

    // counterMeasure
    //
    if (n.name () == "counterMeasure" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< counterMeasure_type > r (
        counterMeasure_traits::create (i, f, this));

      this->counterMeasure_.push_back (r);
      continue;
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "includeAdjacent" && n.namespace_ ().empty ())
    {
      this->includeAdjacent_.set (includeAdjacent_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "incrementIsReciprocal" && n.namespace_ ().empty ())
    {
      this->incrementIsReciprocal_.set (incrementIsReciprocal_traits::create (i, f, this));
      continue;
    }
  }

  if (!includeAdjacent_.present ())
  {
    this->includeAdjacent_.set (includeAdjacent_default_value ());
  }

  if (!incrementIsReciprocal_.present ())
  {
    this->incrementIsReciprocal_.set (incrementIsReciprocal_default_value ());
  }
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type* RPG_Magic_Spell_EffectProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_EffectProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type& RPG_Magic_Spell_EffectProperties_XMLTree_Type::
operator= (const RPG_Magic_Spell_EffectProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->damage_ = x.damage_;
    this->base_ = x.base_;
    this->increment_ = x.increment_;
    this->levelIncrement_ = x.levelIncrement_;
    this->levelIncrementMax_ = x.levelIncrementMax_;
    this->attribute_ = x.attribute_;
    this->domain_ = x.domain_;
    this->creature_ = x.creature_;
    this->duration_ = x.duration_;
    this->precondition_ = x.precondition_;
    this->maxRange_ = x.maxRange_;
    this->counterMeasure_ = x.counterMeasure_;
    this->includeAdjacent_ = x.includeAdjacent_;
    this->incrementIsReciprocal_ = x.incrementIsReciprocal_;
  }

  return *this;
}

RPG_Magic_Spell_EffectProperties_XMLTree_Type::
~RPG_Magic_Spell_EffectProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_EffectProperties_XMLTree_Type& x, const RPG_Magic_Spell_EffectProperties_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.damage () == y.damage ()))
    return false;

  if (!(x.base () == y.base ()))
    return false;

  if (!(x.increment () == y.increment ()))
    return false;

  if (!(x.levelIncrement () == y.levelIncrement ()))
    return false;

  if (!(x.levelIncrementMax () == y.levelIncrementMax ()))
    return false;

  if (!(x.attribute () == y.attribute ()))
    return false;

  if (!(x.domain () == y.domain ()))
    return false;

  if (!(x.creature () == y.creature ()))
    return false;

  if (!(x.duration () == y.duration ()))
    return false;

  if (!(x.precondition () == y.precondition ()))
    return false;

  if (!(x.maxRange () == y.maxRange ()))
    return false;

  if (!(x.counterMeasure () == y.counterMeasure ()))
    return false;

  if (!(x.includeAdjacent () == y.includeAdjacent ()))
    return false;

  if (!(x.incrementIsReciprocal () == y.incrementIsReciprocal ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_EffectProperties_XMLTree_Type& x, const RPG_Magic_Spell_EffectProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Spell_PropertiesXML_XMLTree_Type
//

const RPG_Magic_Spell_PropertiesXML_XMLTree_Type::saveable_type RPG_Magic_Spell_PropertiesXML_XMLTree_Type::saveable_default_value_ (
  "SAVE_NONE");

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const name_type& name,
                                            const type_type& type,
                                            const time_type& time,
                                            const range_type& range,
                                            const duration_type& duration)
: ::xml_schema::type (),
  name_ (name, this),
  type_ (type, this),
  level_ (this),
  cost_ (this),
  time_ (time, this),
  range_ (range, this),
  target_ (this),
  duration_ (duration, this),
  precondition_ (this),
  effect_ (this),
  counterMeasure_ (this),
  saveable_ (saveable_default_value (), this),
  resistible_ (resistible_default_value (), this),
  effectsAreInclusive_ (effectsAreInclusive_default_value (), this)
{
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const name_type& name,
                                            ::std::auto_ptr< type_type > type,
                                            ::std::auto_ptr< time_type > time,
                                            ::std::auto_ptr< range_type > range,
                                            ::std::auto_ptr< duration_type > duration)
: ::xml_schema::type (),
  name_ (name, this),
  type_ (type, this),
  level_ (this),
  cost_ (this),
  time_ (time, this),
  range_ (range, this),
  target_ (this),
  duration_ (duration, this),
  precondition_ (this),
  effect_ (this),
  counterMeasure_ (this),
  saveable_ (saveable_default_value (), this),
  resistible_ (resistible_default_value (), this),
  effectsAreInclusive_ (effectsAreInclusive_default_value (), this)
{
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  type_ (x.type_, f, this),
  level_ (x.level_, f, this),
  cost_ (x.cost_, f, this),
  time_ (x.time_, f, this),
  range_ (x.range_, f, this),
  target_ (x.target_, f, this),
  duration_ (x.duration_, f, this),
  precondition_ (x.precondition_, f, this),
  effect_ (x.effect_, f, this),
  counterMeasure_ (x.counterMeasure_, f, this),
  saveable_ (x.saveable_, f, this),
  resistible_ (x.resistible_, f, this),
  effectsAreInclusive_ (x.effectsAreInclusive_, f, this)
{
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  type_ (this),
  level_ (this),
  cost_ (this),
  time_ (this),
  range_ (this),
  target_ (this),
  duration_ (this),
  precondition_ (this),
  effect_ (this),
  counterMeasure_ (this),
  saveable_ (this),
  resistible_ (this),
  effectsAreInclusive_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (r);
        continue;
      }
    }

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // level
    //
    if (n.name () == "level" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< level_type > r (
        level_traits::create (i, f, this));

      this->level_.push_back (r);
      continue;
    }

    // cost
    //
    if (n.name () == "cost" && n.namespace_ () == "urn:rpg")
    {
      if (!this->cost_)
      {
        this->cost_.set (cost_traits::create (i, f, this));
        continue;
      }
    }

    // time
    //
    if (n.name () == "time" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< time_type > r (
        time_traits::create (i, f, this));

      if (!time_.present ())
      {
        this->time_.set (r);
        continue;
      }
    }

    // range
    //
    if (n.name () == "range" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< range_type > r (
        range_traits::create (i, f, this));

      if (!range_.present ())
      {
        this->range_.set (r);
        continue;
      }
    }

    // target
    //
    if (n.name () == "target" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< target_type > r (
        target_traits::create (i, f, this));

      this->target_.push_back (r);
      continue;
    }

    // duration
    //
    if (n.name () == "duration" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< duration_type > r (
        duration_traits::create (i, f, this));

      if (!duration_.present ())
      {
        this->duration_.set (r);
        continue;
      }
    }

    // precondition
    //
    if (n.name () == "precondition" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< precondition_type > r (
        precondition_traits::create (i, f, this));

      this->precondition_.push_back (r);
      continue;
    }

    // effect
    //
    if (n.name () == "effect" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< effect_type > r (
        effect_traits::create (i, f, this));

      this->effect_.push_back (r);
      continue;
    }

    // counterMeasure
    //
    if (n.name () == "counterMeasure" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< counterMeasure_type > r (
        counterMeasure_traits::create (i, f, this));

      this->counterMeasure_.push_back (r);
      continue;
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "urn:rpg");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "time",
      "urn:rpg");
  }

  if (!range_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "range",
      "urn:rpg");
  }

  if (!duration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "duration",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "saveable" && n.namespace_ ().empty ())
    {
      this->saveable_.set (saveable_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "resistible" && n.namespace_ ().empty ())
    {
      this->resistible_.set (resistible_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "effectsAreInclusive" && n.namespace_ ().empty ())
    {
      this->effectsAreInclusive_.set (effectsAreInclusive_traits::create (i, f, this));
      continue;
    }
  }

  if (!saveable_.present ())
  {
    this->saveable_.set (saveable_default_value ());
  }

  if (!resistible_.present ())
  {
    this->resistible_.set (resistible_default_value ());
  }

  if (!effectsAreInclusive_.present ())
  {
    this->effectsAreInclusive_.set (effectsAreInclusive_default_value ());
  }
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type* RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Spell_PropertiesXML_XMLTree_Type (*this, f, c);
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type& RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
operator= (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->type_ = x.type_;
    this->level_ = x.level_;
    this->cost_ = x.cost_;
    this->time_ = x.time_;
    this->range_ = x.range_;
    this->target_ = x.target_;
    this->duration_ = x.duration_;
    this->precondition_ = x.precondition_;
    this->effect_ = x.effect_;
    this->counterMeasure_ = x.counterMeasure_;
    this->saveable_ = x.saveable_;
    this->resistible_ = x.resistible_;
    this->effectsAreInclusive_ = x.effectsAreInclusive_;
  }

  return *this;
}

RPG_Magic_Spell_PropertiesXML_XMLTree_Type::
~RPG_Magic_Spell_PropertiesXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& x, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& y)
{
  if (!(x.name () == y.name ()))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.level () == y.level ()))
    return false;

  if (!(x.cost () == y.cost ()))
    return false;

  if (!(x.time () == y.time ()))
    return false;

  if (!(x.range () == y.range ()))
    return false;

  if (!(x.target () == y.target ()))
    return false;

  if (!(x.duration () == y.duration ()))
    return false;

  if (!(x.precondition () == y.precondition ()))
    return false;

  if (!(x.effect () == y.effect ()))
    return false;

  if (!(x.counterMeasure () == y.counterMeasure ()))
    return false;

  if (!(x.saveable () == y.saveable ()))
    return false;

  if (!(x.resistible () == y.resistible ()))
    return false;

  if (!(x.effectsAreInclusive () == y.effectsAreInclusive ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& x, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_SpellLikeProperties_XMLTree_Type
//

RPG_Magic_SpellLikeProperties_XMLTree_Type::
RPG_Magic_SpellLikeProperties_XMLTree_Type (const type_type& type,
                                            const casterLevel_type& casterLevel)
: ::xml_schema::type (),
  type_ (type, this),
  casterLevel_ (casterLevel, this),
  duration_ (this),
  save_ (this)
{
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::
RPG_Magic_SpellLikeProperties_XMLTree_Type (const RPG_Magic_SpellLikeProperties_XMLTree_Type& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  casterLevel_ (x.casterLevel_, f, this),
  duration_ (x.duration_, f, this),
  save_ (x.save_, f, this)
{
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::
RPG_Magic_SpellLikeProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  casterLevel_ (this),
  duration_ (this),
  save_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Magic_SpellLikeProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // casterLevel
    //
    if (n.name () == "casterLevel" && n.namespace_ () == "urn:rpg")
    {
      if (!casterLevel_.present ())
      {
        this->casterLevel_.set (casterLevel_traits::create (i, f, this));
        continue;
      }
    }

    // duration
    //
    if (n.name () == "duration" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< duration_type > r (
        duration_traits::create (i, f, this));

      if (!this->duration_)
      {
        this->duration_.set (r);
        continue;
      }
    }

    // save
    //
    if (n.name () == "save" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< save_type > r (
        save_traits::create (i, f, this));

      if (!this->save_)
      {
        this->save_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!casterLevel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "casterLevel",
      "urn:rpg");
  }
}

RPG_Magic_SpellLikeProperties_XMLTree_Type* RPG_Magic_SpellLikeProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_SpellLikeProperties_XMLTree_Type (*this, f, c);
}

RPG_Magic_SpellLikeProperties_XMLTree_Type& RPG_Magic_SpellLikeProperties_XMLTree_Type::
operator= (const RPG_Magic_SpellLikeProperties_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->casterLevel_ = x.casterLevel_;
    this->duration_ = x.duration_;
    this->save_ = x.save_;
  }

  return *this;
}

RPG_Magic_SpellLikeProperties_XMLTree_Type::
~RPG_Magic_SpellLikeProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_SpellLikeProperties_XMLTree_Type& x, const RPG_Magic_SpellLikeProperties_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.casterLevel () == y.casterLevel ()))
    return false;

  if (!(x.duration () == y.duration ()))
    return false;

  if (!(x.save () == y.save ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_SpellLikeProperties_XMLTree_Type& x, const RPG_Magic_SpellLikeProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Magic_Dictionary_XMLTree_Type
//

RPG_Magic_Dictionary_XMLTree_Type::
RPG_Magic_Dictionary_XMLTree_Type ()
: ::xml_schema::type (),
  spell_ (this)
{
}

RPG_Magic_Dictionary_XMLTree_Type::
RPG_Magic_Dictionary_XMLTree_Type (const RPG_Magic_Dictionary_XMLTree_Type& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  spell_ (x.spell_, f, this)
{
}

RPG_Magic_Dictionary_XMLTree_Type::
RPG_Magic_Dictionary_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  spell_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RPG_Magic_Dictionary_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // spell
    //
    if (n.name () == "spell" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< spell_type > r (
        spell_traits::create (i, f, this));

      this->spell_.push_back (r);
      continue;
    }

    break;
  }
}

RPG_Magic_Dictionary_XMLTree_Type* RPG_Magic_Dictionary_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Magic_Dictionary_XMLTree_Type (*this, f, c);
}

RPG_Magic_Dictionary_XMLTree_Type& RPG_Magic_Dictionary_XMLTree_Type::
operator= (const RPG_Magic_Dictionary_XMLTree_Type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->spell_ = x.spell_;
  }

  return *this;
}

RPG_Magic_Dictionary_XMLTree_Type::
~RPG_Magic_Dictionary_XMLTree_Type ()
{
}

bool
operator== (const RPG_Magic_Dictionary_XMLTree_Type& x, const RPG_Magic_Dictionary_XMLTree_Type& y)
{
  if (!(x.spell () == y.spell ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Magic_Dictionary_XMLTree_Type& x, const RPG_Magic_Dictionary_XMLTree_Type& y)
{
  return !(x == y);
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_School_XMLTree_Type::value i)
{
  return o << RPG_Magic_School_XMLTree_Type::_xsd_RPG_Magic_School_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_School_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_SubSchool_XMLTree_Type::value i)
{
  return o << RPG_Magic_SubSchool_XMLTree_Type::_xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_SubSchool_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Descriptor_XMLTree_Type::value i)
{
  return o << RPG_Magic_Descriptor_XMLTree_Type::_xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Descriptor_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Domain_XMLTree_Type::value i)
{
  return o << RPG_Magic_Domain_XMLTree_Type::_xsd_RPG_Magic_Domain_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Domain_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_SpellType_XMLTree_Type::value i)
{
  return o << RPG_Magic_SpellType_XMLTree_Type::_xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_SpellType_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_AbilityClass_XMLTree_Type::value i)
{
  return o << RPG_Magic_AbilityClass_XMLTree_Type::_xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_AbilityClass_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_AbilityType_XMLTree_Type::value i)
{
  return o << RPG_Magic_AbilityType_XMLTree_Type::_xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_AbilityType_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Type_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "school: " << i.school ();
  if (i.subSchool ())
  {
    o << ::std::endl << "subSchool: " << *i.subSchool ();
  }

  for (RPG_Magic_Spell_Type_XMLTree_Type::descriptor_const_iterator
       b (i.descriptor ().begin ()), e (i.descriptor ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "descriptor: " << *b;
  }

  o << ::std::endl << "counterSpell: " << i.counterSpell ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_CasterClassUnion_XMLTree_Type::value i)
{
  return o << RPG_Magic_CasterClassUnion_XMLTree_Type::_xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_CasterClassUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Level_XMLTree_Type& i)
{
  o << ::std::endl << "casterClass: " << i.casterClass ();
  o << ::std::endl << "level: " << i.level ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_CastingTime_XMLTree_Type& i)
{
  if (i.rounds ())
  {
    o << ::std::endl << "rounds: " << *i.rounds ();
  }

  o << ::std::endl << "action: " << i.action ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_RangeEffect_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_RangeEffect_XMLTree_Type::_xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_RangeEffect_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_RangeProperties_XMLTree_Type& i)
{
  if (i.maximum ())
  {
    o << ::std::endl << "maximum: " << *i.maximum ();
  }

  if (i.increment ())
  {
    o << ::std::endl << "increment: " << *i.increment ();
  }

  o << ::std::endl << "effect: " << i.effect ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_Target_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_Target_XMLTree_Type::_xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Target_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::_xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_TargetProperties_XMLTree_Type& i)
{
  if (i.base ())
  {
    o << ::std::endl << "base: " << *i.base ();
  }

  if (i.levelIncrement ())
  {
    o << ::std::endl << "levelIncrement: " << *i.levelIncrement ();
  }

  if (i.levelIncrementMax ())
  {
    o << ::std::endl << "levelIncrementMax: " << *i.levelIncrementMax ();
  }

  if (i.effect ())
  {
    o << ::std::endl << "effect: " << *i.effect ();
  }

  if (i.shape ())
  {
    o << ::std::endl << "shape: " << *i.shape ();
  }

  if (i.radius ())
  {
    o << ::std::endl << "radius: " << *i.radius ();
  }

  if (i.height ())
  {
    o << ::std::endl << "height: " << *i.height ();
  }

  o << ::std::endl << "target: " << i.target ();
  o << ::std::endl << "shapeable: " << i.shapeable ();
  o << ::std::endl << "rangeIsInHD: " << i.rangeIsInHD ();
  o << ::std::endl << "incrementIsReciprocal: " << i.incrementIsReciprocal ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_Duration_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_Duration_XMLTree_Type::_xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Duration_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_DurationProperties_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Common_EffectDuration_XMLTree_Type& > (i);

  o << ::std::endl << "duration: " << i.duration ();
  o << ::std::endl << "dismissible: " << i.dismissible ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_Precondition_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_Precondition_XMLTree_Type::_xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Precondition_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  if (i.value ())
  {
    o << ::std::endl << "value: " << *i.value ();
  }

  if (i.levelIncrement ())
  {
    o << ::std::endl << "levelIncrement: " << *i.levelIncrement ();
  }

  if (i.levelIncrementMax ())
  {
    o << ::std::endl << "levelIncrementMax: " << *i.levelIncrementMax ();
  }

  if (i.alignment ())
  {
    o << ::std::endl << "alignment: " << *i.alignment ();
  }

  if (i.attribute ())
  {
    o << ::std::endl << "attribute: " << *i.attribute ();
  }

  if (i.condition ())
  {
    o << ::std::endl << "condition: " << *i.condition ();
  }

  for (RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::creature_const_iterator
       b (i.creature ().begin ()), e (i.creature ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "creature: " << *b;
  }

  if (i.size ())
  {
    o << ::std::endl << "size: " << *i.size ();
  }

  if (i.environment ())
  {
    o << ::std::endl << "environment: " << *i.environment ();
  }

  o << ::std::endl << "reverse: " << i.reverse ();
  o << ::std::endl << "baseIsCasterLevel: " << i.baseIsCasterLevel ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_Effect_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_Effect_XMLTree_Type::_xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_Effect_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::value i)
{
  return o << RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type::_xsd_RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Magic_CheckTypeUnion_XMLTree_Type::value i)
{
  return o << RPG_Magic_CheckTypeUnion_XMLTree_Type::_xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_CheckTypeUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Check_XMLTree_Type& i)
{
  if (i.type ())
  {
    o << ::std::endl << "type: " << *i.type ();
  }

  if (i.difficultyClass ())
  {
    o << ::std::endl << "difficultyClass: " << *i.difficultyClass ();
  }

  if (i.modifier ())
  {
    o << ::std::endl << "modifier: " << *i.modifier ();
  }

  if (i.levelIncrementMax ())
  {
    o << ::std::endl << "levelIncrementMax: " << *i.levelIncrementMax ();
  }

  o << ::std::endl << "baseIsCasterLevel: " << i.baseIsCasterLevel ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_CounterMeasure_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  if (i.check ())
  {
    o << ::std::endl << "check: " << *i.check ();
  }

  for (RPG_Magic_CounterMeasure_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), e (i.spell ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "spell: " << *b;
  }

  o << ::std::endl << "reduction: " << i.reduction ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_EffectProperties_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  if (i.damage ())
  {
    o << ::std::endl << "damage: " << *i.damage ();
  }

  if (i.base ())
  {
    o << ::std::endl << "base: " << *i.base ();
  }

  if (i.increment ())
  {
    o << ::std::endl << "increment: " << *i.increment ();
  }

  if (i.levelIncrement ())
  {
    o << ::std::endl << "levelIncrement: " << *i.levelIncrement ();
  }

  if (i.levelIncrementMax ())
  {
    o << ::std::endl << "levelIncrementMax: " << *i.levelIncrementMax ();
  }

  if (i.attribute ())
  {
    o << ::std::endl << "attribute: " << *i.attribute ();
  }

  if (i.domain ())
  {
    o << ::std::endl << "domain: " << *i.domain ();
  }

  if (i.creature ())
  {
    o << ::std::endl << "creature: " << *i.creature ();
  }

  if (i.duration ())
  {
    o << ::std::endl << "duration: " << *i.duration ();
  }

  for (RPG_Magic_Spell_EffectProperties_XMLTree_Type::precondition_const_iterator
       b (i.precondition ().begin ()), e (i.precondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "precondition: " << *b;
  }

  if (i.maxRange ())
  {
    o << ::std::endl << "maxRange: " << *i.maxRange ();
  }

  for (RPG_Magic_Spell_EffectProperties_XMLTree_Type::counterMeasure_const_iterator
       b (i.counterMeasure ().begin ()), e (i.counterMeasure ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "counterMeasure: " << *b;
  }

  o << ::std::endl << "includeAdjacent: " << i.includeAdjacent ();
  o << ::std::endl << "incrementIsReciprocal: " << i.incrementIsReciprocal ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "type: " << i.type ();
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::level_const_iterator
       b (i.level ().begin ()), e (i.level ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "level: " << *b;
  }

  if (i.cost ())
  {
    o << ::std::endl << "cost: " << *i.cost ();
  }

  o << ::std::endl << "time: " << i.time ();
  o << ::std::endl << "range: " << i.range ();
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::target_const_iterator
       b (i.target ().begin ()), e (i.target ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "target: " << *b;
  }

  o << ::std::endl << "duration: " << i.duration ();
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::precondition_const_iterator
       b (i.precondition ().begin ()), e (i.precondition ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "precondition: " << *b;
  }

  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effect_const_iterator
       b (i.effect ().begin ()), e (i.effect ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "effect: " << *b;
  }

  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::counterMeasure_const_iterator
       b (i.counterMeasure ().begin ()), e (i.counterMeasure ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "counterMeasure: " << *b;
  }

  o << ::std::endl << "saveable: " << i.saveable ();
  o << ::std::endl << "resistible: " << i.resistible ();
  o << ::std::endl << "effectsAreInclusive: " << i.effectsAreInclusive ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_SpellLikeProperties_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "casterLevel: " << i.casterLevel ();
  if (i.duration ())
  {
    o << ::std::endl << "duration: " << *i.duration ();
  }

  if (i.save ())
  {
    o << ::std::endl << "save: " << *i.save ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Magic_Dictionary_XMLTree_Type& i)
{
  for (RPG_Magic_Dictionary_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), e (i.spell ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "spell: " << *b;
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spellDictionary (isrc, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spellDictionary (isrc, h, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spellDictionary (isrc, h, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spellDictionary (isrc, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spellDictionary (isrc, h, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spellDictionary (isrc, h, f, p);
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
    ::spellDictionary (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > (
      ::spellDictionary (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spellDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > r (
      ::xsd::cxx::tree::traits< ::RPG_Magic_Dictionary_XMLTree_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spellDictionary",
    "urn:rpg");
}

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "spellDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    ::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type > r (
      ::xsd::cxx::tree::traits< ::RPG_Magic_Dictionary_XMLTree_Type, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spellDictionary",
    "urn:rpg");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_School_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_School_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_School_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_SubSchool_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_SubSchool_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_SubSchool_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Descriptor_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Descriptor_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Descriptor_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Domain_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Domain_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Domain_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_SpellType_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_SpellType_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_SpellType_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_AbilityClass_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_AbilityClass_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_AbilityClass_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_AbilityType_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_AbilityType_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_AbilityType_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Type_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // school
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "school",
        "urn:rpg",
        e));

    s << i.school ();
  }

  // subSchool
  //
  if (i.subSchool ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subSchool",
        "urn:rpg",
        e));

    s << *i.subSchool ();
  }

  // descriptor
  //
  for (RPG_Magic_Spell_Type_XMLTree_Type::descriptor_const_iterator
       b (i.descriptor ().begin ()), n (i.descriptor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "descriptor",
        "urn:rpg",
        e));

    s << *b;
  }

  // counterSpell
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "counterSpell",
        e));

    a << i.counterSpell ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_CasterClassUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_CasterClassUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_CasterClassUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Level_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // casterClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "casterClass",
        "urn:rpg",
        e));

    s << i.casterClass ();
  }

  // level
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "level",
        "urn:rpg",
        e));

    s << i.level ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_CastingTime_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // rounds
  //
  if (i.rounds ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rounds",
        "urn:rpg",
        e));

    s << *i.rounds ();
  }

  // action
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "action",
        e));

    a << i.action ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_RangeEffect_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_RangeEffect_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_RangeEffect_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_RangeProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // maximum
  //
  if (i.maximum ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maximum",
        "urn:rpg",
        e));

    s << *i.maximum ();
  }

  // increment
  //
  if (i.increment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "increment",
        "urn:rpg",
        e));

    s << *i.increment ();
  }

  // effect
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "effect",
        e));

    a << i.effect ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Target_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_Target_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_Target_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_TargetProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // base
  //
  if (i.base ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "base",
        "urn:rpg",
        e));

    s << *i.base ();
  }

  // levelIncrement
  //
  if (i.levelIncrement ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrement",
        "urn:rpg",
        e));

    s << *i.levelIncrement ();
  }

  // levelIncrementMax
  //
  if (i.levelIncrementMax ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrementMax",
        "urn:rpg",
        e));

    s << *i.levelIncrementMax ();
  }

  // effect
  //
  if (i.effect ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "effect",
        "urn:rpg",
        e));

    s << *i.effect ();
  }

  // shape
  //
  if (i.shape ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shape",
        "urn:rpg",
        e));

    s << *i.shape ();
  }

  // radius
  //
  if (i.radius ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        "urn:rpg",
        e));

    s << *i.radius ();
  }

  // height
  //
  if (i.height ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "height",
        "urn:rpg",
        e));

    s << *i.height ();
  }

  // target
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "target",
        e));

    a << i.target ();
  }

  // shapeable
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "shapeable",
        e));

    a << i.shapeable ();
  }

  // rangeIsInHD
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rangeIsInHD",
        e));

    a << i.rangeIsInHD ();
  }

  // incrementIsReciprocal
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "incrementIsReciprocal",
        e));

    a << i.incrementIsReciprocal ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Duration_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_Duration_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_Duration_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_DurationProperties_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Common_EffectDuration_XMLTree_Type& > (i);

  // duration
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "duration",
        e));

    a << i.duration ();
  }

  // dismissible
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dismissible",
        e));

    a << i.dismissible ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Precondition_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_Precondition_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_Precondition_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // value
  //
  if (i.value ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        "urn:rpg",
        e));

    s << *i.value ();
  }

  // levelIncrement
  //
  if (i.levelIncrement ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrement",
        "urn:rpg",
        e));

    s << *i.levelIncrement ();
  }

  // levelIncrementMax
  //
  if (i.levelIncrementMax ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrementMax",
        "urn:rpg",
        e));

    s << *i.levelIncrementMax ();
  }

  // alignment
  //
  if (i.alignment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "alignment",
        "urn:rpg",
        e));

    s << *i.alignment ();
  }

  // attribute
  //
  if (i.attribute ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attribute",
        "urn:rpg",
        e));

    s << *i.attribute ();
  }

  // condition
  //
  if (i.condition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "condition",
        "urn:rpg",
        e));

    s << *i.condition ();
  }

  // creature
  //
  for (RPG_Magic_Spell_PreconditionProperties_XMLTree_Type::creature_const_iterator
       b (i.creature ().begin ()), n (i.creature ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "creature",
        "urn:rpg",
        e));

    s << *b;
  }

  // size
  //
  if (i.size ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "size",
        "urn:rpg",
        e));

    s << *i.size ();
  }

  // environment
  //
  if (i.environment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "environment",
        "urn:rpg",
        e));

    s << *i.environment ();
  }

  // reverse
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reverse",
        e));

    a << i.reverse ();
  }

  // baseIsCasterLevel
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "baseIsCasterLevel",
        e));

    a << i.baseIsCasterLevel ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_Effect_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_Effect_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_Effect_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_Spell_DamageTypeUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_CheckTypeUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Magic_CheckTypeUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Magic_CheckTypeUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Check_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  if (i.type ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << *i.type ();
  }

  // difficultyClass
  //
  if (i.difficultyClass ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "difficultyClass",
        "urn:rpg",
        e));

    s << *i.difficultyClass ();
  }

  // modifier
  //
  if (i.modifier ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "modifier",
        "urn:rpg",
        e));

    s << *i.modifier ();
  }

  // levelIncrementMax
  //
  if (i.levelIncrementMax ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrementMax",
        "urn:rpg",
        e));

    s << *i.levelIncrementMax ();
  }

  // baseIsCasterLevel
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "baseIsCasterLevel",
        e));

    a << i.baseIsCasterLevel ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_CounterMeasure_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // check
  //
  if (i.check ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "check",
        "urn:rpg",
        e));

    s << *i.check ();
  }

  // spell
  //
  for (RPG_Magic_CounterMeasure_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), n (i.spell ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spell",
        "urn:rpg",
        e));

    s << *b;
  }

  // reduction
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reduction",
        e));

    a << i.reduction ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_EffectProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // damage
  //
  if (i.damage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damage",
        "urn:rpg",
        e));

    s << *i.damage ();
  }

  // base
  //
  if (i.base ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "base",
        "urn:rpg",
        e));

    s << *i.base ();
  }

  // increment
  //
  if (i.increment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "increment",
        "urn:rpg",
        e));

    s << *i.increment ();
  }

  // levelIncrement
  //
  if (i.levelIncrement ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrement",
        "urn:rpg",
        e));

    s << *i.levelIncrement ();
  }

  // levelIncrementMax
  //
  if (i.levelIncrementMax ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "levelIncrementMax",
        "urn:rpg",
        e));

    s << *i.levelIncrementMax ();
  }

  // attribute
  //
  if (i.attribute ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "attribute",
        "urn:rpg",
        e));

    s << *i.attribute ();
  }

  // domain
  //
  if (i.domain ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domain",
        "urn:rpg",
        e));

    s << *i.domain ();
  }

  // creature
  //
  if (i.creature ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "creature",
        "urn:rpg",
        e));

    s << *i.creature ();
  }

  // duration
  //
  if (i.duration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "duration",
        "urn:rpg",
        e));

    s << *i.duration ();
  }

  // precondition
  //
  for (RPG_Magic_Spell_EffectProperties_XMLTree_Type::precondition_const_iterator
       b (i.precondition ().begin ()), n (i.precondition ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "precondition",
        "urn:rpg",
        e));

    s << *b;
  }

  // maxRange
  //
  if (i.maxRange ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxRange",
        "urn:rpg",
        e));

    s << *i.maxRange ();
  }

  // counterMeasure
  //
  for (RPG_Magic_Spell_EffectProperties_XMLTree_Type::counterMeasure_const_iterator
       b (i.counterMeasure ().begin ()), n (i.counterMeasure ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "counterMeasure",
        "urn:rpg",
        e));

    s << *b;
  }

  // includeAdjacent
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "includeAdjacent",
        e));

    a << i.includeAdjacent ();
  }

  // incrementIsReciprocal
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "incrementIsReciprocal",
        e));

    a << i.incrementIsReciprocal ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        "urn:rpg",
        e));

    s << i.name ();
  }

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // level
  //
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::level_const_iterator
       b (i.level ().begin ()), n (i.level ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "level",
        "urn:rpg",
        e));

    s << *b;
  }

  // cost
  //
  if (i.cost ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cost",
        "urn:rpg",
        e));

    s << *i.cost ();
  }

  // time
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "time",
        "urn:rpg",
        e));

    s << i.time ();
  }

  // range
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "range",
        "urn:rpg",
        e));

    s << i.range ();
  }

  // target
  //
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::target_const_iterator
       b (i.target ().begin ()), n (i.target ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "target",
        "urn:rpg",
        e));

    s << *b;
  }

  // duration
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "duration",
        "urn:rpg",
        e));

    s << i.duration ();
  }

  // precondition
  //
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::precondition_const_iterator
       b (i.precondition ().begin ()), n (i.precondition ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "precondition",
        "urn:rpg",
        e));

    s << *b;
  }

  // effect
  //
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::effect_const_iterator
       b (i.effect ().begin ()), n (i.effect ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "effect",
        "urn:rpg",
        e));

    s << *b;
  }

  // counterMeasure
  //
  for (RPG_Magic_Spell_PropertiesXML_XMLTree_Type::counterMeasure_const_iterator
       b (i.counterMeasure ().begin ()), n (i.counterMeasure ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "counterMeasure",
        "urn:rpg",
        e));

    s << *b;
  }

  // saveable
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "saveable",
        e));

    a << i.saveable ();
  }

  // resistible
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "resistible",
        e));

    a << i.resistible ();
  }

  // effectsAreInclusive
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "effectsAreInclusive",
        e));

    a << i.effectsAreInclusive ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_SpellLikeProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // casterLevel
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "casterLevel",
        "urn:rpg",
        e));

    s << i.casterLevel ();
  }

  // duration
  //
  if (i.duration ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "duration",
        "urn:rpg",
        e));

    s << *i.duration ();
  }

  // save
  //
  if (i.save ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "save",
        "urn:rpg",
        e));

    s << *i.save ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Magic_Dictionary_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // spell
  //
  for (RPG_Magic_Dictionary_XMLTree_Type::spell_const_iterator
       b (i.spell ().begin ()), n (i.spell ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spell",
        "urn:rpg",
        e));

    s << *b;
  }
}

void
spellDictionary (::std::ostream& o,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spellDictionary (::std::ostream& o,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spellDictionary (::std::ostream& o,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spellDictionary (::xercesc::XMLFormatTarget& t,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spellDictionary (::xercesc::XMLFormatTarget& t,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spellDictionary (::xercesc::XMLFormatTarget& t,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spellDictionary (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spellDictionary (::xercesc::DOMDocument& d,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spellDictionary" &&
      n.namespace_ () == "urn:rpg")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "spellDictionary",
      "urn:rpg");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
spellDictionary (const ::RPG_Magic_Dictionary_XMLTree_Type& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "spellDictionary",
      "urn:rpg",
      m, f));

  ::spellDictionary (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

