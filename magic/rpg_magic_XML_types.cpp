// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_magic_XML_types.h"

// RPG_Magic_Spell_Type_Type_pskel
//

void RPG_Magic_Spell_Type_Type_pskel::
type_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
school_parser (::RPG_Magic_School_Type_pskel& p)
{
  this->school_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
subSchool_parser (::RPG_Magic_SubSchool_Type_pskel& p)
{
  this->subSchool_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
descriptor_parser (::RPG_Magic_Descriptor_Type_pskel& p)
{
  this->descriptor_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
counterSpell_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->counterSpell_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
parsers (::RPG_Magic_SpellType_Type_pskel& type,
         ::RPG_Magic_School_Type_pskel& school,
         ::RPG_Magic_SubSchool_Type_pskel& subSchool,
         ::RPG_Magic_Descriptor_Type_pskel& descriptor,
         ::RPG_Magic_SpellType_Type_pskel& counterSpell)
{
  this->type_parser_ = &type;
  this->school_parser_ = &school;
  this->subSchool_parser_ = &subSchool;
  this->descriptor_parser_ = &descriptor;
  this->counterSpell_parser_ = &counterSpell;
}

RPG_Magic_Spell_Type_Type_pskel::
RPG_Magic_Spell_Type_Type_pskel ()
: type_parser_ (0),
  school_parser_ (0),
  subSchool_parser_ (0),
  descriptor_parser_ (0),
  counterSpell_parser_ (0)
{
}

// RPG_Magic_Spell_Level_Type_pskel
//

void RPG_Magic_Spell_Level_Type_pskel::
casterClass_parser (::RPG_Magic_CasterClassUnion_Type_pskel& p)
{
  this->casterClass_parser_ = &p;
}

void RPG_Magic_Spell_Level_Type_pskel::
level_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->level_parser_ = &p;
}

void RPG_Magic_Spell_Level_Type_pskel::
parsers (::RPG_Magic_CasterClassUnion_Type_pskel& casterClass,
         ::xml_schema::unsigned_byte_pskel& level)
{
  this->casterClass_parser_ = &casterClass;
  this->level_parser_ = &level;
}

RPG_Magic_Spell_Level_Type_pskel::
RPG_Magic_Spell_Level_Type_pskel ()
: casterClass_parser_ (0),
  level_parser_ (0)
{
}

// RPG_Magic_Spell_CastingTime_Type_pskel
//

void RPG_Magic_Spell_CastingTime_Type_pskel::
rounds_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->rounds_parser_ = &p;
}

void RPG_Magic_Spell_CastingTime_Type_pskel::
action_parser (::RPG_Common_ActionType_Type_pskel& p)
{
  this->action_parser_ = &p;
}

void RPG_Magic_Spell_CastingTime_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& rounds,
         ::RPG_Common_ActionType_Type_pskel& action)
{
  this->rounds_parser_ = &rounds;
  this->action_parser_ = &action;
}

RPG_Magic_Spell_CastingTime_Type_pskel::
RPG_Magic_Spell_CastingTime_Type_pskel ()
: rounds_parser_ (0),
  action_parser_ (0)
{
}

// RPG_Magic_Spell_RangeProperties_Type_pskel
//

void RPG_Magic_Spell_RangeProperties_Type_pskel::
max_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->max_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
increment_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->increment_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
effect_parser (::RPG_Magic_Spell_RangeEffect_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& max,
         ::xml_schema::unsigned_int_pskel& increment,
         ::RPG_Magic_Spell_RangeEffect_Type_pskel& effect)
{
  this->max_parser_ = &max;
  this->increment_parser_ = &increment;
  this->effect_parser_ = &effect;
}

RPG_Magic_Spell_RangeProperties_Type_pskel::
RPG_Magic_Spell_RangeProperties_Type_pskel ()
: max_parser_ (0),
  increment_parser_ (0),
  effect_parser_ (0)
{
}

// RPG_Magic_Spell_TargetProperties_Type_pskel
//

void RPG_Magic_Spell_TargetProperties_Type_pskel::
base_parser (::RPG_Common_Amount_Type_pskel& p)
{
  this->base_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrement_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
effect_parser (::RPG_Magic_Spell_AreaOfEffect_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
shape_parser (::RPG_Common_AreaOfEffect_Type_pskel& p)
{
  this->shape_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
radius_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->radius_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
height_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->height_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
target_parser (::RPG_Magic_Spell_Target_Type_pskel& p)
{
  this->target_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
shapeable_parser (::xml_schema::boolean_pskel& p)
{
  this->shapeable_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
rangeIsInHD_parser (::xml_schema::boolean_pskel& p)
{
  this->rangeIsInHD_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
incrementIsReciprocal_parser (::xml_schema::boolean_pskel& p)
{
  this->incrementIsReciprocal_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
parsers (::RPG_Common_Amount_Type_pskel& base,
         ::xml_schema::unsigned_byte_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Magic_Spell_AreaOfEffect_Type_pskel& effect,
         ::RPG_Common_AreaOfEffect_Type_pskel& shape,
         ::xml_schema::unsigned_int_pskel& radius,
         ::xml_schema::unsigned_int_pskel& height,
         ::RPG_Magic_Spell_Target_Type_pskel& target,
         ::xml_schema::boolean_pskel& shapeable,
         ::xml_schema::boolean_pskel& rangeIsInHD,
         ::xml_schema::boolean_pskel& incrementIsReciprocal)
{
  this->base_parser_ = &base;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->effect_parser_ = &effect;
  this->shape_parser_ = &shape;
  this->radius_parser_ = &radius;
  this->height_parser_ = &height;
  this->target_parser_ = &target;
  this->shapeable_parser_ = &shapeable;
  this->rangeIsInHD_parser_ = &rangeIsInHD;
  this->incrementIsReciprocal_parser_ = &incrementIsReciprocal;
}

RPG_Magic_Spell_TargetProperties_Type_pskel::
RPG_Magic_Spell_TargetProperties_Type_pskel ()
: base_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  effect_parser_ (0),
  shape_parser_ (0),
  radius_parser_ (0),
  height_parser_ (0),
  target_parser_ (0),
  shapeable_parser_ (0),
  rangeIsInHD_parser_ (0),
  incrementIsReciprocal_parser_ (0)
{
}

// RPG_Magic_Spell_DurationProperties_Type_pskel
//

void RPG_Magic_Spell_DurationProperties_Type_pskel::
duration_parser (::RPG_Magic_Spell_Duration_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
dismissible_parser (::xml_schema::boolean_pskel& p)
{
  this->dismissible_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
parsers (::RPG_Common_Amount_Type_pskel& base,
         ::xml_schema::byte_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::xml_schema::unsigned_byte_pskel& reciprocalIncrement,
         ::xml_schema::boolean_pskel& isMaxDelay,
         ::xml_schema::boolean_pskel& incrementIsInHD,
         ::RPG_Magic_Spell_Duration_Type_pskel& duration,
         ::xml_schema::boolean_pskel& dismissible)
{
  this->base_parser_ = &base;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->reciprocalIncrement_parser_ = &reciprocalIncrement;
  this->isMaxDelay_parser_ = &isMaxDelay;
  this->incrementIsInHD_parser_ = &incrementIsInHD;
  this->duration_parser_ = &duration;
  this->dismissible_parser_ = &dismissible;
}

RPG_Magic_Spell_DurationProperties_Type_pskel::
RPG_Magic_Spell_DurationProperties_Type_pskel ()
: duration_parser_ (0),
  dismissible_parser_ (0)
{
}

// RPG_Magic_Spell_PreconditionProperties_Type_pskel
//

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Precondition_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
value_parser (::xml_schema::int_pskel& p)
{
  this->value_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrement_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
alignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->alignment_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
attribute_parser (::RPG_Common_Attribute_Type_pskel& p)
{
  this->attribute_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
condition_parser (::RPG_Common_Condition_Type_pskel& p)
{
  this->condition_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
creature_parser (::RPG_Common_CreatureType_Type_pskel& p)
{
  this->creature_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
size_parser (::RPG_Common_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
environment_parser (::RPG_Common_Environment_Type_pskel& p)
{
  this->environment_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
reverse_parser (::xml_schema::boolean_pskel& p)
{
  this->reverse_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
baseIsCasterLevel_parser (::xml_schema::boolean_pskel& p)
{
  this->baseIsCasterLevel_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Precondition_Type_pskel& type,
         ::xml_schema::int_pskel& value,
         ::xml_schema::unsigned_byte_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Character_Alignment_Type_pskel& alignment,
         ::RPG_Common_Attribute_Type_pskel& attribute,
         ::RPG_Common_Condition_Type_pskel& condition,
         ::RPG_Common_CreatureType_Type_pskel& creature,
         ::RPG_Common_Size_Type_pskel& size,
         ::RPG_Common_Environment_Type_pskel& environment,
         ::xml_schema::boolean_pskel& reverse,
         ::xml_schema::boolean_pskel& baseIsCasterLevel)
{
  this->type_parser_ = &type;
  this->value_parser_ = &value;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->alignment_parser_ = &alignment;
  this->attribute_parser_ = &attribute;
  this->condition_parser_ = &condition;
  this->creature_parser_ = &creature;
  this->size_parser_ = &size;
  this->environment_parser_ = &environment;
  this->reverse_parser_ = &reverse;
  this->baseIsCasterLevel_parser_ = &baseIsCasterLevel;
}

RPG_Magic_Spell_PreconditionProperties_Type_pskel::
RPG_Magic_Spell_PreconditionProperties_Type_pskel ()
: type_parser_ (0),
  value_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  alignment_parser_ (0),
  attribute_parser_ (0),
  condition_parser_ (0),
  creature_parser_ (0),
  size_parser_ (0),
  environment_parser_ (0),
  reverse_parser_ (0),
  baseIsCasterLevel_parser_ (0)
{
}

// RPG_Magic_Check_Type_pskel
//

void RPG_Magic_Check_Type_pskel::
type_parser (::RPG_Magic_CheckTypeUnion_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
difficultyClass_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->difficultyClass_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
modifier_parser (::xml_schema::byte_pskel& p)
{
  this->modifier_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
baseIsCasterLevel_parser (::xml_schema::boolean_pskel& p)
{
  this->baseIsCasterLevel_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
parsers (::RPG_Magic_CheckTypeUnion_Type_pskel& type,
         ::xml_schema::unsigned_byte_pskel& difficultyClass,
         ::xml_schema::byte_pskel& modifier,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::xml_schema::boolean_pskel& baseIsCasterLevel)
{
  this->type_parser_ = &type;
  this->difficultyClass_parser_ = &difficultyClass;
  this->modifier_parser_ = &modifier;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->baseIsCasterLevel_parser_ = &baseIsCasterLevel;
}

RPG_Magic_Check_Type_pskel::
RPG_Magic_Check_Type_pskel ()
: type_parser_ (0),
  difficultyClass_parser_ (0),
  modifier_parser_ (0),
  levelIncrementMax_parser_ (0),
  baseIsCasterLevel_parser_ (0)
{
}

// RPG_Magic_CounterMeasure_Type_pskel
//

void RPG_Magic_CounterMeasure_Type_pskel::
type_parser (::RPG_Common_CounterMeasure_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
check_parser (::RPG_Magic_Check_Type_pskel& p)
{
  this->check_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
spell_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->spell_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
reduction_parser (::RPG_Common_SaveReductionType_Type_pskel& p)
{
  this->reduction_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
parsers (::RPG_Common_CounterMeasure_Type_pskel& type,
         ::RPG_Magic_Check_Type_pskel& check,
         ::RPG_Magic_SpellType_Type_pskel& spell,
         ::RPG_Common_SaveReductionType_Type_pskel& reduction)
{
  this->type_parser_ = &type;
  this->check_parser_ = &check;
  this->spell_parser_ = &spell;
  this->reduction_parser_ = &reduction;
}

RPG_Magic_CounterMeasure_Type_pskel::
RPG_Magic_CounterMeasure_Type_pskel ()
: type_parser_ (0),
  check_parser_ (0),
  spell_parser_ (0),
  reduction_parser_ (0)
{
}

// RPG_Magic_Spell_EffectProperties_Type_pskel
//

void RPG_Magic_Spell_EffectProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Effect_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
damage_parser (::RPG_Magic_Spell_DamageTypeUnion_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
base_parser (::RPG_Common_Amount_Type_pskel& p)
{
  this->base_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
increment_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->increment_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrement_parser (::RPG_Common_Amount_Type_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
attribute_parser (::RPG_Common_Attribute_Type_pskel& p)
{
  this->attribute_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
domain_parser (::RPG_Magic_Domain_Type_pskel& p)
{
  this->domain_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
creature_parser (::RPG_Common_CreatureType_Type_pskel& p)
{
  this->creature_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
duration_parser (::RPG_Common_EffectDuration_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
precondition_parser (::RPG_Magic_Spell_PreconditionProperties_Type_pskel& p)
{
  this->precondition_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
maxRange_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->maxRange_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
counterMeasure_parser (::RPG_Magic_CounterMeasure_Type_pskel& p)
{
  this->counterMeasure_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
includeAdjacent_parser (::xml_schema::boolean_pskel& p)
{
  this->includeAdjacent_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
incrementIsReciprocal_parser (::xml_schema::boolean_pskel& p)
{
  this->incrementIsReciprocal_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Effect_Type_pskel& type,
         ::RPG_Magic_Spell_DamageTypeUnion_Type_pskel& damage,
         ::RPG_Common_Amount_Type_pskel& base,
         ::xml_schema::unsigned_int_pskel& increment,
         ::RPG_Common_Amount_Type_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Common_Attribute_Type_pskel& attribute,
         ::RPG_Magic_Domain_Type_pskel& domain,
         ::RPG_Common_CreatureType_Type_pskel& creature,
         ::RPG_Common_EffectDuration_Type_pskel& duration,
         ::RPG_Magic_Spell_PreconditionProperties_Type_pskel& precondition,
         ::xml_schema::unsigned_byte_pskel& maxRange,
         ::RPG_Magic_CounterMeasure_Type_pskel& counterMeasure,
         ::xml_schema::boolean_pskel& includeAdjacent,
         ::xml_schema::boolean_pskel& incrementIsReciprocal)
{
  this->type_parser_ = &type;
  this->damage_parser_ = &damage;
  this->base_parser_ = &base;
  this->increment_parser_ = &increment;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->attribute_parser_ = &attribute;
  this->domain_parser_ = &domain;
  this->creature_parser_ = &creature;
  this->duration_parser_ = &duration;
  this->precondition_parser_ = &precondition;
  this->maxRange_parser_ = &maxRange;
  this->counterMeasure_parser_ = &counterMeasure;
  this->includeAdjacent_parser_ = &includeAdjacent;
  this->incrementIsReciprocal_parser_ = &incrementIsReciprocal;
}

RPG_Magic_Spell_EffectProperties_Type_pskel::
RPG_Magic_Spell_EffectProperties_Type_pskel ()
: type_parser_ (0),
  damage_parser_ (0),
  base_parser_ (0),
  increment_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  attribute_parser_ (0),
  domain_parser_ (0),
  creature_parser_ (0),
  duration_parser_ (0),
  precondition_parser_ (0),
  maxRange_parser_ (0),
  counterMeasure_parser_ (0),
  includeAdjacent_parser_ (0),
  incrementIsReciprocal_parser_ (0)
{
}

// RPG_Magic_Spell_PropertiesXML_Type_pskel
//

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
type_parser (::RPG_Magic_Spell_Type_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
level_parser (::RPG_Magic_Spell_Level_Type_pskel& p)
{
  this->level_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
cost_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->cost_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
time_parser (::RPG_Magic_Spell_CastingTime_Type_pskel& p)
{
  this->time_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
range_parser (::RPG_Magic_Spell_RangeProperties_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
target_parser (::RPG_Magic_Spell_TargetProperties_Type_pskel& p)
{
  this->target_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
duration_parser (::RPG_Magic_Spell_DurationProperties_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
precondition_parser (::RPG_Magic_Spell_PreconditionProperties_Type_pskel& p)
{
  this->precondition_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effect_parser (::RPG_Magic_Spell_EffectProperties_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
counterMeasure_parser (::RPG_Magic_CounterMeasure_Type_pskel& p)
{
  this->counterMeasure_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
saveable_parser (::RPG_Common_SavingThrow_Type_pskel& p)
{
  this->saveable_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
resistible_parser (::xml_schema::boolean_pskel& p)
{
  this->resistible_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effectsAreInclusive_parser (::xml_schema::boolean_pskel& p)
{
  this->effectsAreInclusive_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Magic_Spell_Type_Type_pskel& type,
         ::RPG_Magic_Spell_Level_Type_pskel& level,
         ::xml_schema::unsigned_int_pskel& cost,
         ::RPG_Magic_Spell_CastingTime_Type_pskel& time,
         ::RPG_Magic_Spell_RangeProperties_Type_pskel& range,
         ::RPG_Magic_Spell_TargetProperties_Type_pskel& target,
         ::RPG_Magic_Spell_DurationProperties_Type_pskel& duration,
         ::RPG_Magic_Spell_PreconditionProperties_Type_pskel& precondition,
         ::RPG_Magic_Spell_EffectProperties_Type_pskel& effect,
         ::RPG_Magic_CounterMeasure_Type_pskel& counterMeasure,
         ::RPG_Common_SavingThrow_Type_pskel& saveable,
         ::xml_schema::boolean_pskel& resistible,
         ::xml_schema::boolean_pskel& effectsAreInclusive)
{
  this->name_parser_ = &name;
  this->type_parser_ = &type;
  this->level_parser_ = &level;
  this->cost_parser_ = &cost;
  this->time_parser_ = &time;
  this->range_parser_ = &range;
  this->target_parser_ = &target;
  this->duration_parser_ = &duration;
  this->precondition_parser_ = &precondition;
  this->effect_parser_ = &effect;
  this->counterMeasure_parser_ = &counterMeasure;
  this->saveable_parser_ = &saveable;
  this->resistible_parser_ = &resistible;
  this->effectsAreInclusive_parser_ = &effectsAreInclusive;
}

RPG_Magic_Spell_PropertiesXML_Type_pskel::
RPG_Magic_Spell_PropertiesXML_Type_pskel ()
: name_parser_ (0),
  type_parser_ (0),
  level_parser_ (0),
  cost_parser_ (0),
  time_parser_ (0),
  range_parser_ (0),
  target_parser_ (0),
  duration_parser_ (0),
  precondition_parser_ (0),
  effect_parser_ (0),
  counterMeasure_parser_ (0),
  saveable_parser_ (0),
  resistible_parser_ (0),
  effectsAreInclusive_parser_ (0)
{
}

// RPG_Magic_SpellLikeProperties_Type_pskel
//

void RPG_Magic_SpellLikeProperties_Type_pskel::
type_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
casterLevel_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->casterLevel_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
duration_parser (::RPG_Common_Duration_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
save_parser (::RPG_Common_SavingThrowCheck_Type_pskel& p)
{
  this->save_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
parsers (::RPG_Magic_SpellType_Type_pskel& type,
         ::xml_schema::unsigned_byte_pskel& casterLevel,
         ::RPG_Common_Duration_Type_pskel& duration,
         ::RPG_Common_SavingThrowCheck_Type_pskel& save)
{
  this->type_parser_ = &type;
  this->casterLevel_parser_ = &casterLevel;
  this->duration_parser_ = &duration;
  this->save_parser_ = &save;
}

RPG_Magic_SpellLikeProperties_Type_pskel::
RPG_Magic_SpellLikeProperties_Type_pskel ()
: type_parser_ (0),
  casterLevel_parser_ (0),
  duration_parser_ (0),
  save_parser_ (0)
{
}

// RPG_Magic_Dictionary_Type_pskel
//

void RPG_Magic_Dictionary_Type_pskel::
spell_parser (::RPG_Magic_Spell_PropertiesXML_Type_pskel& p)
{
  this->spell_parser_ = &p;
}

void RPG_Magic_Dictionary_Type_pskel::
parsers (::RPG_Magic_Spell_PropertiesXML_Type_pskel& spell)
{
  this->spell_parser_ = &spell;
}

RPG_Magic_Dictionary_Type_pskel::
RPG_Magic_Dictionary_Type_pskel ()
: spell_parser_ (0)
{
}

// RPG_Magic_Spell_Type_Type_pskel
//

void RPG_Magic_Spell_Type_Type_pskel::
type (const RPG_Magic_SpellType&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
school (const RPG_Magic_School&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
subSchool (const RPG_Magic_SubSchool&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
descriptor (const RPG_Magic_Descriptor&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
counterSpell (const RPG_Magic_SpellType&)
{
}

bool RPG_Magic_Spell_Type_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "school" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->school_parser_;

    if (this->school_parser_)
      this->school_parser_->pre ();

    return true;
  }

  if (n == "subSchool" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->subSchool_parser_;

    if (this->subSchool_parser_)
      this->subSchool_parser_->pre ();

    return true;
  }

  if (n == "descriptor" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->descriptor_parser_;

    if (this->descriptor_parser_)
      this->descriptor_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_Type_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  if (n == "school" && ns == "urn:rpg")
  {
    if (this->school_parser_)
      this->school (this->school_parser_->post_RPG_Magic_School_Type ());

    return true;
  }

  if (n == "subSchool" && ns == "urn:rpg")
  {
    if (this->subSchool_parser_)
      this->subSchool (this->subSchool_parser_->post_RPG_Magic_SubSchool_Type ());

    return true;
  }

  if (n == "descriptor" && ns == "urn:rpg")
  {
    if (this->descriptor_parser_)
      this->descriptor (this->descriptor_parser_->post_RPG_Magic_Descriptor_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_Type_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "counterSpell" && ns.empty ())
  {
    if (this->counterSpell_parser_)
    {
      this->counterSpell_parser_->pre ();
      this->counterSpell_parser_->_pre_impl ();
      this->counterSpell_parser_->_characters (v);
      this->counterSpell_parser_->_post_impl ();
      this->counterSpell (this->counterSpell_parser_->post_RPG_Magic_SpellType_Type ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_Level_Type_pskel
//

void RPG_Magic_Spell_Level_Type_pskel::
casterClass (const RPG_Magic_CasterClassUnion&)
{
}

void RPG_Magic_Spell_Level_Type_pskel::
level (unsigned char)
{
}

bool RPG_Magic_Spell_Level_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "casterClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->casterClass_parser_;

    if (this->casterClass_parser_)
      this->casterClass_parser_->pre ();

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->level_parser_;

    if (this->level_parser_)
      this->level_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_Level_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "casterClass" && ns == "urn:rpg")
  {
    if (this->casterClass_parser_)
      this->casterClass (this->casterClass_parser_->post_RPG_Magic_CasterClassUnion_Type ());

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    if (this->level_parser_)
      this->level (this->level_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Magic_Spell_CastingTime_Type_pskel
//

void RPG_Magic_Spell_CastingTime_Type_pskel::
rounds (unsigned int)
{
}

void RPG_Magic_Spell_CastingTime_Type_pskel::
action (const RPG_Common_ActionType&)
{
}

bool RPG_Magic_Spell_CastingTime_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "rounds" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->rounds_parser_;

    if (this->rounds_parser_)
      this->rounds_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_CastingTime_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "rounds" && ns == "urn:rpg")
  {
    if (this->rounds_parser_)
      this->rounds (this->rounds_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_CastingTime_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "action" && ns.empty ())
  {
    if (this->action_parser_)
    {
      this->action_parser_->pre ();
      this->action_parser_->_pre_impl ();
      this->action_parser_->_characters (v);
      this->action_parser_->_post_impl ();
      this->action (this->action_parser_->post_RPG_Common_ActionType_Type ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_RangeProperties_Type_pskel
//

void RPG_Magic_Spell_RangeProperties_Type_pskel::
max (unsigned int)
{
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
increment (unsigned int)
{
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
effect (const RPG_Magic_Spell_RangeEffect&)
{
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "max" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->max_parser_;

    if (this->max_parser_)
      this->max_parser_->pre ();

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->increment_parser_;

    if (this->increment_parser_)
      this->increment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "max" && ns == "urn:rpg")
  {
    if (this->max_parser_)
      this->max (this->max_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    if (this->increment_parser_)
      this->increment (this->increment_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "effect" && ns.empty ())
  {
    if (this->effect_parser_)
    {
      this->effect_parser_->pre ();
      this->effect_parser_->_pre_impl ();
      this->effect_parser_->_characters (v);
      this->effect_parser_->_post_impl ();
      this->effect (this->effect_parser_->post_RPG_Magic_Spell_RangeEffect_Type ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_TargetProperties_Type_pskel
//

void RPG_Magic_Spell_TargetProperties_Type_pskel::
base (const RPG_Common_Amount&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrement (unsigned char)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
effect (const RPG_Magic_Spell_AreaOfEffect&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
shape (const RPG_Common_AreaOfEffect&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
radius (unsigned int)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
height (unsigned int)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
target (const RPG_Magic_Spell_Target&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
shapeable (bool)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
rangeIsInHD (bool)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
incrementIsReciprocal (bool)
{
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "base" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->base_parser_;

    if (this->base_parser_)
      this->base_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->effect_parser_;

    if (this->effect_parser_)
      this->effect_parser_->pre ();

    return true;
  }

  if (n == "shape" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->shape_parser_;

    if (this->shape_parser_)
      this->shape_parser_->pre ();

    return true;
  }

  if (n == "radius" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->radius_parser_;

    if (this->radius_parser_)
      this->radius_parser_->pre ();

    return true;
  }

  if (n == "height" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->height_parser_;

    if (this->height_parser_)
      this->height_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "base" && ns == "urn:rpg")
  {
    if (this->base_parser_)
      this->base (this->base_parser_->post_RPG_Common_Amount_Type ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    if (this->effect_parser_)
      this->effect (this->effect_parser_->post_RPG_Magic_Spell_AreaOfEffect_Type ());

    return true;
  }

  if (n == "shape" && ns == "urn:rpg")
  {
    if (this->shape_parser_)
      this->shape (this->shape_parser_->post_RPG_Common_AreaOfEffect_Type ());

    return true;
  }

  if (n == "radius" && ns == "urn:rpg")
  {
    if (this->radius_parser_)
      this->radius (this->radius_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "height" && ns == "urn:rpg")
  {
    if (this->height_parser_)
      this->height (this->height_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "target" && ns.empty ())
  {
    if (this->target_parser_)
    {
      this->target_parser_->pre ();
      this->target_parser_->_pre_impl ();
      this->target_parser_->_characters (v);
      this->target_parser_->_post_impl ();
      this->target (this->target_parser_->post_RPG_Magic_Spell_Target_Type ());
    }

    return true;
  }

  if (n == "shapeable" && ns.empty ())
  {
    if (this->shapeable_parser_)
    {
      this->shapeable_parser_->pre ();
      this->shapeable_parser_->_pre_impl ();
      this->shapeable_parser_->_characters (v);
      this->shapeable_parser_->_post_impl ();
      this->shapeable (this->shapeable_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "rangeIsInHD" && ns.empty ())
  {
    if (this->rangeIsInHD_parser_)
    {
      this->rangeIsInHD_parser_->pre ();
      this->rangeIsInHD_parser_->_pre_impl ();
      this->rangeIsInHD_parser_->_characters (v);
      this->rangeIsInHD_parser_->_post_impl ();
      this->rangeIsInHD (this->rangeIsInHD_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "incrementIsReciprocal" && ns.empty ())
  {
    if (this->incrementIsReciprocal_parser_)
    {
      this->incrementIsReciprocal_parser_->pre ();
      this->incrementIsReciprocal_parser_->_pre_impl ();
      this->incrementIsReciprocal_parser_->_characters (v);
      this->incrementIsReciprocal_parser_->_post_impl ();
      this->incrementIsReciprocal (this->incrementIsReciprocal_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_DurationProperties_Type_pskel
//

void RPG_Magic_Spell_DurationProperties_Type_pskel::
duration (const RPG_Magic_Spell_Duration&)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
dismissible (bool)
{
}

bool RPG_Magic_Spell_DurationProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::RPG_Common_EffectDuration_Type_pskel::_attribute_impl (ns, n, v))
    return true;

  if (n == "duration" && ns.empty ())
  {
    if (this->duration_parser_)
    {
      this->duration_parser_->pre ();
      this->duration_parser_->_pre_impl ();
      this->duration_parser_->_characters (v);
      this->duration_parser_->_post_impl ();
      this->duration (this->duration_parser_->post_RPG_Magic_Spell_Duration_Type ());
    }

    return true;
  }

  if (n == "dismissible" && ns.empty ())
  {
    if (this->dismissible_parser_)
    {
      this->dismissible_parser_->pre ();
      this->dismissible_parser_->_pre_impl ();
      this->dismissible_parser_->_characters (v);
      this->dismissible_parser_->_post_impl ();
      this->dismissible (this->dismissible_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_PreconditionProperties_Type_pskel
//

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
type (const RPG_Magic_Spell_Precondition&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
value (int)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrement (unsigned char)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
alignment ()
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
attribute (const RPG_Common_Attribute&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
condition (const RPG_Common_Condition&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
creature (const RPG_Common_CreatureType&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
size (const RPG_Common_Size&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
environment (const RPG_Common_Environment&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
reverse (bool)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
baseIsCasterLevel (bool)
{
}

bool RPG_Magic_Spell_PreconditionProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;

    if (this->value_parser_)
      this->value_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alignment_parser_;

    if (this->alignment_parser_)
      this->alignment_parser_->pre ();

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attribute_parser_;

    if (this->attribute_parser_)
      this->attribute_parser_->pre ();

    return true;
  }

  if (n == "condition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->condition_parser_;

    if (this->condition_parser_)
      this->condition_parser_->pre ();

    return true;
  }

  if (n == "creature" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->creature_parser_;

    if (this->creature_parser_)
      this->creature_parser_->pre ();

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->environment_parser_;

    if (this->environment_parser_)
      this->environment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PreconditionProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Precondition_Type ());

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    if (this->value_parser_)
      this->value (this->value_parser_->post_int ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    if (this->alignment_parser_)
    {
      this->alignment_parser_->post_RPG_Character_Alignment_Type ();
      this->alignment ();
    }

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    if (this->attribute_parser_)
      this->attribute (this->attribute_parser_->post_RPG_Common_Attribute_Type ());

    return true;
  }

  if (n == "condition" && ns == "urn:rpg")
  {
    if (this->condition_parser_)
      this->condition (this->condition_parser_->post_RPG_Common_Condition_Type ());

    return true;
  }

  if (n == "creature" && ns == "urn:rpg")
  {
    if (this->creature_parser_)
      this->creature (this->creature_parser_->post_RPG_Common_CreatureType_Type ());

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Common_Size_Type ());

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    if (this->environment_parser_)
      this->environment (this->environment_parser_->post_RPG_Common_Environment_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PreconditionProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "reverse" && ns.empty ())
  {
    if (this->reverse_parser_)
    {
      this->reverse_parser_->pre ();
      this->reverse_parser_->_pre_impl ();
      this->reverse_parser_->_characters (v);
      this->reverse_parser_->_post_impl ();
      this->reverse (this->reverse_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "baseIsCasterLevel" && ns.empty ())
  {
    if (this->baseIsCasterLevel_parser_)
    {
      this->baseIsCasterLevel_parser_->pre ();
      this->baseIsCasterLevel_parser_->_pre_impl ();
      this->baseIsCasterLevel_parser_->_characters (v);
      this->baseIsCasterLevel_parser_->_post_impl ();
      this->baseIsCasterLevel (this->baseIsCasterLevel_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Check_Type_pskel
//

void RPG_Magic_Check_Type_pskel::
type (const RPG_Magic_CheckTypeUnion&)
{
}

void RPG_Magic_Check_Type_pskel::
difficultyClass (unsigned char)
{
}

void RPG_Magic_Check_Type_pskel::
modifier (signed char)
{
}

void RPG_Magic_Check_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Check_Type_pskel::
baseIsCasterLevel (bool)
{
}

bool RPG_Magic_Check_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "difficultyClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->difficultyClass_parser_;

    if (this->difficultyClass_parser_)
      this->difficultyClass_parser_->pre ();

    return true;
  }

  if (n == "modifier" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->modifier_parser_;

    if (this->modifier_parser_)
      this->modifier_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Check_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_CheckTypeUnion_Type ());

    return true;
  }

  if (n == "difficultyClass" && ns == "urn:rpg")
  {
    if (this->difficultyClass_parser_)
      this->difficultyClass (this->difficultyClass_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "modifier" && ns == "urn:rpg")
  {
    if (this->modifier_parser_)
      this->modifier (this->modifier_parser_->post_byte ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

bool RPG_Magic_Check_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "baseIsCasterLevel" && ns.empty ())
  {
    if (this->baseIsCasterLevel_parser_)
    {
      this->baseIsCasterLevel_parser_->pre ();
      this->baseIsCasterLevel_parser_->_pre_impl ();
      this->baseIsCasterLevel_parser_->_characters (v);
      this->baseIsCasterLevel_parser_->_post_impl ();
      this->baseIsCasterLevel (this->baseIsCasterLevel_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_CounterMeasure_Type_pskel
//

void RPG_Magic_CounterMeasure_Type_pskel::
type (const RPG_Common_CounterMeasure&)
{
}

void RPG_Magic_CounterMeasure_Type_pskel::
check (const RPG_Magic_Check&)
{
}

void RPG_Magic_CounterMeasure_Type_pskel::
spell (const RPG_Magic_SpellType&)
{
}

void RPG_Magic_CounterMeasure_Type_pskel::
reduction (const RPG_Common_SaveReductionType&)
{
}

bool RPG_Magic_CounterMeasure_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->check_parser_;

    if (this->check_parser_)
      this->check_parser_->pre ();

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->spell_parser_;

    if (this->spell_parser_)
      this->spell_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_CounterMeasure_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Common_CounterMeasure_Type ());

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    if (this->check_parser_)
      this->check (this->check_parser_->post_RPG_Magic_Check_Type ());

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    if (this->spell_parser_)
      this->spell (this->spell_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_CounterMeasure_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "reduction" && ns.empty ())
  {
    if (this->reduction_parser_)
    {
      this->reduction_parser_->pre ();
      this->reduction_parser_->_pre_impl ();
      this->reduction_parser_->_characters (v);
      this->reduction_parser_->_post_impl ();
      this->reduction (this->reduction_parser_->post_RPG_Common_SaveReductionType_Type ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_EffectProperties_Type_pskel
//

void RPG_Magic_Spell_EffectProperties_Type_pskel::
type (const RPG_Magic_Spell_Effect&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
damage (const RPG_Magic_Spell_DamageTypeUnion&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
base (const RPG_Common_Amount&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
increment (unsigned int)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrement (const RPG_Common_Amount&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
attribute (const RPG_Common_Attribute&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
domain (const RPG_Magic_Domain&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
creature (const RPG_Common_CreatureType&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
duration (const RPG_Common_EffectDuration&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
precondition (const RPG_Magic_Spell_PreconditionProperties&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
maxRange (unsigned char)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
counterMeasure (const RPG_Magic_CounterMeasure&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
includeAdjacent (bool)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
incrementIsReciprocal (bool)
{
}

bool RPG_Magic_Spell_EffectProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

    if (this->damage_parser_)
      this->damage_parser_->pre ();

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->base_parser_;

    if (this->base_parser_)
      this->base_parser_->pre ();

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->increment_parser_;

    if (this->increment_parser_)
      this->increment_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attribute_parser_;

    if (this->attribute_parser_)
      this->attribute_parser_->pre ();

    return true;
  }

  if (n == "domain" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->domain_parser_;

    if (this->domain_parser_)
      this->domain_parser_->pre ();

    return true;
  }

  if (n == "creature" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->creature_parser_;

    if (this->creature_parser_)
      this->creature_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->precondition_parser_;

    if (this->precondition_parser_)
      this->precondition_parser_->pre ();

    return true;
  }

  if (n == "maxRange" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->maxRange_parser_;

    if (this->maxRange_parser_)
      this->maxRange_parser_->pre ();

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->counterMeasure_parser_;

    if (this->counterMeasure_parser_)
      this->counterMeasure_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_EffectProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Effect_Type ());

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    if (this->damage_parser_)
      this->damage (this->damage_parser_->post_RPG_Magic_Spell_DamageTypeUnion_Type ());

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    if (this->base_parser_)
      this->base (this->base_parser_->post_RPG_Common_Amount_Type ());

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    if (this->increment_parser_)
      this->increment (this->increment_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_RPG_Common_Amount_Type ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    if (this->attribute_parser_)
      this->attribute (this->attribute_parser_->post_RPG_Common_Attribute_Type ());

    return true;
  }

  if (n == "domain" && ns == "urn:rpg")
  {
    if (this->domain_parser_)
      this->domain (this->domain_parser_->post_RPG_Magic_Domain_Type ());

    return true;
  }

  if (n == "creature" && ns == "urn:rpg")
  {
    if (this->creature_parser_)
      this->creature (this->creature_parser_->post_RPG_Common_CreatureType_Type ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_RPG_Common_EffectDuration_Type ());

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    if (this->precondition_parser_)
      this->precondition (this->precondition_parser_->post_RPG_Magic_Spell_PreconditionProperties_Type ());

    return true;
  }

  if (n == "maxRange" && ns == "urn:rpg")
  {
    if (this->maxRange_parser_)
      this->maxRange (this->maxRange_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    if (this->counterMeasure_parser_)
      this->counterMeasure (this->counterMeasure_parser_->post_RPG_Magic_CounterMeasure_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_EffectProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "includeAdjacent" && ns.empty ())
  {
    if (this->includeAdjacent_parser_)
    {
      this->includeAdjacent_parser_->pre ();
      this->includeAdjacent_parser_->_pre_impl ();
      this->includeAdjacent_parser_->_characters (v);
      this->includeAdjacent_parser_->_post_impl ();
      this->includeAdjacent (this->includeAdjacent_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "incrementIsReciprocal" && ns.empty ())
  {
    if (this->incrementIsReciprocal_parser_)
    {
      this->incrementIsReciprocal_parser_->pre ();
      this->incrementIsReciprocal_parser_->_pre_impl ();
      this->incrementIsReciprocal_parser_->_characters (v);
      this->incrementIsReciprocal_parser_->_post_impl ();
      this->incrementIsReciprocal (this->incrementIsReciprocal_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_PropertiesXML_Type_pskel
//

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
type (const RPG_Magic_Spell_Type&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
level (const RPG_Magic_Spell_Level&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
cost (unsigned int)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
time (const RPG_Magic_Spell_CastingTime&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
range (const RPG_Magic_Spell_RangeProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
target (const RPG_Magic_Spell_TargetProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
duration (const RPG_Magic_Spell_DurationProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
precondition (const RPG_Magic_Spell_PreconditionProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effect (const RPG_Magic_Spell_EffectProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
counterMeasure (const RPG_Magic_CounterMeasure&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
saveable (const RPG_Common_SavingThrow&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
resistible (bool)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effectsAreInclusive (bool)
{
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->level_parser_;

    if (this->level_parser_)
      this->level_parser_->pre ();

    return true;
  }

  if (n == "cost" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->cost_parser_;

    if (this->cost_parser_)
      this->cost_parser_->pre ();

    return true;
  }

  if (n == "time" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->time_parser_;

    if (this->time_parser_)
      this->time_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  if (n == "target" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->target_parser_;

    if (this->target_parser_)
      this->target_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->precondition_parser_;

    if (this->precondition_parser_)
      this->precondition_parser_->pre ();

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->effect_parser_;

    if (this->effect_parser_)
      this->effect_parser_->pre ();

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->counterMeasure_parser_;

    if (this->counterMeasure_parser_)
      this->counterMeasure_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Type_Type ());

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    if (this->level_parser_)
      this->level (this->level_parser_->post_RPG_Magic_Spell_Level_Type ());

    return true;
  }

  if (n == "cost" && ns == "urn:rpg")
  {
    if (this->cost_parser_)
      this->cost (this->cost_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "time" && ns == "urn:rpg")
  {
    if (this->time_parser_)
      this->time (this->time_parser_->post_RPG_Magic_Spell_CastingTime_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Magic_Spell_RangeProperties_Type ());

    return true;
  }

  if (n == "target" && ns == "urn:rpg")
  {
    if (this->target_parser_)
      this->target (this->target_parser_->post_RPG_Magic_Spell_TargetProperties_Type ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_RPG_Magic_Spell_DurationProperties_Type ());

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    if (this->precondition_parser_)
      this->precondition (this->precondition_parser_->post_RPG_Magic_Spell_PreconditionProperties_Type ());

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    if (this->effect_parser_)
      this->effect (this->effect_parser_->post_RPG_Magic_Spell_EffectProperties_Type ());

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    if (this->counterMeasure_parser_)
      this->counterMeasure (this->counterMeasure_parser_->post_RPG_Magic_CounterMeasure_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "saveable" && ns.empty ())
  {
    if (this->saveable_parser_)
    {
      this->saveable_parser_->pre ();
      this->saveable_parser_->_pre_impl ();
      this->saveable_parser_->_characters (v);
      this->saveable_parser_->_post_impl ();
      this->saveable (this->saveable_parser_->post_RPG_Common_SavingThrow_Type ());
    }

    return true;
  }

  if (n == "resistible" && ns.empty ())
  {
    if (this->resistible_parser_)
    {
      this->resistible_parser_->pre ();
      this->resistible_parser_->_pre_impl ();
      this->resistible_parser_->_characters (v);
      this->resistible_parser_->_post_impl ();
      this->resistible (this->resistible_parser_->post_boolean ());
    }

    return true;
  }

  if (n == "effectsAreInclusive" && ns.empty ())
  {
    if (this->effectsAreInclusive_parser_)
    {
      this->effectsAreInclusive_parser_->pre ();
      this->effectsAreInclusive_parser_->_pre_impl ();
      this->effectsAreInclusive_parser_->_characters (v);
      this->effectsAreInclusive_parser_->_post_impl ();
      this->effectsAreInclusive (this->effectsAreInclusive_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_SpellLikeProperties_Type_pskel
//

void RPG_Magic_SpellLikeProperties_Type_pskel::
type (const RPG_Magic_SpellType&)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
casterLevel (unsigned char)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
duration (const RPG_Common_Duration&)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
save ()
{
}

bool RPG_Magic_SpellLikeProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "casterLevel" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->casterLevel_parser_;

    if (this->casterLevel_parser_)
      this->casterLevel_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->save_parser_;

    if (this->save_parser_)
      this->save_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_SpellLikeProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  if (n == "casterLevel" && ns == "urn:rpg")
  {
    if (this->casterLevel_parser_)
      this->casterLevel (this->casterLevel_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_RPG_Common_Duration_Type ());

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    if (this->save_parser_)
    {
      this->save_parser_->post_RPG_Common_SavingThrowCheck_Type ();
      this->save ();
    }

    return true;
  }

  return false;
}

// RPG_Magic_Dictionary_Type_pskel
//

void RPG_Magic_Dictionary_Type_pskel::
spell (const RPG_Magic_Spell_PropertiesXML&)
{
}

void RPG_Magic_Dictionary_Type_pskel::
post_RPG_Magic_Dictionary_Type ()
{
}

bool RPG_Magic_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "spell" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->spell_parser_;

    if (this->spell_parser_)
      this->spell_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "spell" && ns == "urn:rpg")
  {
    if (this->spell_parser_)
      this->spell (this->spell_parser_->post_RPG_Magic_Spell_PropertiesXML_Type ());

    return true;
  }

  return false;
}

// Begin epilogue.
//
//
// End epilogue.

