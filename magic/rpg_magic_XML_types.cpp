// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_magic_XML_types.h"

// RPG_Magic_Spell_Type_Type_pskel
//

void RPG_Magic_Spell_Type_Type_pskel::
type_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
school_parser (::RPG_Magic_School_Type_pskel& p)
{
  this->school_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
subSchool_parser (::RPG_Magic_SubSchool_Type_pskel& p)
{
  this->subSchool_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
descriptor_parser (::RPG_Magic_Descriptor_Type_pskel& p)
{
  this->descriptor_parser_ = &p;
}

void RPG_Magic_Spell_Type_Type_pskel::
parsers (::RPG_Magic_SpellType_Type_pskel& type,
         ::RPG_Magic_School_Type_pskel& school,
         ::RPG_Magic_SubSchool_Type_pskel& subSchool,
         ::RPG_Magic_Descriptor_Type_pskel& descriptor)
{
  this->type_parser_ = &type;
  this->school_parser_ = &school;
  this->subSchool_parser_ = &subSchool;
  this->descriptor_parser_ = &descriptor;
}

RPG_Magic_Spell_Type_Type_pskel::
RPG_Magic_Spell_Type_Type_pskel ()
: type_parser_ (0),
  school_parser_ (0),
  subSchool_parser_ (0),
  descriptor_parser_ (0)
{
}

// RPG_Magic_Spell_Level_Type_pskel
//

void RPG_Magic_Spell_Level_Type_pskel::
casterClass_parser (::RPG_Magic_CasterClassUnion_Type_pskel& p)
{
  this->casterClass_parser_ = &p;
}

void RPG_Magic_Spell_Level_Type_pskel::
level_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->level_parser_ = &p;
}

void RPG_Magic_Spell_Level_Type_pskel::
parsers (::RPG_Magic_CasterClassUnion_Type_pskel& casterClass,
         ::xml_schema::unsigned_byte_pskel& level)
{
  this->casterClass_parser_ = &casterClass;
  this->level_parser_ = &level;
}

RPG_Magic_Spell_Level_Type_pskel::
RPG_Magic_Spell_Level_Type_pskel ()
: casterClass_parser_ (0),
  level_parser_ (0)
{
}

// RPG_Magic_Spell_RangeProperties_Type_pskel
//

void RPG_Magic_Spell_RangeProperties_Type_pskel::
max_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->max_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
increment_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->increment_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
effect_parser (::RPG_Magic_Spell_RangeEffect_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
parsers (::xml_schema::unsigned_int_pskel& max,
         ::xml_schema::unsigned_int_pskel& increment,
         ::RPG_Magic_Spell_RangeEffect_Type_pskel& effect)
{
  this->max_parser_ = &max;
  this->increment_parser_ = &increment;
  this->effect_parser_ = &effect;
}

RPG_Magic_Spell_RangeProperties_Type_pskel::
RPG_Magic_Spell_RangeProperties_Type_pskel ()
: max_parser_ (0),
  increment_parser_ (0),
  effect_parser_ (0)
{
}

// RPG_Magic_Spell_TargetProperties_Type_pskel
//

void RPG_Magic_Spell_TargetProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Target_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
value_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->value_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
range_parser (::RPG_Dice_Roll_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrement_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
area_parser (::RPG_Common_AreaOfEffect_Type_pskel& p)
{
  this->area_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
radius_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->radius_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
height_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->height_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
rangeIsInHD_parser (::xml_schema::boolean_pskel& p)
{
  this->rangeIsInHD_parser_ = &p;
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Target_Type_pskel& type,
         ::xml_schema::unsigned_int_pskel& value,
         ::RPG_Dice_Roll_Type_pskel& range,
         ::xml_schema::unsigned_byte_pskel& levelIncrement,
         ::RPG_Common_AreaOfEffect_Type_pskel& area,
         ::xml_schema::unsigned_byte_pskel& radius,
         ::xml_schema::unsigned_byte_pskel& height,
         ::xml_schema::boolean_pskel& rangeIsInHD)
{
  this->type_parser_ = &type;
  this->value_parser_ = &value;
  this->range_parser_ = &range;
  this->levelIncrement_parser_ = &levelIncrement;
  this->area_parser_ = &area;
  this->radius_parser_ = &radius;
  this->height_parser_ = &height;
  this->rangeIsInHD_parser_ = &rangeIsInHD;
}

RPG_Magic_Spell_TargetProperties_Type_pskel::
RPG_Magic_Spell_TargetProperties_Type_pskel ()
: type_parser_ (0),
  value_parser_ (0),
  range_parser_ (0),
  levelIncrement_parser_ (0),
  area_parser_ (0),
  radius_parser_ (0),
  height_parser_ (0),
  rangeIsInHD_parser_ (0)
{
}

// RPG_Magic_Spell_DurationProperties_Type_pskel
//

void RPG_Magic_Spell_DurationProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Duration_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
base_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->base_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
duration_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
levelIncrement_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
period_parser (::RPG_Dice_Roll_Type_pskel& p)
{
  this->period_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
dismissible_parser (::xml_schema::boolean_pskel& p)
{
  this->dismissible_parser_ = &p;
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Duration_Type_pskel& type,
         ::xml_schema::unsigned_int_pskel& base,
         ::xml_schema::unsigned_int_pskel& duration,
         ::xml_schema::unsigned_byte_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Dice_Roll_Type_pskel& period,
         ::xml_schema::boolean_pskel& dismissible)
{
  this->type_parser_ = &type;
  this->base_parser_ = &base;
  this->duration_parser_ = &duration;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->period_parser_ = &period;
  this->dismissible_parser_ = &dismissible;
}

RPG_Magic_Spell_DurationProperties_Type_pskel::
RPG_Magic_Spell_DurationProperties_Type_pskel ()
: type_parser_ (0),
  base_parser_ (0),
  duration_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  period_parser_ (0),
  dismissible_parser_ (0)
{
}

// RPG_Magic_Spell_PreconditionProperties_Type_pskel
//

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Precondition_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
value_parser (::xml_schema::integer_pskel& p)
{
  this->value_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrement_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
attribute_parser (::RPG_Common_Attribute_Type_pskel& p)
{
  this->attribute_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
condition_parser (::RPG_Character_Condition_Type_pskel& p)
{
  this->condition_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Precondition_Type_pskel& type,
         ::xml_schema::integer_pskel& value,
         ::xml_schema::unsigned_byte_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Common_Attribute_Type_pskel& attribute,
         ::RPG_Character_Condition_Type_pskel& condition,
         ::RPG_Character_Size_Type_pskel& size)
{
  this->type_parser_ = &type;
  this->value_parser_ = &value;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->attribute_parser_ = &attribute;
  this->condition_parser_ = &condition;
  this->size_parser_ = &size;
}

RPG_Magic_Spell_PreconditionProperties_Type_pskel::
RPG_Magic_Spell_PreconditionProperties_Type_pskel ()
: type_parser_ (0),
  value_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  attribute_parser_ (0),
  condition_parser_ (0),
  size_parser_ (0)
{
}

// RPG_Magic_Check_Type_pskel
//

void RPG_Magic_Check_Type_pskel::
type_parser (::RPG_Magic_CheckTypeUnion_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
attribute_parser (::RPG_Common_Attribute_Type_pskel& p)
{
  this->attribute_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
difficultyClass_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->difficultyClass_parser_ = &p;
}

void RPG_Magic_Check_Type_pskel::
parsers (::RPG_Magic_CheckTypeUnion_Type_pskel& type,
         ::RPG_Common_Attribute_Type_pskel& attribute,
         ::xml_schema::unsigned_byte_pskel& difficultyClass)
{
  this->type_parser_ = &type;
  this->attribute_parser_ = &attribute;
  this->difficultyClass_parser_ = &difficultyClass;
}

RPG_Magic_Check_Type_pskel::
RPG_Magic_Check_Type_pskel ()
: type_parser_ (0),
  attribute_parser_ (0),
  difficultyClass_parser_ (0)
{
}

// RPG_Magic_CounterMeasure_Type_pskel
//

void RPG_Magic_CounterMeasure_Type_pskel::
type_parser (::RPG_Common_CounterMeasure_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
check_parser (::RPG_Magic_Check_Type_pskel& p)
{
  this->check_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
spell_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->spell_parser_ = &p;
}

void RPG_Magic_CounterMeasure_Type_pskel::
parsers (::RPG_Common_CounterMeasure_Type_pskel& type,
         ::RPG_Magic_Check_Type_pskel& check,
         ::RPG_Magic_SpellType_Type_pskel& spell)
{
  this->type_parser_ = &type;
  this->check_parser_ = &check;
  this->spell_parser_ = &spell;
}

RPG_Magic_CounterMeasure_Type_pskel::
RPG_Magic_CounterMeasure_Type_pskel ()
: type_parser_ (0),
  check_parser_ (0),
  spell_parser_ (0)
{
}

// RPG_Magic_Spell_EffectProperties_Type_pskel
//

void RPG_Magic_Spell_EffectProperties_Type_pskel::
type_parser (::RPG_Magic_Spell_Effect_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
base_parser (::RPG_Common_Amount_Type_pskel& p)
{
  this->base_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrement_parser (::RPG_Common_Amount_Type_pskel& p)
{
  this->levelIncrement_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrementMax_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelIncrementMax_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
counterMeasure_parser (::RPG_Magic_CounterMeasure_Type_pskel& p)
{
  this->counterMeasure_parser_ = &p;
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
parsers (::RPG_Magic_Spell_Effect_Type_pskel& type,
         ::RPG_Common_Amount_Type_pskel& base,
         ::RPG_Common_Amount_Type_pskel& levelIncrement,
         ::xml_schema::unsigned_byte_pskel& levelIncrementMax,
         ::RPG_Magic_CounterMeasure_Type_pskel& counterMeasure)
{
  this->type_parser_ = &type;
  this->base_parser_ = &base;
  this->levelIncrement_parser_ = &levelIncrement;
  this->levelIncrementMax_parser_ = &levelIncrementMax;
  this->counterMeasure_parser_ = &counterMeasure;
}

RPG_Magic_Spell_EffectProperties_Type_pskel::
RPG_Magic_Spell_EffectProperties_Type_pskel ()
: type_parser_ (0),
  base_parser_ (0),
  levelIncrement_parser_ (0),
  levelIncrementMax_parser_ (0),
  counterMeasure_parser_ (0)
{
}

// RPG_Magic_Spell_PropertiesXML_Type_pskel
//

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
type_parser (::RPG_Magic_Spell_Type_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
level_parser (::RPG_Magic_Spell_Level_Type_pskel& p)
{
  this->level_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
cost_parser (::xml_schema::unsigned_int_pskel& p)
{
  this->cost_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
action_parser (::RPG_Common_ActionType_Type_pskel& p)
{
  this->action_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
range_parser (::RPG_Magic_Spell_RangeProperties_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
target_parser (::RPG_Magic_Spell_TargetProperties_Type_pskel& p)
{
  this->target_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
duration_parser (::RPG_Magic_Spell_DurationProperties_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
precondition_parser (::RPG_Magic_Spell_PreconditionProperties_Type_pskel& p)
{
  this->precondition_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
save_parser (::RPG_Common_SavingThrowCheck_Type_pskel& p)
{
  this->save_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effect_parser (::RPG_Magic_Spell_EffectProperties_Type_pskel& p)
{
  this->effect_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
saveable_parser (::RPG_Common_SavingThrow_Type_pskel& p)
{
  this->saveable_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
resistible_parser (::xml_schema::boolean_pskel& p)
{
  this->resistible_parser_ = &p;
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Magic_Spell_Type_Type_pskel& type,
         ::RPG_Magic_Spell_Level_Type_pskel& level,
         ::xml_schema::unsigned_int_pskel& cost,
         ::RPG_Common_ActionType_Type_pskel& action,
         ::RPG_Magic_Spell_RangeProperties_Type_pskel& range,
         ::RPG_Magic_Spell_TargetProperties_Type_pskel& target,
         ::RPG_Magic_Spell_DurationProperties_Type_pskel& duration,
         ::RPG_Magic_Spell_PreconditionProperties_Type_pskel& precondition,
         ::RPG_Common_SavingThrowCheck_Type_pskel& save,
         ::RPG_Magic_Spell_EffectProperties_Type_pskel& effect,
         ::RPG_Common_SavingThrow_Type_pskel& saveable,
         ::xml_schema::boolean_pskel& resistible)
{
  this->name_parser_ = &name;
  this->type_parser_ = &type;
  this->level_parser_ = &level;
  this->cost_parser_ = &cost;
  this->action_parser_ = &action;
  this->range_parser_ = &range;
  this->target_parser_ = &target;
  this->duration_parser_ = &duration;
  this->precondition_parser_ = &precondition;
  this->save_parser_ = &save;
  this->effect_parser_ = &effect;
  this->saveable_parser_ = &saveable;
  this->resistible_parser_ = &resistible;
}

RPG_Magic_Spell_PropertiesXML_Type_pskel::
RPG_Magic_Spell_PropertiesXML_Type_pskel ()
: name_parser_ (0),
  type_parser_ (0),
  level_parser_ (0),
  cost_parser_ (0),
  action_parser_ (0),
  range_parser_ (0),
  target_parser_ (0),
  duration_parser_ (0),
  precondition_parser_ (0),
  save_parser_ (0),
  effect_parser_ (0),
  saveable_parser_ (0),
  resistible_parser_ (0)
{
}

// RPG_Magic_SpellLikeProperties_Type_pskel
//

void RPG_Magic_SpellLikeProperties_Type_pskel::
type_parser (::RPG_Magic_SpellType_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
casterLevel_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->casterLevel_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
duration_parser (::RPG_Common_Duration_Type_pskel& p)
{
  this->duration_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
save_parser (::RPG_Common_SavingThrowCheck_Type_pskel& p)
{
  this->save_parser_ = &p;
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
parsers (::RPG_Magic_SpellType_Type_pskel& type,
         ::xml_schema::unsigned_byte_pskel& casterLevel,
         ::RPG_Common_Duration_Type_pskel& duration,
         ::RPG_Common_SavingThrowCheck_Type_pskel& save)
{
  this->type_parser_ = &type;
  this->casterLevel_parser_ = &casterLevel;
  this->duration_parser_ = &duration;
  this->save_parser_ = &save;
}

RPG_Magic_SpellLikeProperties_Type_pskel::
RPG_Magic_SpellLikeProperties_Type_pskel ()
: type_parser_ (0),
  casterLevel_parser_ (0),
  duration_parser_ (0),
  save_parser_ (0)
{
}

// RPG_Magic_Dictionary_Type_pskel
//

void RPG_Magic_Dictionary_Type_pskel::
spell_parser (::RPG_Magic_Spell_PropertiesXML_Type_pskel& p)
{
  this->spell_parser_ = &p;
}

void RPG_Magic_Dictionary_Type_pskel::
parsers (::RPG_Magic_Spell_PropertiesXML_Type_pskel& spell)
{
  this->spell_parser_ = &spell;
}

RPG_Magic_Dictionary_Type_pskel::
RPG_Magic_Dictionary_Type_pskel ()
: spell_parser_ (0)
{
}

// RPG_Magic_Spell_Type_Type_pskel
//

void RPG_Magic_Spell_Type_Type_pskel::
type (const RPG_Magic_SpellType&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
school (const RPG_Magic_School&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
subSchool (const RPG_Magic_SubSchool&)
{
}

void RPG_Magic_Spell_Type_Type_pskel::
descriptor (const RPG_Magic_Descriptor&)
{
}

bool RPG_Magic_Spell_Type_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "school" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->school_parser_;

    if (this->school_parser_)
      this->school_parser_->pre ();

    return true;
  }

  if (n == "subSchool" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->subSchool_parser_;

    if (this->subSchool_parser_)
      this->subSchool_parser_->pre ();

    return true;
  }

  if (n == "descriptor" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->descriptor_parser_;

    if (this->descriptor_parser_)
      this->descriptor_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_Type_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  if (n == "school" && ns == "urn:rpg")
  {
    if (this->school_parser_)
      this->school (this->school_parser_->post_RPG_Magic_School_Type ());

    return true;
  }

  if (n == "subSchool" && ns == "urn:rpg")
  {
    if (this->subSchool_parser_)
      this->subSchool (this->subSchool_parser_->post_RPG_Magic_SubSchool_Type ());

    return true;
  }

  if (n == "descriptor" && ns == "urn:rpg")
  {
    if (this->descriptor_parser_)
      this->descriptor (this->descriptor_parser_->post_RPG_Magic_Descriptor_Type ());

    return true;
  }

  return false;
}

// RPG_Magic_Spell_Level_Type_pskel
//

void RPG_Magic_Spell_Level_Type_pskel::
casterClass (const RPG_Magic_CasterClassUnion&)
{
}

void RPG_Magic_Spell_Level_Type_pskel::
level (unsigned char)
{
}

bool RPG_Magic_Spell_Level_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "casterClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->casterClass_parser_;

    if (this->casterClass_parser_)
      this->casterClass_parser_->pre ();

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->level_parser_;

    if (this->level_parser_)
      this->level_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_Level_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "casterClass" && ns == "urn:rpg")
  {
    if (this->casterClass_parser_)
      this->casterClass (this->casterClass_parser_->post_RPG_Magic_CasterClassUnion_Type ());

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    if (this->level_parser_)
      this->level (this->level_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Magic_Spell_RangeProperties_Type_pskel
//

void RPG_Magic_Spell_RangeProperties_Type_pskel::
max (unsigned int)
{
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
increment (unsigned int)
{
}

void RPG_Magic_Spell_RangeProperties_Type_pskel::
effect (const RPG_Magic_Spell_RangeEffect&)
{
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "max" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->max_parser_;

    if (this->max_parser_)
      this->max_parser_->pre ();

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->increment_parser_;

    if (this->increment_parser_)
      this->increment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "max" && ns == "urn:rpg")
  {
    if (this->max_parser_)
      this->max (this->max_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "increment" && ns == "urn:rpg")
  {
    if (this->increment_parser_)
      this->increment (this->increment_parser_->post_unsigned_int ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_RangeProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "effect" && ns.empty ())
  {
    if (this->effect_parser_)
    {
      this->effect_parser_->pre ();
      this->effect_parser_->_pre_impl ();
      this->effect_parser_->_characters (v);
      this->effect_parser_->_post_impl ();
      this->effect (this->effect_parser_->post_RPG_Magic_Spell_RangeEffect_Type ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_TargetProperties_Type_pskel
//

void RPG_Magic_Spell_TargetProperties_Type_pskel::
type (const RPG_Magic_Spell_Target&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
value (unsigned int)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
range (const RPG_Dice_Roll&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
levelIncrement (unsigned char)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
area (const RPG_Common_AreaOfEffect&)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
radius (unsigned char)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
height (unsigned char)
{
}

void RPG_Magic_Spell_TargetProperties_Type_pskel::
rangeIsInHD (bool)
{
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;

    if (this->value_parser_)
      this->value_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "area" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->area_parser_;

    if (this->area_parser_)
      this->area_parser_->pre ();

    return true;
  }

  if (n == "radius" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->radius_parser_;

    if (this->radius_parser_)
      this->radius_parser_->pre ();

    return true;
  }

  if (n == "height" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->height_parser_;

    if (this->height_parser_)
      this->height_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Target_Type ());

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    if (this->value_parser_)
      this->value (this->value_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_Roll_Type ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "area" && ns == "urn:rpg")
  {
    if (this->area_parser_)
      this->area (this->area_parser_->post_RPG_Common_AreaOfEffect_Type ());

    return true;
  }

  if (n == "radius" && ns == "urn:rpg")
  {
    if (this->radius_parser_)
      this->radius (this->radius_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "height" && ns == "urn:rpg")
  {
    if (this->height_parser_)
      this->height (this->height_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_TargetProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "rangeIsInHD" && ns.empty ())
  {
    if (this->rangeIsInHD_parser_)
    {
      this->rangeIsInHD_parser_->pre ();
      this->rangeIsInHD_parser_->_pre_impl ();
      this->rangeIsInHD_parser_->_characters (v);
      this->rangeIsInHD_parser_->_post_impl ();
      this->rangeIsInHD (this->rangeIsInHD_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_DurationProperties_Type_pskel
//

void RPG_Magic_Spell_DurationProperties_Type_pskel::
type (const RPG_Magic_Spell_Duration&)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
base (unsigned int)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
duration (unsigned int)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
levelIncrement (unsigned char)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
period (const RPG_Dice_Roll&)
{
}

void RPG_Magic_Spell_DurationProperties_Type_pskel::
dismissible (bool)
{
}

bool RPG_Magic_Spell_DurationProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->base_parser_;

    if (this->base_parser_)
      this->base_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "period" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->period_parser_;

    if (this->period_parser_)
      this->period_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_DurationProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Duration_Type ());

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    if (this->base_parser_)
      this->base (this->base_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "period" && ns == "urn:rpg")
  {
    if (this->period_parser_)
      this->period (this->period_parser_->post_RPG_Dice_Roll_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_DurationProperties_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "dismissible" && ns.empty ())
  {
    if (this->dismissible_parser_)
    {
      this->dismissible_parser_->pre ();
      this->dismissible_parser_->_pre_impl ();
      this->dismissible_parser_->_characters (v);
      this->dismissible_parser_->_post_impl ();
      this->dismissible (this->dismissible_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_Spell_PreconditionProperties_Type_pskel
//

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
type (const RPG_Magic_Spell_Precondition&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
value (long long)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrement (unsigned char)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
attribute (const RPG_Common_Attribute&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
condition (const RPG_Character_Condition&)
{
}

void RPG_Magic_Spell_PreconditionProperties_Type_pskel::
size (const RPG_Character_Size&)
{
}

bool RPG_Magic_Spell_PreconditionProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;

    if (this->value_parser_)
      this->value_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attribute_parser_;

    if (this->attribute_parser_)
      this->attribute_parser_->pre ();

    return true;
  }

  if (n == "condition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->condition_parser_;

    if (this->condition_parser_)
      this->condition_parser_->pre ();

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PreconditionProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Precondition_Type ());

    return true;
  }

  if (n == "value" && ns == "urn:rpg")
  {
    if (this->value_parser_)
      this->value (this->value_parser_->post_integer ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    if (this->attribute_parser_)
      this->attribute (this->attribute_parser_->post_RPG_Common_Attribute_Type ());

    return true;
  }

  if (n == "condition" && ns == "urn:rpg")
  {
    if (this->condition_parser_)
      this->condition (this->condition_parser_->post_RPG_Character_Condition_Type ());

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Character_Size_Type ());

    return true;
  }

  return false;
}

// RPG_Magic_Check_Type_pskel
//

void RPG_Magic_Check_Type_pskel::
type (const RPG_Magic_CheckTypeUnion&)
{
}

void RPG_Magic_Check_Type_pskel::
attribute (const RPG_Common_Attribute&)
{
}

void RPG_Magic_Check_Type_pskel::
difficultyClass (unsigned char)
{
}

bool RPG_Magic_Check_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attribute_parser_;

    if (this->attribute_parser_)
      this->attribute_parser_->pre ();

    return true;
  }

  if (n == "difficultyClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->difficultyClass_parser_;

    if (this->difficultyClass_parser_)
      this->difficultyClass_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Check_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_CheckTypeUnion_Type ());

    return true;
  }

  if (n == "attribute" && ns == "urn:rpg")
  {
    if (this->attribute_parser_)
      this->attribute (this->attribute_parser_->post_RPG_Common_Attribute_Type ());

    return true;
  }

  if (n == "difficultyClass" && ns == "urn:rpg")
  {
    if (this->difficultyClass_parser_)
      this->difficultyClass (this->difficultyClass_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Magic_CounterMeasure_Type_pskel
//

void RPG_Magic_CounterMeasure_Type_pskel::
type (const RPG_Common_CounterMeasure&)
{
}

void RPG_Magic_CounterMeasure_Type_pskel::
check (const RPG_Magic_Check&)
{
}

void RPG_Magic_CounterMeasure_Type_pskel::
spell (const RPG_Magic_SpellType&)
{
}

bool RPG_Magic_CounterMeasure_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->check_parser_;

    if (this->check_parser_)
      this->check_parser_->pre ();

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->spell_parser_;

    if (this->spell_parser_)
      this->spell_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_CounterMeasure_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Common_CounterMeasure_Type ());

    return true;
  }

  if (n == "check" && ns == "urn:rpg")
  {
    if (this->check_parser_)
      this->check (this->check_parser_->post_RPG_Magic_Check_Type ());

    return true;
  }

  if (n == "spell" && ns == "urn:rpg")
  {
    if (this->spell_parser_)
      this->spell (this->spell_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  return false;
}

// RPG_Magic_Spell_EffectProperties_Type_pskel
//

void RPG_Magic_Spell_EffectProperties_Type_pskel::
type (const RPG_Magic_Spell_Effect&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
base (const RPG_Common_Amount&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrement (const RPG_Common_Amount&)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
levelIncrementMax (unsigned char)
{
}

void RPG_Magic_Spell_EffectProperties_Type_pskel::
counterMeasure (const RPG_Magic_CounterMeasure&)
{
}

bool RPG_Magic_Spell_EffectProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->base_parser_;

    if (this->base_parser_)
      this->base_parser_->pre ();

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrement_parser_;

    if (this->levelIncrement_parser_)
      this->levelIncrement_parser_->pre ();

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelIncrementMax_parser_;

    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax_parser_->pre ();

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->counterMeasure_parser_;

    if (this->counterMeasure_parser_)
      this->counterMeasure_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_EffectProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Effect_Type ());

    return true;
  }

  if (n == "base" && ns == "urn:rpg")
  {
    if (this->base_parser_)
      this->base (this->base_parser_->post_RPG_Common_Amount_Type ());

    return true;
  }

  if (n == "levelIncrement" && ns == "urn:rpg")
  {
    if (this->levelIncrement_parser_)
      this->levelIncrement (this->levelIncrement_parser_->post_RPG_Common_Amount_Type ());

    return true;
  }

  if (n == "levelIncrementMax" && ns == "urn:rpg")
  {
    if (this->levelIncrementMax_parser_)
      this->levelIncrementMax (this->levelIncrementMax_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "counterMeasure" && ns == "urn:rpg")
  {
    if (this->counterMeasure_parser_)
      this->counterMeasure (this->counterMeasure_parser_->post_RPG_Magic_CounterMeasure_Type ());

    return true;
  }

  return false;
}

// RPG_Magic_Spell_PropertiesXML_Type_pskel
//

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
type (const RPG_Magic_Spell_Type&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
level (const RPG_Magic_Spell_Level&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
cost (unsigned int)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
action (const RPG_Common_ActionType&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
range (const RPG_Magic_Spell_RangeProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
target (const RPG_Magic_Spell_TargetProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
duration (const RPG_Magic_Spell_DurationProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
precondition (const RPG_Magic_Spell_PreconditionProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
save (const RPG_Common_SavingThrowCheck&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
effect (const RPG_Magic_Spell_EffectProperties&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
saveable (const RPG_Common_SavingThrow&)
{
}

void RPG_Magic_Spell_PropertiesXML_Type_pskel::
resistible (bool)
{
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->level_parser_;

    if (this->level_parser_)
      this->level_parser_->pre ();

    return true;
  }

  if (n == "cost" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->cost_parser_;

    if (this->cost_parser_)
      this->cost_parser_->pre ();

    return true;
  }

  if (n == "action" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

    if (this->action_parser_)
      this->action_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  if (n == "target" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->target_parser_;

    if (this->target_parser_)
      this->target_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->precondition_parser_;

    if (this->precondition_parser_)
      this->precondition_parser_->pre ();

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->save_parser_;

    if (this->save_parser_)
      this->save_parser_->pre ();

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->effect_parser_;

    if (this->effect_parser_)
      this->effect_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_Spell_Type_Type ());

    return true;
  }

  if (n == "level" && ns == "urn:rpg")
  {
    if (this->level_parser_)
      this->level (this->level_parser_->post_RPG_Magic_Spell_Level_Type ());

    return true;
  }

  if (n == "cost" && ns == "urn:rpg")
  {
    if (this->cost_parser_)
      this->cost (this->cost_parser_->post_unsigned_int ());

    return true;
  }

  if (n == "action" && ns == "urn:rpg")
  {
    if (this->action_parser_)
      this->action (this->action_parser_->post_RPG_Common_ActionType_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Magic_Spell_RangeProperties_Type ());

    return true;
  }

  if (n == "target" && ns == "urn:rpg")
  {
    if (this->target_parser_)
      this->target (this->target_parser_->post_RPG_Magic_Spell_TargetProperties_Type ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_RPG_Magic_Spell_DurationProperties_Type ());

    return true;
  }

  if (n == "precondition" && ns == "urn:rpg")
  {
    if (this->precondition_parser_)
      this->precondition (this->precondition_parser_->post_RPG_Magic_Spell_PreconditionProperties_Type ());

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    if (this->save_parser_)
      this->save (this->save_parser_->post_RPG_Common_SavingThrowCheck_Type ());

    return true;
  }

  if (n == "effect" && ns == "urn:rpg")
  {
    if (this->effect_parser_)
      this->effect (this->effect_parser_->post_RPG_Magic_Spell_EffectProperties_Type ());

    return true;
  }

  return false;
}

bool RPG_Magic_Spell_PropertiesXML_Type_pskel::
_attribute_impl (const ::xml_schema::ro_string& ns,
                 const ::xml_schema::ro_string& n,
                 const ::xml_schema::ro_string& v)
{
  if (this->::xml_schema::complex_content::_attribute_impl (ns, n, v))
    return true;

  if (n == "saveable" && ns.empty ())
  {
    if (this->saveable_parser_)
    {
      this->saveable_parser_->pre ();
      this->saveable_parser_->_pre_impl ();
      this->saveable_parser_->_characters (v);
      this->saveable_parser_->_post_impl ();
      this->saveable (this->saveable_parser_->post_RPG_Common_SavingThrow_Type ());
    }

    return true;
  }

  if (n == "resistible" && ns.empty ())
  {
    if (this->resistible_parser_)
    {
      this->resistible_parser_->pre ();
      this->resistible_parser_->_pre_impl ();
      this->resistible_parser_->_characters (v);
      this->resistible_parser_->_post_impl ();
      this->resistible (this->resistible_parser_->post_boolean ());
    }

    return true;
  }

  return false;
}

// RPG_Magic_SpellLikeProperties_Type_pskel
//

void RPG_Magic_SpellLikeProperties_Type_pskel::
type (const RPG_Magic_SpellType&)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
casterLevel (unsigned char)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
duration (const RPG_Common_Duration&)
{
}

void RPG_Magic_SpellLikeProperties_Type_pskel::
save (const RPG_Common_SavingThrowCheck&)
{
}

bool RPG_Magic_SpellLikeProperties_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "casterLevel" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->casterLevel_parser_;

    if (this->casterLevel_parser_)
      this->casterLevel_parser_->pre ();

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->duration_parser_;

    if (this->duration_parser_)
      this->duration_parser_->pre ();

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->save_parser_;

    if (this->save_parser_)
      this->save_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_SpellLikeProperties_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Magic_SpellType_Type ());

    return true;
  }

  if (n == "casterLevel" && ns == "urn:rpg")
  {
    if (this->casterLevel_parser_)
      this->casterLevel (this->casterLevel_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "duration" && ns == "urn:rpg")
  {
    if (this->duration_parser_)
      this->duration (this->duration_parser_->post_RPG_Common_Duration_Type ());

    return true;
  }

  if (n == "save" && ns == "urn:rpg")
  {
    if (this->save_parser_)
      this->save (this->save_parser_->post_RPG_Common_SavingThrowCheck_Type ());

    return true;
  }

  return false;
}

// RPG_Magic_Dictionary_Type_pskel
//

void RPG_Magic_Dictionary_Type_pskel::
spell (const RPG_Magic_Spell_PropertiesXML&)
{
}

void RPG_Magic_Dictionary_Type_pskel::
post_RPG_Magic_Dictionary_Type ()
{
}

bool RPG_Magic_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "spell" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->spell_parser_;

    if (this->spell_parser_)
      this->spell_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Magic_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "spell" && ns == "urn:rpg")
  {
    if (this->spell_parser_)
      this->spell (this->spell_parser_->post_RPG_Magic_Spell_PropertiesXML_Type ());

    return true;
  }

  return false;
}

// Begin epilogue.
//
//
// End epilogue.

