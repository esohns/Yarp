// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___RPG_MAGIC_XML_TREE_H
#define CXX___RPG_MAGIC_XML_TREE_H

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "rpg_XMLSchema_XML_tree.h"

// Forward declarations.
//
class RPG_Magic_School_XMLTree_Type;
class RPG_Magic_SubSchool_XMLTree_Type;
class RPG_Magic_Descriptor_XMLTree_Type;
class RPG_Magic_Domain_XMLTree_Type;
class RPG_Magic_SpellType_XMLTree_Type;
class RPG_Magic_AbilityClass_XMLTree_Type;
class RPG_Magic_AbilityType_XMLTree_Type;
class RPG_Magic_Spell_Type_XMLTree_Type;
class RPG_Magic_CasterClassUnion_XMLTree_Type;
class RPG_Magic_Spell_Level_XMLTree_Type;
class RPG_Magic_Spell_CastingTime_XMLTree_Type;
class RPG_Magic_Spell_RangeEffect_XMLTree_Type;
class RPG_Magic_Spell_RangeProperties_XMLTree_Type;
class RPG_Magic_Spell_Target_XMLTree_Type;
class RPG_Magic_Spell_AreaOfEffect_XMLTree_Type;
class RPG_Magic_Spell_TargetProperties_XMLTree_Type;
class RPG_Magic_Spell_Duration_XMLTree_Type;
class RPG_Magic_Spell_DurationProperties_XMLTree_Type;
class RPG_Magic_Spell_Precondition_XMLTree_Type;
class RPG_Magic_Spell_PreconditionProperties_XMLTree_Type;
class RPG_Magic_Spell_Effect_XMLTree_Type;
class RPG_Magic_CheckTypeUnion_XMLTree_Type;
class RPG_Magic_Check_XMLTree_Type;
class RPG_Magic_CounterMeasure_XMLTree_Type;
class RPG_Magic_Spell_EffectProperties_XMLTree_Type;
class RPG_Magic_Spell_PropertiesXML_XMLTree_Type;
class RPG_Magic_SpellLikeProperties_XMLTree_Type;
class RPG_Magic_Dictionary_XMLTree_Type;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#include "rpg_dice_XML_tree.h"

#include "rpg_common_XML_tree.h"

#include "rpg_character_XML_tree.h"

class RPG_Magic_School_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SCHOOL_NONE,
    SCHOOL_ABJURATION,
    SCHOOL_CONJURATION,
    SCHOOL_DIVINATION,
    SCHOOL_ENCHANTMENT,
    SCHOOL_EVOCATION,
    SCHOOL_ILLUSION,
    SCHOOL_NECROMANCY,
    SCHOOL_TRANSMUTATION
  };

  RPG_Magic_School_XMLTree_Type (value v);

  RPG_Magic_School_XMLTree_Type (const char* v);

  RPG_Magic_School_XMLTree_Type (const ::std::string& v);

  RPG_Magic_School_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_School_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_School_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_School_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_School_XMLTree_Type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_School_XMLTree_Type (const RPG_Magic_School_XMLTree_Type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual RPG_Magic_School_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_School_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_School_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_School_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_School_XMLTree_Type_literals_[9];
  static const value _xsd_RPG_Magic_School_XMLTree_Type_indexes_[9];
};

class RPG_Magic_SubSchool_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SUBSCHOOL_SUMMONING,
    SUBSCHOOL_CALLING,
    SUBSCHOOL_HEALING,
    SUBSCHOOL_TELEPORTATION,
    SUBSCHOOL_CREATION,
    SUBSCHOOL_SCRYING,
    SUBSCHOOL_CHARM,
    SUBSCHOOL_COMPULSION,
    SUBSCHOOL_FIGMENT,
    SUBSCHOOL_GLAMER,
    SUBSCHOOL_PATTERN,
    SUBSCHOOL_PHANTASM,
    SUBSCHOOL_SHADOW
  };

  RPG_Magic_SubSchool_XMLTree_Type (value v);

  RPG_Magic_SubSchool_XMLTree_Type (const char* v);

  RPG_Magic_SubSchool_XMLTree_Type (const ::std::string& v);

  RPG_Magic_SubSchool_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_SubSchool_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SubSchool_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SubSchool_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SubSchool_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SubSchool_XMLTree_Type (const RPG_Magic_SubSchool_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Magic_SubSchool_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_SubSchool_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_SubSchool_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_SubSchool_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_SubSchool_XMLTree_Type_literals_[13];
  static const value _xsd_RPG_Magic_SubSchool_XMLTree_Type_indexes_[13];
};

class RPG_Magic_Descriptor_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    DESCRIPTOR_ACID,
    DESCRIPTOR_AIR,
    DESCRIPTOR_CHAOTIC,
    DESCRIPTOR_COLD,
    DESCRIPTOR_DARKNESS,
    DESCRIPTOR_DEATH,
    DESCRIPTOR_EARTH,
    DESCRIPTOR_ELECTRICITY,
    DESCRIPTOR_EVIL,
    DESCRIPTOR_FEAR,
    DESCRIPTOR_FIRE,
    DESCRIPTOR_FORCE,
    DESCRIPTOR_GOOD,
    DESCRIPTOR_LANGUAGE_DEPENDENT,
    DESCRIPTOR_LAWFUL,
    DESCRIPTOR_LIGHT,
    DESCRIPTOR_MIND_AFFECTING,
    DESCRIPTOR_SONIC,
    DESCRIPTOR_WATER
  };

  RPG_Magic_Descriptor_XMLTree_Type (value v);

  RPG_Magic_Descriptor_XMLTree_Type (const char* v);

  RPG_Magic_Descriptor_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Descriptor_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Descriptor_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Descriptor_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Descriptor_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Descriptor_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Descriptor_XMLTree_Type (const RPG_Magic_Descriptor_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Magic_Descriptor_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Descriptor_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Descriptor_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Descriptor_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Descriptor_XMLTree_Type_literals_[19];
  static const value _xsd_RPG_Magic_Descriptor_XMLTree_Type_indexes_[19];
};

class RPG_Magic_Domain_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    DOMAIN_NONE,
    DOMAIN_AIR,
    DOMAIN_ANIMAL,
    DOMAIN_CHAOS,
    DOMAIN_DEATH,
    DOMAIN_DESTRUCTION,
    DOMAIN_EARTH,
    DOMAIN_EVIL,
    DOMAIN_FIRE,
    DOMAIN_GOOD,
    DOMAIN_HEALING,
    DOMAIN_KNOWLEDGE,
    DOMAIN_LAW,
    DOMAIN_LUCK,
    DOMAIN_MAGIC,
    DOMAIN_PLANT,
    DOMAIN_PROTECTION,
    DOMAIN_STRENGTH,
    DOMAIN_SUN,
    DOMAIN_TRAVEL,
    DOMAIN_TRICKERY,
    DOMAIN_WAR,
    DOMAIN_WATER
  };

  RPG_Magic_Domain_XMLTree_Type (value v);

  RPG_Magic_Domain_XMLTree_Type (const char* v);

  RPG_Magic_Domain_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Domain_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Domain_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_Domain_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_Domain_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_Domain_XMLTree_Type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  RPG_Magic_Domain_XMLTree_Type (const RPG_Magic_Domain_XMLTree_Type& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual RPG_Magic_Domain_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Domain_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Domain_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Domain_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Domain_XMLTree_Type_literals_[23];
  static const value _xsd_RPG_Magic_Domain_XMLTree_Type_indexes_[23];
};

class RPG_Magic_SpellType_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SPELL_NONE,
    SPELL_ACID_ARROW,
    SPELL_ACID_FOG,
    SPELL_ACID_SPLASH,
    SPELL_AID,
    SPELL_AIR_WALK,
    SPELL_ALARM,
    SPELL_ALIGN_WEAPON,
    SPELL_ALTER_SELF,
    SPELL_ANALYZE_DWEOMER,
    SPELL_ANIMAL_GROWTH,
    SPELL_ANIMAL_MESSENGER,
    SPELL_ANIMAL_SHAPES,
    SPELL_ANIMAL_TRANCE,
    SPELL_ANIMATE_DEAD,
    SPELL_ANIMATE_OBJECTS,
    SPELL_ANIMATE_PLANTS,
    SPELL_ANIMATE_ROPE,
    SPELL_ANTILIFE_SHELL,
    SPELL_ANTIMAGIC_FIELD,
    SPELL_ANTIPATHY,
    SPELL_ANTIPLANT_SHELL,
    SPELL_ARCANE_EYE,
    SPELL_ARCANE_LOCK,
    SPELL_ARCANE_MARK,
    SPELL_ARCANE_SIGHT,
    SPELL_ARCANE_SIGHT_GREATER,
    SPELL_ASTRAL_PROJECTION,
    SPELL_ATONEMENT,
    SPELL_AUGURY,
    SPELL_AWAKEN,
    SPELL_BALEFUL_POLYMORPH,
    SPELL_BANE,
    SPELL_BANISHMENT,
    SPELL_BARKSKIN,
    SPELL_BEARS_ENDURANCE,
    SPELL_BEARS_ENDURANCE_MASS,
    SPELL_BESTOW_CURSE,
    SPELL_BINDING,
    SPELL_BLADE_BARRIER,
    SPELL_BLASPHEMY,
    SPELL_BLESS,
    SPELL_BLINK,
    SPELL_BREAK_ENCHANTMENT,
    SPELL_CALL_LIGHTNING,
    SPELL_CANTRIP,
    SPELL_CHAOS_HAMMER,
    SPELL_CHARM_MONSTER,
    SPELL_COMMUNE,
    SPELL_CONFUSION,
    SPELL_DARKNESS,
    SPELL_DELAY_POISON,
    SPELL_DETECT_CHAOS,
    SPELL_DETECT_EVIL,
    SPELL_DETECT_GOOD,
    SPELL_DETECT_LAW,
    SPELL_DETECT_MAGIC,
    SPELL_DETECT_THOUGHTS,
    SPELL_DIMENSION_DOOR,
    SPELL_DISCERN_LOCATION,
    SPELL_DISPEL_MAGIC,
    SPELL_DISPEL_MAGIC_GREATER,
    SPELL_DOMINATE_MONSTER,
    SPELL_ENTANGLE,
    SPELL_ETHEREAL_JAUNT,
    SPELL_FEAR,
    SPELL_FEEBLEMIND,
    SPELL_FIRE_STORM,
    SPELL_GASEOUS_FORM,
    SPELL_HEAL,
    SPELL_HEAL_MASS,
    SPELL_HEROISM,
    SPELL_HOLD_MONSTER,
    SPELL_IMPLOSION,
    SPELL_INSANITY,
    SPELL_INVISIBILITY,
    SPELL_MAGIC_WEAPON,
    SPELL_MIRACLE,
    SPELL_MIRROR_IMAGE,
    SPELL_NEUTRALIZE_POISON,
    SPELL_PLANE_SHIFT,
    SPELL_POLYMORPH,
    SPELL_POWER_WORD_STUN,
    SPELL_PROJECT_IMAGE,
    SPELL_REMOVE_CURSE,
    SPELL_REMOVE_DISEASE,
    SPELL_RESTORATION,
    SPELL_RESTORATION_GREATER,
    SPELL_REVERSE_GRAVITY,
    SPELL_SCARE,
    SPELL_SEE_INVISIBILITY,
    SPELL_SILENT_IMAGE,
    SPELL_SLOW,
    SPELL_STINKING_CLOUD,
    SPELL_STONE_SHAPE,
    SPELL_SUGGESTION,
    SPELL_SUMMON_MONSTER_I,
    SPELL_SUMMON_MONSTER_III,
    SPELL_SUMMON_MONSTER_IV,
    SPELL_SUMMON_MONSTER_V,
    SPELL_SUMMON_MONSTER_IX,
    SPELL_SYMPATHY,
    SPELL_TELEKINESIS,
    SPELL_TELEPATHY,
    SPELL_TELEPORT_GREATER,
    SPELL_TONGUES,
    SPELL_TRUE_SEEING,
    SPELL_UNHOLY_AURA,
    SPELL_UNHOLY_BLIGHT,
    SPELL_WISH,
    SPELL_WISH_LIMITED
  };

  RPG_Magic_SpellType_XMLTree_Type (value v);

  RPG_Magic_SpellType_XMLTree_Type (const char* v);

  RPG_Magic_SpellType_XMLTree_Type (const ::std::string& v);

  RPG_Magic_SpellType_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_SpellType_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SpellType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SpellType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SpellType_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Magic_SpellType_XMLTree_Type (const RPG_Magic_SpellType_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Magic_SpellType_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_SpellType_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_SpellType_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_SpellType_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_SpellType_XMLTree_Type_literals_[111];
  static const value _xsd_RPG_Magic_SpellType_XMLTree_Type_indexes_[111];
};

class RPG_Magic_AbilityClass_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ABILITYCLASS_EXTRAORDINARY,
    ABILITYCLASS_SPELLLIKE,
    ABILITYCLASS_SUPERNATURAL
  };

  RPG_Magic_AbilityClass_XMLTree_Type (value v);

  RPG_Magic_AbilityClass_XMLTree_Type (const char* v);

  RPG_Magic_AbilityClass_XMLTree_Type (const ::std::string& v);

  RPG_Magic_AbilityClass_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_AbilityClass_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_AbilityClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_AbilityClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_AbilityClass_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_AbilityClass_XMLTree_Type (const RPG_Magic_AbilityClass_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Magic_AbilityClass_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_AbilityClass_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_AbilityClass_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_AbilityClass_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Magic_AbilityClass_XMLTree_Type_indexes_[3];
};

class RPG_Magic_AbilityType_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ABILITYTYPE_SMITE,
    ABILITYTYPE_SMOKE_CLAWS,
    ABILITYTYPE_WHIRLWIND_BLAST
  };

  RPG_Magic_AbilityType_XMLTree_Type (value v);

  RPG_Magic_AbilityType_XMLTree_Type (const char* v);

  RPG_Magic_AbilityType_XMLTree_Type (const ::std::string& v);

  RPG_Magic_AbilityType_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_AbilityType_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_AbilityType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_AbilityType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_AbilityType_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_AbilityType_XMLTree_Type (const RPG_Magic_AbilityType_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Magic_AbilityType_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_AbilityType_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_AbilityType_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_AbilityType_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_AbilityType_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Magic_AbilityType_XMLTree_Type_indexes_[3];
};

class RPG_Magic_Spell_Type_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_SpellType_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // school
  // 
  typedef ::RPG_Magic_School_XMLTree_Type school_type;
  typedef ::xsd::cxx::tree::traits< school_type, char > school_traits;

  const school_type&
  school () const;

  school_type&
  school ();

  void
  school (const school_type& x);

  void
  school (::std::auto_ptr< school_type > p);

  // subSchool
  // 
  typedef ::RPG_Magic_SubSchool_XMLTree_Type subSchool_type;
  typedef ::xsd::cxx::tree::optional< subSchool_type > subSchool_optional;
  typedef ::xsd::cxx::tree::traits< subSchool_type, char > subSchool_traits;

  const subSchool_optional&
  subSchool () const;

  subSchool_optional&
  subSchool ();

  void
  subSchool (const subSchool_type& x);

  void
  subSchool (const subSchool_optional& x);

  void
  subSchool (::std::auto_ptr< subSchool_type > p);

  // descriptor
  // 
  typedef ::RPG_Magic_Descriptor_XMLTree_Type descriptor_type;
  typedef ::xsd::cxx::tree::sequence< descriptor_type > descriptor_sequence;
  typedef descriptor_sequence::iterator descriptor_iterator;
  typedef descriptor_sequence::const_iterator descriptor_const_iterator;
  typedef ::xsd::cxx::tree::traits< descriptor_type, char > descriptor_traits;

  const descriptor_sequence&
  descriptor () const;

  descriptor_sequence&
  descriptor ();

  void
  descriptor (const descriptor_sequence& s);

  // counterSpell
  // 
  typedef ::RPG_Magic_SpellType_XMLTree_Type counterSpell_type;
  typedef ::xsd::cxx::tree::traits< counterSpell_type, char > counterSpell_traits;

  const counterSpell_type&
  counterSpell () const;

  counterSpell_type&
  counterSpell ();

  void
  counterSpell (const counterSpell_type& x);

  void
  counterSpell (::std::auto_ptr< counterSpell_type > p);

  static const counterSpell_type&
  counterSpell_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_Type_XMLTree_Type (const type_type&,
                                     const school_type&);

  RPG_Magic_Spell_Type_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Type_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Type_XMLTree_Type (const RPG_Magic_Spell_Type_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Type_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_Type_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< school_type > school_;
  subSchool_optional subSchool_;
  descriptor_sequence descriptor_;
  ::xsd::cxx::tree::one< counterSpell_type > counterSpell_;
  static const counterSpell_type counterSpell_default_value_;
};

bool
operator== (const RPG_Magic_Spell_Type_XMLTree_Type&, const RPG_Magic_Spell_Type_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_Type_XMLTree_Type&, const RPG_Magic_Spell_Type_XMLTree_Type&);


class RPG_Magic_CasterClassUnion_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SUBCLASS_NONE,
    SUBCLASS_AVENGER,
    SUBCLASS_BARBARIAN,
    SUBCLASS_BARD,
    SUBCLASS_CLERIC,
    SUBCLASS_DRUID,
    SUBCLASS_FIGHTER,
    SUBCLASS_INVOKER,
    SUBCLASS_MONK,
    SUBCLASS_PALADIN,
    SUBCLASS_RANGER,
    SUBCLASS_SHAMAN,
    SUBCLASS_SORCERER,
    SUBCLASS_THIEF,
    SUBCLASS_WARLOCK,
    SUBCLASS_WARLORD,
    SUBCLASS_WIZARD,
    DOMAIN_NONE,
    DOMAIN_AIR,
    DOMAIN_ANIMAL,
    DOMAIN_CHAOS,
    DOMAIN_DEATH,
    DOMAIN_DESTRUCTION,
    DOMAIN_EARTH,
    DOMAIN_EVIL,
    DOMAIN_FIRE,
    DOMAIN_GOOD,
    DOMAIN_HEALING,
    DOMAIN_KNOWLEDGE,
    DOMAIN_LAW,
    DOMAIN_LUCK,
    DOMAIN_MAGIC,
    DOMAIN_PLANT,
    DOMAIN_PROTECTION,
    DOMAIN_STRENGTH,
    DOMAIN_SUN,
    DOMAIN_TRAVEL,
    DOMAIN_TRICKERY,
    DOMAIN_WAR,
    DOMAIN_WATER
  };

  RPG_Magic_CasterClassUnion_XMLTree_Type (value v);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const char* v);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const ::std::string& v);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_CasterClassUnion_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Magic_CasterClassUnion_XMLTree_Type (const RPG_Magic_CasterClassUnion_XMLTree_Type& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  virtual RPG_Magic_CasterClassUnion_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_CasterClassUnion_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_literals_[40];
  static const value _xsd_RPG_Magic_CasterClassUnion_XMLTree_Type_indexes_[40];
};

class RPG_Magic_Spell_Level_XMLTree_Type: public ::xml_schema::type
{
  public:
  // casterClass
  // 
  typedef ::RPG_Magic_CasterClassUnion_XMLTree_Type casterClass_type;
  typedef ::xsd::cxx::tree::traits< casterClass_type, char > casterClass_traits;

  const casterClass_type&
  casterClass () const;

  casterClass_type&
  casterClass ();

  void
  casterClass (const casterClass_type& x);

  void
  casterClass (::std::auto_ptr< casterClass_type > p);

  // level
  // 
  typedef ::xml_schema::unsigned_byte level_type;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_type&
  level () const;

  level_type&
  level ();

  void
  level (const level_type& x);

  // Constructors.
  //
  RPG_Magic_Spell_Level_XMLTree_Type (const casterClass_type&,
                                      const level_type&);

  RPG_Magic_Spell_Level_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Level_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Level_XMLTree_Type (const RPG_Magic_Spell_Level_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Level_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_Level_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< casterClass_type > casterClass_;
  ::xsd::cxx::tree::one< level_type > level_;
};

bool
operator== (const RPG_Magic_Spell_Level_XMLTree_Type&, const RPG_Magic_Spell_Level_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_Level_XMLTree_Type&, const RPG_Magic_Spell_Level_XMLTree_Type&);


class RPG_Magic_Spell_CastingTime_XMLTree_Type: public ::xml_schema::type
{
  public:
  // rounds
  // 
  typedef ::xml_schema::unsigned_int rounds_type;
  typedef ::xsd::cxx::tree::optional< rounds_type > rounds_optional;
  typedef ::xsd::cxx::tree::traits< rounds_type, char > rounds_traits;

  const rounds_optional&
  rounds () const;

  rounds_optional&
  rounds ();

  void
  rounds (const rounds_type& x);

  void
  rounds (const rounds_optional& x);

  // action
  // 
  typedef ::RPG_Common_ActionType_XMLTree_Type action_type;
  typedef ::xsd::cxx::tree::traits< action_type, char > action_traits;

  const action_type&
  action () const;

  action_type&
  action ();

  void
  action (const action_type& x);

  void
  action (::std::auto_ptr< action_type > p);

  static const action_type&
  action_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_CastingTime_XMLTree_Type ();

  RPG_Magic_Spell_CastingTime_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_CastingTime_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_CastingTime_XMLTree_Type (const RPG_Magic_Spell_CastingTime_XMLTree_Type& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_CastingTime_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_CastingTime_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  rounds_optional rounds_;
  ::xsd::cxx::tree::one< action_type > action_;
  static const action_type action_default_value_;
};

bool
operator== (const RPG_Magic_Spell_CastingTime_XMLTree_Type&, const RPG_Magic_Spell_CastingTime_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_CastingTime_XMLTree_Type&, const RPG_Magic_Spell_CastingTime_XMLTree_Type&);


class RPG_Magic_Spell_RangeEffect_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    RANGEEFFECT_PERSONAL,
    RANGEEFFECT_TOUCH,
    RANGEEFFECT_CLOSE,
    RANGEEFFECT_MEDIUM,
    RANGEEFFECT_LONG,
    RANGEEFFECT_UNLIMITED,
    RANGEEFFECT_RANGED
  };

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (value v);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const char* v);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeEffect_XMLTree_Type (const RPG_Magic_Spell_RangeEffect_XMLTree_Type& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_RangeEffect_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_RangeEffect_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_literals_[7];
  static const value _xsd_RPG_Magic_Spell_RangeEffect_XMLTree_Type_indexes_[7];
};

class RPG_Magic_Spell_RangeProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // max
  // 
  typedef ::xml_schema::unsigned_int max_type;
  typedef ::xsd::cxx::tree::optional< max_type > max_optional;
  typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

  const max_optional&
  max () const;

  max_optional&
  max ();

  void
  max (const max_type& x);

  void
  max (const max_optional& x);

  // increment
  // 
  typedef ::xml_schema::unsigned_int increment_type;
  typedef ::xsd::cxx::tree::optional< increment_type > increment_optional;
  typedef ::xsd::cxx::tree::traits< increment_type, char > increment_traits;

  const increment_optional&
  increment () const;

  increment_optional&
  increment ();

  void
  increment (const increment_type& x);

  void
  increment (const increment_optional& x);

  // effect
  // 
  typedef ::RPG_Magic_Spell_RangeEffect_XMLTree_Type effect_type;
  typedef ::xsd::cxx::tree::traits< effect_type, char > effect_traits;

  const effect_type&
  effect () const;

  effect_type&
  effect ();

  void
  effect (const effect_type& x);

  void
  effect (::std::auto_ptr< effect_type > p);

  static const effect_type&
  effect_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_RangeProperties_XMLTree_Type ();

  RPG_Magic_Spell_RangeProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  RPG_Magic_Spell_RangeProperties_XMLTree_Type (const RPG_Magic_Spell_RangeProperties_XMLTree_Type& x,
                                                ::xml_schema::flags f = 0,
                                                ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_RangeProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_RangeProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  max_optional max_;
  increment_optional increment_;
  ::xsd::cxx::tree::one< effect_type > effect_;
  static const effect_type effect_default_value_;
};

bool
operator== (const RPG_Magic_Spell_RangeProperties_XMLTree_Type&, const RPG_Magic_Spell_RangeProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_RangeProperties_XMLTree_Type&, const RPG_Magic_Spell_RangeProperties_XMLTree_Type&);


class RPG_Magic_Spell_Target_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    TARGET_SELF,
    TARGET_FIX,
    TARGET_VARIABLE,
    TARGET_LOCATION,
    TARGET_AREA
  };

  RPG_Magic_Spell_Target_XMLTree_Type (value v);

  RPG_Magic_Spell_Target_XMLTree_Type (const char* v);

  RPG_Magic_Spell_Target_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_Target_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_Target_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Target_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Target_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Target_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Target_XMLTree_Type (const RPG_Magic_Spell_Target_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Target_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_Target_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_Target_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_Target_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Magic_Spell_Target_XMLTree_Type_indexes_[5];
};

class RPG_Magic_Spell_AreaOfEffect_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    EFFECT_BURST,
    EFFECT_EMANATION,
    EFFECT_SPREAD
  };

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (value v);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const char* v);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type (const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_AreaOfEffect_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Magic_Spell_AreaOfEffect_XMLTree_Type_indexes_[3];
};

class RPG_Magic_Spell_TargetProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_Spell_Target_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // value
  // 
  typedef ::xml_schema::unsigned_int value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  // range
  // 
  typedef ::RPG_Dice_Roll_XMLTree_Type range_type;
  typedef ::xsd::cxx::tree::optional< range_type > range_optional;
  typedef ::xsd::cxx::tree::traits< range_type, char > range_traits;

  const range_optional&
  range () const;

  range_optional&
  range ();

  void
  range (const range_type& x);

  void
  range (const range_optional& x);

  void
  range (::std::auto_ptr< range_type > p);

  // levelIncrement
  // 
  typedef ::xml_schema::unsigned_byte levelIncrement_type;
  typedef ::xsd::cxx::tree::optional< levelIncrement_type > levelIncrement_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrement_type, char > levelIncrement_traits;

  const levelIncrement_optional&
  levelIncrement () const;

  levelIncrement_optional&
  levelIncrement ();

  void
  levelIncrement (const levelIncrement_type& x);

  void
  levelIncrement (const levelIncrement_optional& x);

  // effect
  // 
  typedef ::RPG_Magic_Spell_AreaOfEffect_XMLTree_Type effect_type;
  typedef ::xsd::cxx::tree::optional< effect_type > effect_optional;
  typedef ::xsd::cxx::tree::traits< effect_type, char > effect_traits;

  const effect_optional&
  effect () const;

  effect_optional&
  effect ();

  void
  effect (const effect_type& x);

  void
  effect (const effect_optional& x);

  void
  effect (::std::auto_ptr< effect_type > p);

  // shape
  // 
  typedef ::RPG_Common_AreaOfEffect_XMLTree_Type shape_type;
  typedef ::xsd::cxx::tree::optional< shape_type > shape_optional;
  typedef ::xsd::cxx::tree::traits< shape_type, char > shape_traits;

  const shape_optional&
  shape () const;

  shape_optional&
  shape ();

  void
  shape (const shape_type& x);

  void
  shape (const shape_optional& x);

  void
  shape (::std::auto_ptr< shape_type > p);

  // radius
  // 
  typedef ::xml_schema::unsigned_byte radius_type;
  typedef ::xsd::cxx::tree::optional< radius_type > radius_optional;
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  const radius_optional&
  radius () const;

  radius_optional&
  radius ();

  void
  radius (const radius_type& x);

  void
  radius (const radius_optional& x);

  // height
  // 
  typedef ::xml_schema::unsigned_byte height_type;
  typedef ::xsd::cxx::tree::optional< height_type > height_optional;
  typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

  const height_optional&
  height () const;

  height_optional&
  height ();

  void
  height (const height_type& x);

  void
  height (const height_optional& x);

  // rangeIsInHD
  // 
  typedef ::xml_schema::boolean rangeIsInHD_type;
  typedef ::xsd::cxx::tree::traits< rangeIsInHD_type, char > rangeIsInHD_traits;

  const rangeIsInHD_type&
  rangeIsInHD () const;

  rangeIsInHD_type&
  rangeIsInHD ();

  void
  rangeIsInHD (const rangeIsInHD_type& x);

  static rangeIsInHD_type
  rangeIsInHD_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_TargetProperties_XMLTree_Type (const type_type&);

  RPG_Magic_Spell_TargetProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Magic_Spell_TargetProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Magic_Spell_TargetProperties_XMLTree_Type (const RPG_Magic_Spell_TargetProperties_XMLTree_Type& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_TargetProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_TargetProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  value_optional value_;
  range_optional range_;
  levelIncrement_optional levelIncrement_;
  effect_optional effect_;
  shape_optional shape_;
  radius_optional radius_;
  height_optional height_;
  ::xsd::cxx::tree::one< rangeIsInHD_type > rangeIsInHD_;
};

bool
operator== (const RPG_Magic_Spell_TargetProperties_XMLTree_Type&, const RPG_Magic_Spell_TargetProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_TargetProperties_XMLTree_Type&, const RPG_Magic_Spell_TargetProperties_XMLTree_Type&);


class RPG_Magic_Spell_Duration_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    DURATION_TIMED,
    DURATION_INSTANTANEOUS,
    DURATION_PERMANENT,
    DURATION_CONCENTRATION,
    DURATION_DISCHARGE
  };

  RPG_Magic_Spell_Duration_XMLTree_Type (value v);

  RPG_Magic_Spell_Duration_XMLTree_Type (const char* v);

  RPG_Magic_Spell_Duration_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_Duration_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_Duration_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Duration_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Duration_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Duration_XMLTree_Type (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Duration_XMLTree_Type (const RPG_Magic_Spell_Duration_XMLTree_Type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Duration_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_Duration_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Magic_Spell_Duration_XMLTree_Type_indexes_[5];
};

class RPG_Magic_Spell_DurationProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_Spell_Duration_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // base
  // 
  typedef ::xml_schema::unsigned_int base_type;
  typedef ::xsd::cxx::tree::optional< base_type > base_optional;
  typedef ::xsd::cxx::tree::traits< base_type, char > base_traits;

  const base_optional&
  base () const;

  base_optional&
  base ();

  void
  base (const base_type& x);

  void
  base (const base_optional& x);

  // duration
  // 
  typedef ::xml_schema::unsigned_int duration_type;
  typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
  typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

  const duration_optional&
  duration () const;

  duration_optional&
  duration ();

  void
  duration (const duration_type& x);

  void
  duration (const duration_optional& x);

  // levelIncrement
  // 
  typedef ::xml_schema::unsigned_byte levelIncrement_type;
  typedef ::xsd::cxx::tree::optional< levelIncrement_type > levelIncrement_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrement_type, char > levelIncrement_traits;

  const levelIncrement_optional&
  levelIncrement () const;

  levelIncrement_optional&
  levelIncrement ();

  void
  levelIncrement (const levelIncrement_type& x);

  void
  levelIncrement (const levelIncrement_optional& x);

  // levelIncrementMax
  // 
  typedef ::xml_schema::unsigned_byte levelIncrementMax_type;
  typedef ::xsd::cxx::tree::optional< levelIncrementMax_type > levelIncrementMax_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrementMax_type, char > levelIncrementMax_traits;

  const levelIncrementMax_optional&
  levelIncrementMax () const;

  levelIncrementMax_optional&
  levelIncrementMax ();

  void
  levelIncrementMax (const levelIncrementMax_type& x);

  void
  levelIncrementMax (const levelIncrementMax_optional& x);

  // period
  // 
  typedef ::RPG_Dice_Roll_XMLTree_Type period_type;
  typedef ::xsd::cxx::tree::optional< period_type > period_optional;
  typedef ::xsd::cxx::tree::traits< period_type, char > period_traits;

  const period_optional&
  period () const;

  period_optional&
  period ();

  void
  period (const period_type& x);

  void
  period (const period_optional& x);

  void
  period (::std::auto_ptr< period_type > p);

  // dismissible
  // 
  typedef ::xml_schema::boolean dismissible_type;
  typedef ::xsd::cxx::tree::traits< dismissible_type, char > dismissible_traits;

  const dismissible_type&
  dismissible () const;

  dismissible_type&
  dismissible ();

  void
  dismissible (const dismissible_type& x);

  static dismissible_type
  dismissible_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_DurationProperties_XMLTree_Type (const type_type&);

  RPG_Magic_Spell_DurationProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  RPG_Magic_Spell_DurationProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  RPG_Magic_Spell_DurationProperties_XMLTree_Type (const RPG_Magic_Spell_DurationProperties_XMLTree_Type& x,
                                                   ::xml_schema::flags f = 0,
                                                   ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_DurationProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_DurationProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  base_optional base_;
  duration_optional duration_;
  levelIncrement_optional levelIncrement_;
  levelIncrementMax_optional levelIncrementMax_;
  period_optional period_;
  ::xsd::cxx::tree::one< dismissible_type > dismissible_;
};

bool
operator== (const RPG_Magic_Spell_DurationProperties_XMLTree_Type&, const RPG_Magic_Spell_DurationProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_DurationProperties_XMLTree_Type&, const RPG_Magic_Spell_DurationProperties_XMLTree_Type&);


class RPG_Magic_Spell_Precondition_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    PRECONDITION_ALIGNMENT_ETHIC,
    PRECONDITION_ATTRIBUTE_MAX,
    PRECONDITION_CONDITION,
    PRECONDITION_HD_MAX,
    PRECONDITION_MANUFACTURED,
    PRECONDITION_NONMAGICAL,
    PRECONDITION_OBJECT,
    PRECONDITION_RANGED_TOUCH_ATTACK,
    PRECONDITION_SIZE_MAX,
    PRECONDITION_SIZE_RELATIVE,
    PRECONDITION_TYPE
  };

  RPG_Magic_Spell_Precondition_XMLTree_Type (value v);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const char* v);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_Precondition_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Precondition_XMLTree_Type (const RPG_Magic_Spell_Precondition_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Precondition_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_Precondition_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_literals_[11];
  static const value _xsd_RPG_Magic_Spell_Precondition_XMLTree_Type_indexes_[11];
};

class RPG_Magic_Spell_PreconditionProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_Spell_Precondition_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // value
  // 
  typedef ::xml_schema::integer value_type;
  typedef ::xsd::cxx::tree::optional< value_type > value_optional;
  typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

  const value_optional&
  value () const;

  value_optional&
  value ();

  void
  value (const value_type& x);

  void
  value (const value_optional& x);

  // levelIncrement
  // 
  typedef ::xml_schema::unsigned_byte levelIncrement_type;
  typedef ::xsd::cxx::tree::optional< levelIncrement_type > levelIncrement_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrement_type, char > levelIncrement_traits;

  const levelIncrement_optional&
  levelIncrement () const;

  levelIncrement_optional&
  levelIncrement ();

  void
  levelIncrement (const levelIncrement_type& x);

  void
  levelIncrement (const levelIncrement_optional& x);

  // levelIncrementMax
  // 
  typedef ::xml_schema::unsigned_byte levelIncrementMax_type;
  typedef ::xsd::cxx::tree::optional< levelIncrementMax_type > levelIncrementMax_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrementMax_type, char > levelIncrementMax_traits;

  const levelIncrementMax_optional&
  levelIncrementMax () const;

  levelIncrementMax_optional&
  levelIncrementMax ();

  void
  levelIncrementMax (const levelIncrementMax_type& x);

  void
  levelIncrementMax (const levelIncrementMax_optional& x);

  // ethic
  // 
  typedef ::RPG_Character_AlignmentEthic_XMLTree_Type ethic_type;
  typedef ::xsd::cxx::tree::optional< ethic_type > ethic_optional;
  typedef ::xsd::cxx::tree::traits< ethic_type, char > ethic_traits;

  const ethic_optional&
  ethic () const;

  ethic_optional&
  ethic ();

  void
  ethic (const ethic_type& x);

  void
  ethic (const ethic_optional& x);

  void
  ethic (::std::auto_ptr< ethic_type > p);

  // attribute
  // 
  typedef ::RPG_Common_Attribute_XMLTree_Type attribute_type;
  typedef ::xsd::cxx::tree::optional< attribute_type > attribute_optional;
  typedef ::xsd::cxx::tree::traits< attribute_type, char > attribute_traits;

  const attribute_optional&
  attribute () const;

  attribute_optional&
  attribute ();

  void
  attribute (const attribute_type& x);

  void
  attribute (const attribute_optional& x);

  void
  attribute (::std::auto_ptr< attribute_type > p);

  // condition
  // 
  typedef ::RPG_Common_Condition_XMLTree_Type condition_type;
  typedef ::xsd::cxx::tree::optional< condition_type > condition_optional;
  typedef ::xsd::cxx::tree::traits< condition_type, char > condition_traits;

  const condition_optional&
  condition () const;

  condition_optional&
  condition ();

  void
  condition (const condition_type& x);

  void
  condition (const condition_optional& x);

  void
  condition (::std::auto_ptr< condition_type > p);

  // creature
  // 
  typedef ::RPG_Common_CreatureType_XMLTree_Type creature_type;
  typedef ::xsd::cxx::tree::sequence< creature_type > creature_sequence;
  typedef creature_sequence::iterator creature_iterator;
  typedef creature_sequence::const_iterator creature_const_iterator;
  typedef ::xsd::cxx::tree::traits< creature_type, char > creature_traits;

  const creature_sequence&
  creature () const;

  creature_sequence&
  creature ();

  void
  creature (const creature_sequence& s);

  // size
  // 
  typedef ::RPG_Common_Size_XMLTree_Type size_type;
  typedef ::xsd::cxx::tree::optional< size_type > size_optional;
  typedef ::xsd::cxx::tree::traits< size_type, char > size_traits;

  const size_optional&
  size () const;

  size_optional&
  size ();

  void
  size (const size_type& x);

  void
  size (const size_optional& x);

  void
  size (::std::auto_ptr< size_type > p);

  // reverse
  // 
  typedef ::xml_schema::boolean reverse_type;
  typedef ::xsd::cxx::tree::traits< reverse_type, char > reverse_traits;

  const reverse_type&
  reverse () const;

  reverse_type&
  reverse ();

  void
  reverse (const reverse_type& x);

  static reverse_type
  reverse_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const type_type&);

  RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_PreconditionProperties_XMLTree_Type (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type& x,
                                                       ::xml_schema::flags f = 0,
                                                       ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_PreconditionProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_PreconditionProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  value_optional value_;
  levelIncrement_optional levelIncrement_;
  levelIncrementMax_optional levelIncrementMax_;
  ethic_optional ethic_;
  attribute_optional attribute_;
  condition_optional condition_;
  creature_sequence creature_;
  size_optional size_;
  ::xsd::cxx::tree::one< reverse_type > reverse_;
};

bool
operator== (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&);


class RPG_Magic_Spell_Effect_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SPELLEFFECT_ABILITIY_LOSS_MAGICAL_ALL,
    SPELLEFFECT_ABILITIY_LOSS_MAGICAL_EXTRAORDINARY,
    SPELLEFFECT_ABILITIY_LOSS_MAGICAL_SPELLLIKE,
    SPELLEFFECT_ABILITIY_LOSS_MAGICAL_SUPERNATURAL,
    SPELLEFFECT_ALIGN_WEAPON,
    SPELLEFFECT_ANIMATE_ANIMAL,
    SPELLEFFECT_ANIMATE_DEAD,
    SPELLEFFECT_ANIMATE_PLANT,
    SPELLEFFECT_ATONEMENT,
    SPELLEFFECT_AUGURY,
    SPELLEFFECT_BANISH_CREATURE,
    SPELLEFFECT_BARRIER_CREATURE,
    SPELLEFFECT_BARRIER_MAGIC,
    SPELLEFFECT_DAMAGE,
    SPELLEFFECT_DAZE,
    SPELLEFFECT_DETECT_MAGIC,
    SPELLEFFECT_ENTANGLE,
    SPELLEFFECT_FASCINATE,
    SPELLEFFECT_GROW,
    SPELLEFFECT_HOLD_CREATURE,
    SPELLEFFECT_IDENTIFY,
    SPELLEFFECT_KILL,
    SPELLEFFECT_LEVITATE,
    SPELLEFFECT_LOCK,
    SPELLEFFECT_MARK,
    SPELLEFFECT_MESSENGER,
    SPELLEFFECT_MODIFIER_ARMOR_CLASS,
    SPELLEFFECT_MODIFIER_ATTACK_ROLL,
    SPELLEFFECT_MODIFIER_ATTRIBUTE,
    SPELLEFFECT_MODIFIER_CHECK_ATTRIBUTE_ALL,
    SPELLEFFECT_MODIFIER_CHECK_SKILL_ALL,
    SPELLEFFECT_MODIFIER_HP,
    SPELLEFFECT_MODIFIER_MORALE,
    SPELLEFFECT_MODIFIER_SAVE_ALL,
    SPELLEFFECT_MODIFIER_SAVE_FEAR,
    SPELLEFFECT_MODIFIER_SAVE_REFLEX,
    SPELLEFFECT_PARALYSIS,
    SPELLEFFECT_POLYMORPH,
    SPELLEFFECT_RAISE_DEAD,
    SPELLEFFECT_SENSOR_VISUAL,
    SPELLEFFECT_TELEPORT_INTERPLANAR,
    SPELLEFFECT_TRIGGER_ALARM
  };

  RPG_Magic_Spell_Effect_XMLTree_Type (value v);

  RPG_Magic_Spell_Effect_XMLTree_Type (const char* v);

  RPG_Magic_Spell_Effect_XMLTree_Type (const ::std::string& v);

  RPG_Magic_Spell_Effect_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_Spell_Effect_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Effect_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Effect_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Effect_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Magic_Spell_Effect_XMLTree_Type (const RPG_Magic_Spell_Effect_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_Effect_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_Spell_Effect_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_literals_[42];
  static const value _xsd_RPG_Magic_Spell_Effect_XMLTree_Type_indexes_[42];
};

class RPG_Magic_CheckTypeUnion_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    SKILL_APPRAISE,
    SKILL_BALANCE,
    SKILL_BLUFF,
    SKILL_CLIMB,
    SKILL_CONCENTRATION,
    SKILL_CRAFT_ANY,
    SKILL_CRAFT_ALL,
    SKILL_CRAFT_ALCHEMY,
    SKILL_CRAFT_FLETCHER,
    SKILL_CRAFT_BOWYER,
    SKILL_CRAFT_SMITH_ARMOR,
    SKILL_CRAFT_SMITH_BLACK,
    SKILL_CRAFT_SMITH_WEAPON,
    SKILL_CRAFT_TRAP,
    SKILL_CRAFT_OTHER,
    SKILL_DECIPHER_SCRIPT,
    SKILL_DIPLOMACY,
    SKILL_DISABLE_DEVICE,
    SKILL_DISGUISE,
    SKILL_ESCAPE_ARTIST,
    SKILL_FORGERY,
    SKILL_GATHER_INFORMATION,
    SKILL_HANDLE_ANIMAL,
    SKILL_HEAL,
    SKILL_HIDE,
    SKILL_INTIMIDATE,
    SKILL_JUMP,
    SKILL_KNOWLEDGE_ANY,
    SKILL_KNOWLEDGE_ALL,
    SKILL_KNOWLEDGE_ARCANA,
    SKILL_KNOWLEDGE_ARCHITECTURE_ENGINEERING,
    SKILL_KNOWLEDGE_DUNGEONS,
    SKILL_KNOWLEDGE_GEOGRAPHY,
    SKILL_KNOWLEDGE_HISTORY,
    SKILL_KNOWLEDGE_LOCAL,
    SKILL_KNOWLEDGE_NATURE,
    SKILL_KNOWLEDGE_NOBILITY_ROYALTY,
    SKILL_KNOWLEDGE_RELIGION,
    SKILL_KNOWLEDGE_PLANES,
    SKILL_LISTEN,
    SKILL_MOVE_SILENTLY,
    SKILL_OPEN_LOCK,
    SKILL_PERFORM,
    SKILL_PROFESSION,
    SKILL_RIDE,
    SKILL_SEARCH,
    SKILL_SENSE_MOTIVE,
    SKILL_SLEIGHT_OF_HAND,
    SKILL_SPEAK_LANGUAGE,
    SKILL_SPELLCRAFT,
    SKILL_SPOT,
    SKILL_SURVIVAL,
    SKILL_SWIM,
    SKILL_TUMBLE,
    SKILL_USE_MAGIC_DEVICE,
    SKILL_USE_ROPE,
    ATTRIBUTE_CHARISMA,
    ATTRIBUTE_CONSTITUTION,
    ATTRIBUTE_DEXTERITY,
    ATTRIBUTE_INTELLIGENCE,
    ATTRIBUTE_STRENGTH,
    ATTRIBUTE_WISDOM,
    ATTRIBUTE_ANY,
    CHECK_CASTER_LEVEL,
    CHECK_GRAPPLE,
    CHECK_HIT_DICE,
    SAVE_NONE,
    SAVE_FORTITUDE,
    SAVE_MAGIC,
    SAVE_REFLEX,
    SAVE_WILL
  };

  RPG_Magic_CheckTypeUnion_XMLTree_Type (value v);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const char* v);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::std::string& v);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CheckTypeUnion_XMLTree_Type (const RPG_Magic_CheckTypeUnion_XMLTree_Type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual RPG_Magic_CheckTypeUnion_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Magic_CheckTypeUnion_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_literals_[71];
  static const value _xsd_RPG_Magic_CheckTypeUnion_XMLTree_Type_indexes_[71];
};

class RPG_Magic_Check_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_CheckTypeUnion_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // difficultyClass
  // 
  typedef ::xml_schema::unsigned_byte difficultyClass_type;
  typedef ::xsd::cxx::tree::optional< difficultyClass_type > difficultyClass_optional;
  typedef ::xsd::cxx::tree::traits< difficultyClass_type, char > difficultyClass_traits;

  const difficultyClass_optional&
  difficultyClass () const;

  difficultyClass_optional&
  difficultyClass ();

  void
  difficultyClass (const difficultyClass_type& x);

  void
  difficultyClass (const difficultyClass_optional& x);

  // modifier
  // 
  typedef ::xml_schema::byte modifier_type;
  typedef ::xsd::cxx::tree::optional< modifier_type > modifier_optional;
  typedef ::xsd::cxx::tree::traits< modifier_type, char > modifier_traits;

  const modifier_optional&
  modifier () const;

  modifier_optional&
  modifier ();

  void
  modifier (const modifier_type& x);

  void
  modifier (const modifier_optional& x);

  // baseIsCasterLevel
  // 
  typedef ::xml_schema::boolean baseIsCasterLevel_type;
  typedef ::xsd::cxx::tree::traits< baseIsCasterLevel_type, char > baseIsCasterLevel_traits;

  const baseIsCasterLevel_type&
  baseIsCasterLevel () const;

  baseIsCasterLevel_type&
  baseIsCasterLevel ();

  void
  baseIsCasterLevel (const baseIsCasterLevel_type& x);

  static baseIsCasterLevel_type
  baseIsCasterLevel_default_value ();

  // Constructors.
  //
  RPG_Magic_Check_XMLTree_Type (const type_type&);

  RPG_Magic_Check_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  RPG_Magic_Check_XMLTree_Type (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  RPG_Magic_Check_XMLTree_Type (const RPG_Magic_Check_XMLTree_Type& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

  virtual RPG_Magic_Check_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Check_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  difficultyClass_optional difficultyClass_;
  modifier_optional modifier_;
  ::xsd::cxx::tree::one< baseIsCasterLevel_type > baseIsCasterLevel_;
};

bool
operator== (const RPG_Magic_Check_XMLTree_Type&, const RPG_Magic_Check_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Check_XMLTree_Type&, const RPG_Magic_Check_XMLTree_Type&);


class RPG_Magic_CounterMeasure_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Common_CounterMeasure_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // check
  // 
  typedef ::RPG_Magic_Check_XMLTree_Type check_type;
  typedef ::xsd::cxx::tree::optional< check_type > check_optional;
  typedef ::xsd::cxx::tree::traits< check_type, char > check_traits;

  const check_optional&
  check () const;

  check_optional&
  check ();

  void
  check (const check_type& x);

  void
  check (const check_optional& x);

  void
  check (::std::auto_ptr< check_type > p);

  // spell
  // 
  typedef ::RPG_Magic_SpellType_XMLTree_Type spell_type;
  typedef ::xsd::cxx::tree::sequence< spell_type > spell_sequence;
  typedef spell_sequence::iterator spell_iterator;
  typedef spell_sequence::const_iterator spell_const_iterator;
  typedef ::xsd::cxx::tree::traits< spell_type, char > spell_traits;

  const spell_sequence&
  spell () const;

  spell_sequence&
  spell ();

  void
  spell (const spell_sequence& s);

  // reduction
  // 
  typedef ::RPG_Common_SaveReductionType_XMLTree_Type reduction_type;
  typedef ::xsd::cxx::tree::traits< reduction_type, char > reduction_traits;

  const reduction_type&
  reduction () const;

  reduction_type&
  reduction ();

  void
  reduction (const reduction_type& x);

  void
  reduction (::std::auto_ptr< reduction_type > p);

  static const reduction_type&
  reduction_default_value ();

  // Constructors.
  //
  RPG_Magic_CounterMeasure_XMLTree_Type (const type_type&);

  RPG_Magic_CounterMeasure_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CounterMeasure_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  RPG_Magic_CounterMeasure_XMLTree_Type (const RPG_Magic_CounterMeasure_XMLTree_Type& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

  virtual RPG_Magic_CounterMeasure_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_CounterMeasure_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  check_optional check_;
  spell_sequence spell_;
  ::xsd::cxx::tree::one< reduction_type > reduction_;
  static const reduction_type reduction_default_value_;
};

bool
operator== (const RPG_Magic_CounterMeasure_XMLTree_Type&, const RPG_Magic_CounterMeasure_XMLTree_Type&);

bool
operator!= (const RPG_Magic_CounterMeasure_XMLTree_Type&, const RPG_Magic_CounterMeasure_XMLTree_Type&);


class RPG_Magic_Spell_EffectProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_Spell_Effect_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // damage
  // 
  typedef ::RPG_Common_PhysicalDamageType_XMLTree_Type damage_type;
  typedef ::xsd::cxx::tree::optional< damage_type > damage_optional;
  typedef ::xsd::cxx::tree::traits< damage_type, char > damage_traits;

  const damage_optional&
  damage () const;

  damage_optional&
  damage ();

  void
  damage (const damage_type& x);

  void
  damage (const damage_optional& x);

  void
  damage (::std::auto_ptr< damage_type > p);

  // base
  // 
  typedef ::RPG_Common_Amount_XMLTree_Type base_type;
  typedef ::xsd::cxx::tree::optional< base_type > base_optional;
  typedef ::xsd::cxx::tree::traits< base_type, char > base_traits;

  const base_optional&
  base () const;

  base_optional&
  base ();

  void
  base (const base_type& x);

  void
  base (const base_optional& x);

  void
  base (::std::auto_ptr< base_type > p);

  // increment
  // 
  typedef ::xml_schema::unsigned_int increment_type;
  typedef ::xsd::cxx::tree::optional< increment_type > increment_optional;
  typedef ::xsd::cxx::tree::traits< increment_type, char > increment_traits;

  const increment_optional&
  increment () const;

  increment_optional&
  increment ();

  void
  increment (const increment_type& x);

  void
  increment (const increment_optional& x);

  // levelIncrement
  // 
  typedef ::RPG_Common_Amount_XMLTree_Type levelIncrement_type;
  typedef ::xsd::cxx::tree::optional< levelIncrement_type > levelIncrement_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrement_type, char > levelIncrement_traits;

  const levelIncrement_optional&
  levelIncrement () const;

  levelIncrement_optional&
  levelIncrement ();

  void
  levelIncrement (const levelIncrement_type& x);

  void
  levelIncrement (const levelIncrement_optional& x);

  void
  levelIncrement (::std::auto_ptr< levelIncrement_type > p);

  // levelIncrementMax
  // 
  typedef ::xml_schema::unsigned_byte levelIncrementMax_type;
  typedef ::xsd::cxx::tree::optional< levelIncrementMax_type > levelIncrementMax_optional;
  typedef ::xsd::cxx::tree::traits< levelIncrementMax_type, char > levelIncrementMax_traits;

  const levelIncrementMax_optional&
  levelIncrementMax () const;

  levelIncrementMax_optional&
  levelIncrementMax ();

  void
  levelIncrementMax (const levelIncrementMax_type& x);

  void
  levelIncrementMax (const levelIncrementMax_optional& x);

  // attribute
  // 
  typedef ::RPG_Common_Attribute_XMLTree_Type attribute_type;
  typedef ::xsd::cxx::tree::optional< attribute_type > attribute_optional;
  typedef ::xsd::cxx::tree::traits< attribute_type, char > attribute_traits;

  const attribute_optional&
  attribute () const;

  attribute_optional&
  attribute ();

  void
  attribute (const attribute_type& x);

  void
  attribute (const attribute_optional& x);

  void
  attribute (::std::auto_ptr< attribute_type > p);

  // duration
  // 
  typedef ::RPG_Common_Amount_XMLTree_Type duration_type;
  typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
  typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

  const duration_optional&
  duration () const;

  duration_optional&
  duration ();

  void
  duration (const duration_type& x);

  void
  duration (const duration_optional& x);

  void
  duration (::std::auto_ptr< duration_type > p);

  // maxRange
  // 
  typedef ::xml_schema::unsigned_byte maxRange_type;
  typedef ::xsd::cxx::tree::optional< maxRange_type > maxRange_optional;
  typedef ::xsd::cxx::tree::traits< maxRange_type, char > maxRange_traits;

  const maxRange_optional&
  maxRange () const;

  maxRange_optional&
  maxRange ();

  void
  maxRange (const maxRange_type& x);

  void
  maxRange (const maxRange_optional& x);

  // counterMeasure
  // 
  typedef ::RPG_Magic_CounterMeasure_XMLTree_Type counterMeasure_type;
  typedef ::xsd::cxx::tree::sequence< counterMeasure_type > counterMeasure_sequence;
  typedef counterMeasure_sequence::iterator counterMeasure_iterator;
  typedef counterMeasure_sequence::const_iterator counterMeasure_const_iterator;
  typedef ::xsd::cxx::tree::traits< counterMeasure_type, char > counterMeasure_traits;

  const counterMeasure_sequence&
  counterMeasure () const;

  counterMeasure_sequence&
  counterMeasure ();

  void
  counterMeasure (const counterMeasure_sequence& s);

  // includeAdjacent
  // 
  typedef ::xml_schema::boolean includeAdjacent_type;
  typedef ::xsd::cxx::tree::traits< includeAdjacent_type, char > includeAdjacent_traits;

  const includeAdjacent_type&
  includeAdjacent () const;

  includeAdjacent_type&
  includeAdjacent ();

  void
  includeAdjacent (const includeAdjacent_type& x);

  static includeAdjacent_type
  includeAdjacent_default_value ();

  // effectsAreInclusive
  // 
  typedef ::xml_schema::boolean effectsAreInclusive_type;
  typedef ::xsd::cxx::tree::traits< effectsAreInclusive_type, char > effectsAreInclusive_traits;

  const effectsAreInclusive_type&
  effectsAreInclusive () const;

  effectsAreInclusive_type&
  effectsAreInclusive ();

  void
  effectsAreInclusive (const effectsAreInclusive_type& x);

  static effectsAreInclusive_type
  effectsAreInclusive_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_EffectProperties_XMLTree_Type (const type_type&);

  RPG_Magic_Spell_EffectProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Magic_Spell_EffectProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Magic_Spell_EffectProperties_XMLTree_Type (const RPG_Magic_Spell_EffectProperties_XMLTree_Type& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_EffectProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_EffectProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  damage_optional damage_;
  base_optional base_;
  increment_optional increment_;
  levelIncrement_optional levelIncrement_;
  levelIncrementMax_optional levelIncrementMax_;
  attribute_optional attribute_;
  duration_optional duration_;
  maxRange_optional maxRange_;
  counterMeasure_sequence counterMeasure_;
  ::xsd::cxx::tree::one< includeAdjacent_type > includeAdjacent_;
  ::xsd::cxx::tree::one< effectsAreInclusive_type > effectsAreInclusive_;
};

bool
operator== (const RPG_Magic_Spell_EffectProperties_XMLTree_Type&, const RPG_Magic_Spell_EffectProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_EffectProperties_XMLTree_Type&, const RPG_Magic_Spell_EffectProperties_XMLTree_Type&);


class RPG_Magic_Spell_PropertiesXML_XMLTree_Type: public ::xml_schema::type
{
  public:
  // name
  // 
  typedef ::xml_schema::string name_type;
  typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

  const name_type&
  name () const;

  name_type&
  name ();

  void
  name (const name_type& x);

  void
  name (::std::auto_ptr< name_type > p);

  // type
  // 
  typedef ::RPG_Magic_Spell_Type_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // level
  // 
  typedef ::RPG_Magic_Spell_Level_XMLTree_Type level_type;
  typedef ::xsd::cxx::tree::sequence< level_type > level_sequence;
  typedef level_sequence::iterator level_iterator;
  typedef level_sequence::const_iterator level_const_iterator;
  typedef ::xsd::cxx::tree::traits< level_type, char > level_traits;

  const level_sequence&
  level () const;

  level_sequence&
  level ();

  void
  level (const level_sequence& s);

  // cost
  // 
  typedef ::xml_schema::unsigned_int cost_type;
  typedef ::xsd::cxx::tree::optional< cost_type > cost_optional;
  typedef ::xsd::cxx::tree::traits< cost_type, char > cost_traits;

  const cost_optional&
  cost () const;

  cost_optional&
  cost ();

  void
  cost (const cost_type& x);

  void
  cost (const cost_optional& x);

  // time
  // 
  typedef ::RPG_Magic_Spell_CastingTime_XMLTree_Type time_type;
  typedef ::xsd::cxx::tree::optional< time_type > time_optional;
  typedef ::xsd::cxx::tree::traits< time_type, char > time_traits;

  const time_optional&
  time () const;

  time_optional&
  time ();

  void
  time (const time_type& x);

  void
  time (const time_optional& x);

  void
  time (::std::auto_ptr< time_type > p);

  // range
  // 
  typedef ::RPG_Magic_Spell_RangeProperties_XMLTree_Type range_type;
  typedef ::xsd::cxx::tree::traits< range_type, char > range_traits;

  const range_type&
  range () const;

  range_type&
  range ();

  void
  range (const range_type& x);

  void
  range (::std::auto_ptr< range_type > p);

  // target
  // 
  typedef ::RPG_Magic_Spell_TargetProperties_XMLTree_Type target_type;
  typedef ::xsd::cxx::tree::sequence< target_type > target_sequence;
  typedef target_sequence::iterator target_iterator;
  typedef target_sequence::const_iterator target_const_iterator;
  typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

  const target_sequence&
  target () const;

  target_sequence&
  target ();

  void
  target (const target_sequence& s);

  // duration
  // 
  typedef ::RPG_Magic_Spell_DurationProperties_XMLTree_Type duration_type;
  typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

  const duration_type&
  duration () const;

  duration_type&
  duration ();

  void
  duration (const duration_type& x);

  void
  duration (::std::auto_ptr< duration_type > p);

  // precondition
  // 
  typedef ::RPG_Magic_Spell_PreconditionProperties_XMLTree_Type precondition_type;
  typedef ::xsd::cxx::tree::sequence< precondition_type > precondition_sequence;
  typedef precondition_sequence::iterator precondition_iterator;
  typedef precondition_sequence::const_iterator precondition_const_iterator;
  typedef ::xsd::cxx::tree::traits< precondition_type, char > precondition_traits;

  const precondition_sequence&
  precondition () const;

  precondition_sequence&
  precondition ();

  void
  precondition (const precondition_sequence& s);

  // effect
  // 
  typedef ::RPG_Magic_Spell_EffectProperties_XMLTree_Type effect_type;
  typedef ::xsd::cxx::tree::sequence< effect_type > effect_sequence;
  typedef effect_sequence::iterator effect_iterator;
  typedef effect_sequence::const_iterator effect_const_iterator;
  typedef ::xsd::cxx::tree::traits< effect_type, char > effect_traits;

  const effect_sequence&
  effect () const;

  effect_sequence&
  effect ();

  void
  effect (const effect_sequence& s);

  // counterMeasure
  // 
  typedef ::RPG_Magic_CounterMeasure_XMLTree_Type counterMeasure_type;
  typedef ::xsd::cxx::tree::sequence< counterMeasure_type > counterMeasure_sequence;
  typedef counterMeasure_sequence::iterator counterMeasure_iterator;
  typedef counterMeasure_sequence::const_iterator counterMeasure_const_iterator;
  typedef ::xsd::cxx::tree::traits< counterMeasure_type, char > counterMeasure_traits;

  const counterMeasure_sequence&
  counterMeasure () const;

  counterMeasure_sequence&
  counterMeasure ();

  void
  counterMeasure (const counterMeasure_sequence& s);

  // saveable
  // 
  typedef ::RPG_Common_SavingThrow_XMLTree_Type saveable_type;
  typedef ::xsd::cxx::tree::traits< saveable_type, char > saveable_traits;

  const saveable_type&
  saveable () const;

  saveable_type&
  saveable ();

  void
  saveable (const saveable_type& x);

  void
  saveable (::std::auto_ptr< saveable_type > p);

  static const saveable_type&
  saveable_default_value ();

  // resistible
  // 
  typedef ::xml_schema::boolean resistible_type;
  typedef ::xsd::cxx::tree::traits< resistible_type, char > resistible_traits;

  const resistible_type&
  resistible () const;

  resistible_type&
  resistible ();

  void
  resistible (const resistible_type& x);

  static resistible_type
  resistible_default_value ();

  // Constructors.
  //
  RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const name_type&,
                                              const type_type&,
                                              const range_type&,
                                              const duration_type&);

  RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const name_type&,
                                              ::std::auto_ptr< type_type >&,
                                              ::std::auto_ptr< range_type >&,
                                              ::std::auto_ptr< duration_type >&);

  RPG_Magic_Spell_PropertiesXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Magic_Spell_PropertiesXML_XMLTree_Type (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  virtual RPG_Magic_Spell_PropertiesXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Spell_PropertiesXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< name_type > name_;
  ::xsd::cxx::tree::one< type_type > type_;
  level_sequence level_;
  cost_optional cost_;
  time_optional time_;
  ::xsd::cxx::tree::one< range_type > range_;
  target_sequence target_;
  ::xsd::cxx::tree::one< duration_type > duration_;
  precondition_sequence precondition_;
  effect_sequence effect_;
  counterMeasure_sequence counterMeasure_;
  ::xsd::cxx::tree::one< saveable_type > saveable_;
  static const saveable_type saveable_default_value_;
  ::xsd::cxx::tree::one< resistible_type > resistible_;
};

bool
operator== (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&);


class RPG_Magic_SpellLikeProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Magic_SpellType_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // casterLevel
  // 
  typedef ::xml_schema::unsigned_byte casterLevel_type;
  typedef ::xsd::cxx::tree::traits< casterLevel_type, char > casterLevel_traits;

  const casterLevel_type&
  casterLevel () const;

  casterLevel_type&
  casterLevel ();

  void
  casterLevel (const casterLevel_type& x);

  // duration
  // 
  typedef ::RPG_Common_Duration_XMLTree_Type duration_type;
  typedef ::xsd::cxx::tree::optional< duration_type > duration_optional;
  typedef ::xsd::cxx::tree::traits< duration_type, char > duration_traits;

  const duration_optional&
  duration () const;

  duration_optional&
  duration ();

  void
  duration (const duration_type& x);

  void
  duration (const duration_optional& x);

  void
  duration (::std::auto_ptr< duration_type > p);

  // save
  // 
  typedef ::RPG_Common_SavingThrowCheck_XMLTree_Type save_type;
  typedef ::xsd::cxx::tree::optional< save_type > save_optional;
  typedef ::xsd::cxx::tree::traits< save_type, char > save_traits;

  const save_optional&
  save () const;

  save_optional&
  save ();

  void
  save (const save_type& x);

  void
  save (const save_optional& x);

  void
  save (::std::auto_ptr< save_type > p);

  // Constructors.
  //
  RPG_Magic_SpellLikeProperties_XMLTree_Type (const type_type&,
                                              const casterLevel_type&);

  RPG_Magic_SpellLikeProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Magic_SpellLikeProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Magic_SpellLikeProperties_XMLTree_Type (const RPG_Magic_SpellLikeProperties_XMLTree_Type& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  virtual RPG_Magic_SpellLikeProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_SpellLikeProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< casterLevel_type > casterLevel_;
  duration_optional duration_;
  save_optional save_;
};

bool
operator== (const RPG_Magic_SpellLikeProperties_XMLTree_Type&, const RPG_Magic_SpellLikeProperties_XMLTree_Type&);

bool
operator!= (const RPG_Magic_SpellLikeProperties_XMLTree_Type&, const RPG_Magic_SpellLikeProperties_XMLTree_Type&);


class RPG_Magic_Dictionary_XMLTree_Type: public ::xml_schema::type
{
  public:
  // spell
  // 
  typedef ::RPG_Magic_Spell_PropertiesXML_XMLTree_Type spell_type;
  typedef ::xsd::cxx::tree::sequence< spell_type > spell_sequence;
  typedef spell_sequence::iterator spell_iterator;
  typedef spell_sequence::const_iterator spell_const_iterator;
  typedef ::xsd::cxx::tree::traits< spell_type, char > spell_traits;

  const spell_sequence&
  spell () const;

  spell_sequence&
  spell ();

  void
  spell (const spell_sequence& s);

  // Constructors.
  //
  RPG_Magic_Dictionary_XMLTree_Type ();

  RPG_Magic_Dictionary_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Dictionary_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Magic_Dictionary_XMLTree_Type (const RPG_Magic_Dictionary_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Magic_Dictionary_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Magic_Dictionary_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  spell_sequence spell_;
};

bool
operator== (const RPG_Magic_Dictionary_XMLTree_Type&, const RPG_Magic_Dictionary_XMLTree_Type&);

bool
operator!= (const RPG_Magic_Dictionary_XMLTree_Type&, const RPG_Magic_Dictionary_XMLTree_Type&);


#include <iosfwd>

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_School_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_School_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_SubSchool_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_SubSchool_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Descriptor_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Descriptor_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Domain_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Domain_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_SpellType_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_SpellType_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_AbilityClass_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_AbilityClass_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_AbilityType_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_AbilityType_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Type_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_CasterClassUnion_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_CasterClassUnion_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Level_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_CastingTime_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_RangeEffect_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_RangeEffect_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_RangeProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_Target_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Target_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_AreaOfEffect_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_TargetProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_Duration_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Duration_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_DurationProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_Precondition_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Precondition_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_Spell_Effect_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_Effect_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, RPG_Magic_CheckTypeUnion_XMLTree_Type::value);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_CheckTypeUnion_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Check_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_CounterMeasure_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_EffectProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_SpellLikeProperties_XMLTree_Type&);

::std::ostream&
operator<< (::std::ostream&, const RPG_Magic_Dictionary_XMLTree_Type&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& uri,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& uri,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::std::string& uri,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::std::istream& is,
                 const ::std::string& id,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& is,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& is,
                 ::xml_schema::error_handler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xercesc::InputSource& is,
                 ::xercesc::DOMErrorHandler& eh,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::RPG_Magic_Dictionary_XMLTree_Type >
spellDictionary (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f = 0,
                 const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_School_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_School_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_School_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_SubSchool_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_SubSchool_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_SubSchool_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Descriptor_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Descriptor_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Descriptor_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Domain_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Domain_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Domain_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_SpellType_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_SpellType_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_SpellType_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_AbilityClass_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_AbilityClass_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_AbilityClass_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_AbilityType_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_AbilityType_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_AbilityType_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Type_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_CasterClassUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_CasterClassUnion_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_CasterClassUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Level_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_CastingTime_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_RangeEffect_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_RangeEffect_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_RangeEffect_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_RangeProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Target_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_Target_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_Target_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_TargetProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Duration_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_Duration_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_Duration_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_DurationProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Precondition_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_Precondition_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_Precondition_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_Effect_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_Spell_Effect_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_Spell_Effect_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMAttr&, const RPG_Magic_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xml_schema::list_stream&,
            const RPG_Magic_CheckTypeUnion_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Check_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_CounterMeasure_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_EffectProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_SpellLikeProperties_XMLTree_Type&);

void
operator<< (::xercesc::DOMElement&, const RPG_Magic_Dictionary_XMLTree_Type&);

// Serialize to std::ostream.
//

void
spellDictionary (::std::ostream& os,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
spellDictionary (::std::ostream& os,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
spellDictionary (::std::ostream& os,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
spellDictionary (::xercesc::XMLFormatTarget& ft,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
spellDictionary (::xercesc::XMLFormatTarget& ft,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 ::xml_schema::error_handler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

void
spellDictionary (::xercesc::XMLFormatTarget& ft,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 ::xercesc::DOMErrorHandler& eh,
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
spellDictionary (::xercesc::DOMDocument& d,
                 const ::RPG_Magic_Dictionary_XMLTree_Type& x,
                 ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
spellDictionary (const ::RPG_Magic_Dictionary_XMLTree_Type& x, 
                 const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                 ::xml_schema::flags f = 0);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_School_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_SubSchool_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Descriptor_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Domain_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_SpellType_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_AbilityClass_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_AbilityType_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Type_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_CasterClassUnion_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Level_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_CastingTime_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_RangeEffect_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_RangeProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Target_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_AreaOfEffect_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_TargetProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Duration_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_DurationProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Precondition_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_PreconditionProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_Effect_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_CheckTypeUnion_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Check_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_CounterMeasure_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_EffectProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Spell_PropertiesXML_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_SpellLikeProperties_XMLTree_Type&);

::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Magic_Dictionary_XMLTree_Type&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___RPG_MAGIC_XML_TREE_H
