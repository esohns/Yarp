// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include "stdafx.h"
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rpg_item_XML_tree.h"

// RPG_Item_Type_XMLTree_Type
// 

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_Type_XMLTree_Type_literals_[v])
{
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const RPG_Item_Type_XMLTree_Type& v,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_Type_XMLTree_Type& RPG_Item_Type_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_Type_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_CommodityType_XMLTree_Type
// 

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[v])
{
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const RPG_Item_CommodityType_XMLTree_Type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_CommodityType_XMLTree_Type& RPG_Item_CommodityType_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_CommodityBeverage_XMLTree_Type
// 

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[v])
{
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const RPG_Item_CommodityBeverage_XMLTree_Type& v,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_CommodityBeverage_XMLTree_Type& RPG_Item_CommodityBeverage_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_CommodityLight_XMLTree_Type
// 

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[v])
{
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const RPG_Item_CommodityLight_XMLTree_Type& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_CommodityLight_XMLTree_Type& RPG_Item_CommodityLight_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_CommodityUnion_XMLTree_Type
// 

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[v])
{
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const RPG_Item_CommodityUnion_XMLTree_Type& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_CommodityUnion_XMLTree_Type& RPG_Item_CommodityUnion_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_Money_XMLTree_Type
// 

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_Money_XMLTree_Type_literals_[v])
{
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const RPG_Item_Money_XMLTree_Type& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_Money_XMLTree_Type& RPG_Item_Money_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_Money_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_WeaponCategory_XMLTree_Type
// 

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[v])
{
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const RPG_Item_WeaponCategory_XMLTree_Type& v,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_WeaponCategory_XMLTree_Type& RPG_Item_WeaponCategory_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_WeaponClass_XMLTree_Type
// 

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[v])
{
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const RPG_Item_WeaponClass_XMLTree_Type& v,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_WeaponClass_XMLTree_Type& RPG_Item_WeaponClass_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_WeaponType_XMLTree_Type
// 

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[v])
{
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const RPG_Item_WeaponType_XMLTree_Type& v,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_WeaponType_XMLTree_Type& RPG_Item_WeaponType_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_StorePrice_XMLTree_Type
// 

const RPG_Item_StorePrice_XMLTree_Type::numGoldPieces_optional& RPG_Item_StorePrice_XMLTree_Type::
numGoldPieces () const
{
  return this->numGoldPieces_;
}

RPG_Item_StorePrice_XMLTree_Type::numGoldPieces_optional& RPG_Item_StorePrice_XMLTree_Type::
numGoldPieces ()
{
  return this->numGoldPieces_;
}

void RPG_Item_StorePrice_XMLTree_Type::
numGoldPieces (const numGoldPieces_type& x)
{
  this->numGoldPieces_.set (x);
}

void RPG_Item_StorePrice_XMLTree_Type::
numGoldPieces (const numGoldPieces_optional& x)
{
  this->numGoldPieces_ = x;
}

const RPG_Item_StorePrice_XMLTree_Type::numSilverPieces_optional& RPG_Item_StorePrice_XMLTree_Type::
numSilverPieces () const
{
  return this->numSilverPieces_;
}

RPG_Item_StorePrice_XMLTree_Type::numSilverPieces_optional& RPG_Item_StorePrice_XMLTree_Type::
numSilverPieces ()
{
  return this->numSilverPieces_;
}

void RPG_Item_StorePrice_XMLTree_Type::
numSilverPieces (const numSilverPieces_type& x)
{
  this->numSilverPieces_.set (x);
}

void RPG_Item_StorePrice_XMLTree_Type::
numSilverPieces (const numSilverPieces_optional& x)
{
  this->numSilverPieces_ = x;
}


// RPG_Item_CriticalHitProperties_XMLTree_Type
// 

const RPG_Item_CriticalHitProperties_XMLTree_Type::minToHitRoll_type& RPG_Item_CriticalHitProperties_XMLTree_Type::
minToHitRoll () const
{
  return this->minToHitRoll_.get ();
}

RPG_Item_CriticalHitProperties_XMLTree_Type::minToHitRoll_type& RPG_Item_CriticalHitProperties_XMLTree_Type::
minToHitRoll ()
{
  return this->minToHitRoll_.get ();
}

void RPG_Item_CriticalHitProperties_XMLTree_Type::
minToHitRoll (const minToHitRoll_type& x)
{
  this->minToHitRoll_.set (x);
}

const RPG_Item_CriticalHitProperties_XMLTree_Type::damageModifier_type& RPG_Item_CriticalHitProperties_XMLTree_Type::
damageModifier () const
{
  return this->damageModifier_.get ();
}

RPG_Item_CriticalHitProperties_XMLTree_Type::damageModifier_type& RPG_Item_CriticalHitProperties_XMLTree_Type::
damageModifier ()
{
  return this->damageModifier_.get ();
}

void RPG_Item_CriticalHitProperties_XMLTree_Type::
damageModifier (const damageModifier_type& x)
{
  this->damageModifier_.set (x);
}


// RPG_Item_CreationCost_XMLTree_Type
// 

const RPG_Item_CreationCost_XMLTree_Type::numGoldPieces_optional& RPG_Item_CreationCost_XMLTree_Type::
numGoldPieces () const
{
  return this->numGoldPieces_;
}

RPG_Item_CreationCost_XMLTree_Type::numGoldPieces_optional& RPG_Item_CreationCost_XMLTree_Type::
numGoldPieces ()
{
  return this->numGoldPieces_;
}

void RPG_Item_CreationCost_XMLTree_Type::
numGoldPieces (const numGoldPieces_type& x)
{
  this->numGoldPieces_.set (x);
}

void RPG_Item_CreationCost_XMLTree_Type::
numGoldPieces (const numGoldPieces_optional& x)
{
  this->numGoldPieces_ = x;
}

const RPG_Item_CreationCost_XMLTree_Type::numExperiencePoints_optional& RPG_Item_CreationCost_XMLTree_Type::
numExperiencePoints () const
{
  return this->numExperiencePoints_;
}

RPG_Item_CreationCost_XMLTree_Type::numExperiencePoints_optional& RPG_Item_CreationCost_XMLTree_Type::
numExperiencePoints ()
{
  return this->numExperiencePoints_;
}

void RPG_Item_CreationCost_XMLTree_Type::
numExperiencePoints (const numExperiencePoints_type& x)
{
  this->numExperiencePoints_.set (x);
}

void RPG_Item_CreationCost_XMLTree_Type::
numExperiencePoints (const numExperiencePoints_optional& x)
{
  this->numExperiencePoints_ = x;
}


// RPG_Item_BaseProperties_XMLTree_Type
// 

const RPG_Item_BaseProperties_XMLTree_Type::baseWeight_type& RPG_Item_BaseProperties_XMLTree_Type::
baseWeight () const
{
  return this->baseWeight_.get ();
}

RPG_Item_BaseProperties_XMLTree_Type::baseWeight_type& RPG_Item_BaseProperties_XMLTree_Type::
baseWeight ()
{
  return this->baseWeight_.get ();
}

void RPG_Item_BaseProperties_XMLTree_Type::
baseWeight (const baseWeight_type& x)
{
  this->baseWeight_.set (x);
}

const RPG_Item_BaseProperties_XMLTree_Type::baseStorePrice_type& RPG_Item_BaseProperties_XMLTree_Type::
baseStorePrice () const
{
  return this->baseStorePrice_.get ();
}

RPG_Item_BaseProperties_XMLTree_Type::baseStorePrice_type& RPG_Item_BaseProperties_XMLTree_Type::
baseStorePrice ()
{
  return this->baseStorePrice_.get ();
}

void RPG_Item_BaseProperties_XMLTree_Type::
baseStorePrice (const baseStorePrice_type& x)
{
  this->baseStorePrice_.set (x);
}

void RPG_Item_BaseProperties_XMLTree_Type::
baseStorePrice (::std::auto_ptr< baseStorePrice_type > x)
{
  this->baseStorePrice_.set (x);
}

const RPG_Item_BaseProperties_XMLTree_Type::costToCreate_optional& RPG_Item_BaseProperties_XMLTree_Type::
costToCreate () const
{
  return this->costToCreate_;
}

RPG_Item_BaseProperties_XMLTree_Type::costToCreate_optional& RPG_Item_BaseProperties_XMLTree_Type::
costToCreate ()
{
  return this->costToCreate_;
}

void RPG_Item_BaseProperties_XMLTree_Type::
costToCreate (const costToCreate_type& x)
{
  this->costToCreate_.set (x);
}

void RPG_Item_BaseProperties_XMLTree_Type::
costToCreate (const costToCreate_optional& x)
{
  this->costToCreate_ = x;
}

void RPG_Item_BaseProperties_XMLTree_Type::
costToCreate (::std::auto_ptr< costToCreate_type > x)
{
  this->costToCreate_.set (x);
}


// RPG_Item_MagicalPrerequisites_XMLTree_Type
// 

const RPG_Item_MagicalPrerequisites_XMLTree_Type::minCasterLevel_optional& RPG_Item_MagicalPrerequisites_XMLTree_Type::
minCasterLevel () const
{
  return this->minCasterLevel_;
}

RPG_Item_MagicalPrerequisites_XMLTree_Type::minCasterLevel_optional& RPG_Item_MagicalPrerequisites_XMLTree_Type::
minCasterLevel ()
{
  return this->minCasterLevel_;
}

void RPG_Item_MagicalPrerequisites_XMLTree_Type::
minCasterLevel (const minCasterLevel_type& x)
{
  this->minCasterLevel_.set (x);
}

void RPG_Item_MagicalPrerequisites_XMLTree_Type::
minCasterLevel (const minCasterLevel_optional& x)
{
  this->minCasterLevel_ = x;
}


// RPG_Item_PropertiesBase_XMLTree_Type
// 

const RPG_Item_PropertiesBase_XMLTree_Type::aura_optional& RPG_Item_PropertiesBase_XMLTree_Type::
aura () const
{
  return this->aura_;
}

RPG_Item_PropertiesBase_XMLTree_Type::aura_optional& RPG_Item_PropertiesBase_XMLTree_Type::
aura ()
{
  return this->aura_;
}

void RPG_Item_PropertiesBase_XMLTree_Type::
aura (const aura_type& x)
{
  this->aura_.set (x);
}

void RPG_Item_PropertiesBase_XMLTree_Type::
aura (const aura_optional& x)
{
  this->aura_ = x;
}

void RPG_Item_PropertiesBase_XMLTree_Type::
aura (::std::auto_ptr< aura_type > x)
{
  this->aura_.set (x);
}

const RPG_Item_PropertiesBase_XMLTree_Type::prerequisites_optional& RPG_Item_PropertiesBase_XMLTree_Type::
prerequisites () const
{
  return this->prerequisites_;
}

RPG_Item_PropertiesBase_XMLTree_Type::prerequisites_optional& RPG_Item_PropertiesBase_XMLTree_Type::
prerequisites ()
{
  return this->prerequisites_;
}

void RPG_Item_PropertiesBase_XMLTree_Type::
prerequisites (const prerequisites_type& x)
{
  this->prerequisites_.set (x);
}

void RPG_Item_PropertiesBase_XMLTree_Type::
prerequisites (const prerequisites_optional& x)
{
  this->prerequisites_ = x;
}

void RPG_Item_PropertiesBase_XMLTree_Type::
prerequisites (::std::auto_ptr< prerequisites_type > x)
{
  this->prerequisites_.set (x);
}


// RPG_Item_CommodityPropertiesBase_XMLTree_Type
// 

const RPG_Item_CommodityPropertiesBase_XMLTree_Type::type_type& RPG_Item_CommodityPropertiesBase_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::type_type& RPG_Item_CommodityPropertiesBase_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Item_CommodityPropertiesBase_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Item_CommodityPropertiesBase_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Item_CommodityPropertiesBase_XMLTree_Type::subType_type& RPG_Item_CommodityPropertiesBase_XMLTree_Type::
subType () const
{
  return this->subType_.get ();
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::subType_type& RPG_Item_CommodityPropertiesBase_XMLTree_Type::
subType ()
{
  return this->subType_.get ();
}

void RPG_Item_CommodityPropertiesBase_XMLTree_Type::
subType (const subType_type& x)
{
  this->subType_.set (x);
}

void RPG_Item_CommodityPropertiesBase_XMLTree_Type::
subType (::std::auto_ptr< subType_type > x)
{
  this->subType_.set (x);
}


// RPG_Item_WeaponPropertiesBase_XMLTree_Type
// 

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::type_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::type_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::category_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
category () const
{
  return this->category_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::category_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
category ()
{
  return this->category_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
category (const category_type& x)
{
  this->category_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
category (::std::auto_ptr< category_type > x)
{
  this->category_.set (x);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::weaponClass_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
weaponClass () const
{
  return this->weaponClass_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::weaponClass_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
weaponClass ()
{
  return this->weaponClass_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
weaponClass (const weaponClass_type& x)
{
  this->weaponClass_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
weaponClass (::std::auto_ptr< weaponClass_type > x)
{
  this->weaponClass_.set (x);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::baseDamage_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
baseDamage () const
{
  return this->baseDamage_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::baseDamage_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
baseDamage ()
{
  return this->baseDamage_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
baseDamage (const baseDamage_type& x)
{
  this->baseDamage_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
baseDamage (::std::auto_ptr< baseDamage_type > x)
{
  this->baseDamage_.set (x);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::criticalHit_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
criticalHit () const
{
  return this->criticalHit_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::criticalHit_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
criticalHit ()
{
  return this->criticalHit_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
criticalHit (const criticalHit_type& x)
{
  this->criticalHit_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
criticalHit (::std::auto_ptr< criticalHit_type > x)
{
  this->criticalHit_.set (x);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::rangeIncrement_optional& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
rangeIncrement () const
{
  return this->rangeIncrement_;
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::rangeIncrement_optional& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
rangeIncrement ()
{
  return this->rangeIncrement_;
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
rangeIncrement (const rangeIncrement_type& x)
{
  this->rangeIncrement_.set (x);
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
rangeIncrement (const rangeIncrement_optional& x)
{
  this->rangeIncrement_ = x;
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::typeOfDamage_sequence& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
typeOfDamage () const
{
  return this->typeOfDamage_;
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::typeOfDamage_sequence& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
typeOfDamage ()
{
  return this->typeOfDamage_;
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
typeOfDamage (const typeOfDamage_sequence& s)
{
  this->typeOfDamage_ = s;
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::isNonLethal_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isNonLethal () const
{
  return this->isNonLethal_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isNonLethal_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isNonLethal ()
{
  return this->isNonLethal_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isNonLethal (const isNonLethal_type& x)
{
  this->isNonLethal_.set (x);
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isNonLethal_type RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isNonLethal_default_value ()
{
  return isNonLethal_type (false);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::isReachWeapon_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isReachWeapon () const
{
  return this->isReachWeapon_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isReachWeapon_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isReachWeapon ()
{
  return this->isReachWeapon_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isReachWeapon (const isReachWeapon_type& x)
{
  this->isReachWeapon_.set (x);
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isReachWeapon_type RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isReachWeapon_default_value ()
{
  return isReachWeapon_type (false);
}

const RPG_Item_WeaponPropertiesBase_XMLTree_Type::isDoubleWeapon_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isDoubleWeapon () const
{
  return this->isDoubleWeapon_.get ();
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isDoubleWeapon_type& RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isDoubleWeapon ()
{
  return this->isDoubleWeapon_.get ();
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isDoubleWeapon (const isDoubleWeapon_type& x)
{
  this->isDoubleWeapon_.set (x);
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::isDoubleWeapon_type RPG_Item_WeaponPropertiesBase_XMLTree_Type::
isDoubleWeapon_default_value ()
{
  return isDoubleWeapon_type (false);
}


// RPG_Item_WeaponPropertiesXML_XMLTree_Type
// 

const RPG_Item_WeaponPropertiesXML_XMLTree_Type::toHitModifier_optional& RPG_Item_WeaponPropertiesXML_XMLTree_Type::
toHitModifier () const
{
  return this->toHitModifier_;
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type::toHitModifier_optional& RPG_Item_WeaponPropertiesXML_XMLTree_Type::
toHitModifier ()
{
  return this->toHitModifier_;
}

void RPG_Item_WeaponPropertiesXML_XMLTree_Type::
toHitModifier (const toHitModifier_type& x)
{
  this->toHitModifier_.set (x);
}

void RPG_Item_WeaponPropertiesXML_XMLTree_Type::
toHitModifier (const toHitModifier_optional& x)
{
  this->toHitModifier_ = x;
}


// RPG_Item_ArmorCategory_XMLTree_Type
// 

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[v])
{
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const RPG_Item_ArmorCategory_XMLTree_Type& v,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_ArmorCategory_XMLTree_Type& RPG_Item_ArmorCategory_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_ArmorType_XMLTree_Type
// 

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (value v)
: ::xml_schema::string (_xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[v])
{
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const char* v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const RPG_Item_ArmorType_XMLTree_Type& v,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

RPG_Item_ArmorType_XMLTree_Type& RPG_Item_ArmorType_XMLTree_Type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[v]);

  return *this;
}


// RPG_Item_ArmorPropertiesBase_XMLTree_Type
// 

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::type_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::type_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::category_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
category () const
{
  return this->category_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::category_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
category ()
{
  return this->category_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
category (const category_type& x)
{
  this->category_.set (x);
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
category (::std::auto_ptr< category_type > x)
{
  this->category_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::baseBonus_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseBonus () const
{
  return this->baseBonus_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::baseBonus_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseBonus ()
{
  return this->baseBonus_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseBonus (const baseBonus_type& x)
{
  this->baseBonus_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::maxDexterityBonus_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
maxDexterityBonus () const
{
  return this->maxDexterityBonus_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::maxDexterityBonus_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
maxDexterityBonus ()
{
  return this->maxDexterityBonus_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
maxDexterityBonus (const maxDexterityBonus_type& x)
{
  this->maxDexterityBonus_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::checkPenalty_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
checkPenalty () const
{
  return this->checkPenalty_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::checkPenalty_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
checkPenalty ()
{
  return this->checkPenalty_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
checkPenalty (const checkPenalty_type& x)
{
  this->checkPenalty_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::arcaneSpellFailure_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
arcaneSpellFailure () const
{
  return this->arcaneSpellFailure_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::arcaneSpellFailure_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
arcaneSpellFailure ()
{
  return this->arcaneSpellFailure_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
arcaneSpellFailure (const arcaneSpellFailure_type& x)
{
  this->arcaneSpellFailure_.set (x);
}

const RPG_Item_ArmorPropertiesBase_XMLTree_Type::baseSpeed_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseSpeed () const
{
  return this->baseSpeed_.get ();
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::baseSpeed_type& RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseSpeed ()
{
  return this->baseSpeed_.get ();
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
baseSpeed (const baseSpeed_type& x)
{
  this->baseSpeed_.set (x);
}


// RPG_Item_ArmorPropertiesXML_XMLTree_Type
// 

const RPG_Item_ArmorPropertiesXML_XMLTree_Type::defenseModifier_optional& RPG_Item_ArmorPropertiesXML_XMLTree_Type::
defenseModifier () const
{
  return this->defenseModifier_;
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type::defenseModifier_optional& RPG_Item_ArmorPropertiesXML_XMLTree_Type::
defenseModifier ()
{
  return this->defenseModifier_;
}

void RPG_Item_ArmorPropertiesXML_XMLTree_Type::
defenseModifier (const defenseModifier_type& x)
{
  this->defenseModifier_.set (x);
}

void RPG_Item_ArmorPropertiesXML_XMLTree_Type::
defenseModifier (const defenseModifier_optional& x)
{
  this->defenseModifier_ = x;
}


// RPG_Item_XML_XMLTree_Type
// 

const RPG_Item_XML_XMLTree_Type::type_type& RPG_Item_XML_XMLTree_Type::
type () const
{
  return this->type_.get ();
}

RPG_Item_XML_XMLTree_Type::type_type& RPG_Item_XML_XMLTree_Type::
type ()
{
  return this->type_.get ();
}

void RPG_Item_XML_XMLTree_Type::
type (const type_type& x)
{
  this->type_.set (x);
}

void RPG_Item_XML_XMLTree_Type::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const RPG_Item_XML_XMLTree_Type::armor_optional& RPG_Item_XML_XMLTree_Type::
armor () const
{
  return this->armor_;
}

RPG_Item_XML_XMLTree_Type::armor_optional& RPG_Item_XML_XMLTree_Type::
armor ()
{
  return this->armor_;
}

void RPG_Item_XML_XMLTree_Type::
armor (const armor_type& x)
{
  this->armor_.set (x);
}

void RPG_Item_XML_XMLTree_Type::
armor (const armor_optional& x)
{
  this->armor_ = x;
}

void RPG_Item_XML_XMLTree_Type::
armor (::std::auto_ptr< armor_type > x)
{
  this->armor_.set (x);
}

const RPG_Item_XML_XMLTree_Type::commodity_optional& RPG_Item_XML_XMLTree_Type::
commodity () const
{
  return this->commodity_;
}

RPG_Item_XML_XMLTree_Type::commodity_optional& RPG_Item_XML_XMLTree_Type::
commodity ()
{
  return this->commodity_;
}

void RPG_Item_XML_XMLTree_Type::
commodity (const commodity_type& x)
{
  this->commodity_.set (x);
}

void RPG_Item_XML_XMLTree_Type::
commodity (const commodity_optional& x)
{
  this->commodity_ = x;
}

void RPG_Item_XML_XMLTree_Type::
commodity (::std::auto_ptr< commodity_type > x)
{
  this->commodity_.set (x);
}

const RPG_Item_XML_XMLTree_Type::weapon_optional& RPG_Item_XML_XMLTree_Type::
weapon () const
{
  return this->weapon_;
}

RPG_Item_XML_XMLTree_Type::weapon_optional& RPG_Item_XML_XMLTree_Type::
weapon ()
{
  return this->weapon_;
}

void RPG_Item_XML_XMLTree_Type::
weapon (const weapon_type& x)
{
  this->weapon_.set (x);
}

void RPG_Item_XML_XMLTree_Type::
weapon (const weapon_optional& x)
{
  this->weapon_ = x;
}

void RPG_Item_XML_XMLTree_Type::
weapon (::std::auto_ptr< weapon_type > x)
{
  this->weapon_.set (x);
}


// RPG_Item_InventoryXML_XMLTree_Type
// 

const RPG_Item_InventoryXML_XMLTree_Type::item_sequence& RPG_Item_InventoryXML_XMLTree_Type::
item () const
{
  return this->item_;
}

RPG_Item_InventoryXML_XMLTree_Type::item_sequence& RPG_Item_InventoryXML_XMLTree_Type::
item ()
{
  return this->item_;
}

void RPG_Item_InventoryXML_XMLTree_Type::
item (const item_sequence& s)
{
  this->item_ = s;
}


// RPG_Item_DictionaryXML_XMLTree_Type
// 

const RPG_Item_DictionaryXML_XMLTree_Type::armor_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
armor () const
{
  return this->armor_;
}

RPG_Item_DictionaryXML_XMLTree_Type::armor_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
armor ()
{
  return this->armor_;
}

void RPG_Item_DictionaryXML_XMLTree_Type::
armor (const armor_sequence& s)
{
  this->armor_ = s;
}

const RPG_Item_DictionaryXML_XMLTree_Type::commodity_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
commodity () const
{
  return this->commodity_;
}

RPG_Item_DictionaryXML_XMLTree_Type::commodity_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
commodity ()
{
  return this->commodity_;
}

void RPG_Item_DictionaryXML_XMLTree_Type::
commodity (const commodity_sequence& s)
{
  this->commodity_ = s;
}

const RPG_Item_DictionaryXML_XMLTree_Type::weapon_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
weapon () const
{
  return this->weapon_;
}

RPG_Item_DictionaryXML_XMLTree_Type::weapon_sequence& RPG_Item_DictionaryXML_XMLTree_Type::
weapon ()
{
  return this->weapon_;
}

void RPG_Item_DictionaryXML_XMLTree_Type::
weapon (const weapon_sequence& s)
{
  this->weapon_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// RPG_Item_Type_XMLTree_Type
//

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_Type_XMLTree_Type_convert ();
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_Type_XMLTree_Type_convert ();
}

RPG_Item_Type_XMLTree_Type::
RPG_Item_Type_XMLTree_Type (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_Type_XMLTree_Type_convert ();
}

RPG_Item_Type_XMLTree_Type* RPG_Item_Type_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_Type_XMLTree_Type (*this, f, c);
}

RPG_Item_Type_XMLTree_Type::value RPG_Item_Type_XMLTree_Type::
_xsd_RPG_Item_Type_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_Type_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_Type_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_Type_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_Type_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Item_Type_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_Type_XMLTree_Type::
_xsd_RPG_Item_Type_XMLTree_Type_literals_[5] =
{
  "ITEM_ARMOR",
  "ITEM_COMMODITY",
  "ITEM_OTHER",
  "ITEM_VALUABLE",
  "ITEM_WEAPON"
};

const RPG_Item_Type_XMLTree_Type::value RPG_Item_Type_XMLTree_Type::
_xsd_RPG_Item_Type_XMLTree_Type_indexes_[5] =
{
  ::RPG_Item_Type_XMLTree_Type::ITEM_ARMOR,
  ::RPG_Item_Type_XMLTree_Type::ITEM_COMMODITY,
  ::RPG_Item_Type_XMLTree_Type::ITEM_OTHER,
  ::RPG_Item_Type_XMLTree_Type::ITEM_VALUABLE,
  ::RPG_Item_Type_XMLTree_Type::ITEM_WEAPON
};

// RPG_Item_CommodityType_XMLTree_Type
//

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_CommodityType_XMLTree_Type_convert ();
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_CommodityType_XMLTree_Type_convert ();
}

RPG_Item_CommodityType_XMLTree_Type::
RPG_Item_CommodityType_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_CommodityType_XMLTree_Type_convert ();
}

RPG_Item_CommodityType_XMLTree_Type* RPG_Item_CommodityType_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CommodityType_XMLTree_Type (*this, f, c);
}

RPG_Item_CommodityType_XMLTree_Type::value RPG_Item_CommodityType_XMLTree_Type::
_xsd_RPG_Item_CommodityType_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_CommodityType_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_CommodityType_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_CommodityType_XMLTree_Type_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_CommodityType_XMLTree_Type_indexes_ + 4 || _xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_CommodityType_XMLTree_Type::
_xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[4] =
{
  "COMMODITY_BEVERAGE",
  "COMMODITY_FOOD",
  "COMMODITY_LIGHT",
  "COMMODITY_OTHER"
};

const RPG_Item_CommodityType_XMLTree_Type::value RPG_Item_CommodityType_XMLTree_Type::
_xsd_RPG_Item_CommodityType_XMLTree_Type_indexes_[4] =
{
  ::RPG_Item_CommodityType_XMLTree_Type::COMMODITY_BEVERAGE,
  ::RPG_Item_CommodityType_XMLTree_Type::COMMODITY_FOOD,
  ::RPG_Item_CommodityType_XMLTree_Type::COMMODITY_LIGHT,
  ::RPG_Item_CommodityType_XMLTree_Type::COMMODITY_OTHER
};

// RPG_Item_CommodityBeverage_XMLTree_Type
//

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert ();
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert ();
}

RPG_Item_CommodityBeverage_XMLTree_Type::
RPG_Item_CommodityBeverage_XMLTree_Type (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert ();
}

RPG_Item_CommodityBeverage_XMLTree_Type* RPG_Item_CommodityBeverage_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CommodityBeverage_XMLTree_Type (*this, f, c);
}

RPG_Item_CommodityBeverage_XMLTree_Type::value RPG_Item_CommodityBeverage_XMLTree_Type::
_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_CommodityBeverage_XMLTree_Type::
_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[3] =
{
  "COMMODITY_BEVERAGE_BEER",
  "COMMODITY_BEVERAGE_WATER",
  "COMMODITY_BEVERAGE_WINE"
};

const RPG_Item_CommodityBeverage_XMLTree_Type::value RPG_Item_CommodityBeverage_XMLTree_Type::
_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_indexes_[3] =
{
  ::RPG_Item_CommodityBeverage_XMLTree_Type::COMMODITY_BEVERAGE_BEER,
  ::RPG_Item_CommodityBeverage_XMLTree_Type::COMMODITY_BEVERAGE_WATER,
  ::RPG_Item_CommodityBeverage_XMLTree_Type::COMMODITY_BEVERAGE_WINE
};

// RPG_Item_CommodityLight_XMLTree_Type
//

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_CommodityLight_XMLTree_Type_convert ();
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_CommodityLight_XMLTree_Type_convert ();
}

RPG_Item_CommodityLight_XMLTree_Type::
RPG_Item_CommodityLight_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_CommodityLight_XMLTree_Type_convert ();
}

RPG_Item_CommodityLight_XMLTree_Type* RPG_Item_CommodityLight_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CommodityLight_XMLTree_Type (*this, f, c);
}

RPG_Item_CommodityLight_XMLTree_Type::value RPG_Item_CommodityLight_XMLTree_Type::
_xsd_RPG_Item_CommodityLight_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_CommodityLight_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_CommodityLight_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_CommodityLight_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_CommodityLight_XMLTree_Type::
_xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[5] =
{
  "COMMODITY_LIGHT_CANDLE",
  "COMMODITY_LIGHT_LAMP",
  "COMMODITY_LIGHT_LANTERN_BULLSEYE",
  "COMMODITY_LIGHT_LANTERN_HOODED",
  "COMMODITY_LIGHT_TORCH"
};

const RPG_Item_CommodityLight_XMLTree_Type::value RPG_Item_CommodityLight_XMLTree_Type::
_xsd_RPG_Item_CommodityLight_XMLTree_Type_indexes_[5] =
{
  ::RPG_Item_CommodityLight_XMLTree_Type::COMMODITY_LIGHT_CANDLE,
  ::RPG_Item_CommodityLight_XMLTree_Type::COMMODITY_LIGHT_LAMP,
  ::RPG_Item_CommodityLight_XMLTree_Type::COMMODITY_LIGHT_LANTERN_BULLSEYE,
  ::RPG_Item_CommodityLight_XMLTree_Type::COMMODITY_LIGHT_LANTERN_HOODED,
  ::RPG_Item_CommodityLight_XMLTree_Type::COMMODITY_LIGHT_TORCH
};

// RPG_Item_CommodityUnion_XMLTree_Type
//

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert ();
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert ();
}

RPG_Item_CommodityUnion_XMLTree_Type::
RPG_Item_CommodityUnion_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert ();
}

RPG_Item_CommodityUnion_XMLTree_Type* RPG_Item_CommodityUnion_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CommodityUnion_XMLTree_Type (*this, f, c);
}

RPG_Item_CommodityUnion_XMLTree_Type::value RPG_Item_CommodityUnion_XMLTree_Type::
_xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_CommodityUnion_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_CommodityUnion_XMLTree_Type_indexes_ + 8,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_CommodityUnion_XMLTree_Type_indexes_ + 8 || _xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_CommodityUnion_XMLTree_Type::
_xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[8] =
{
  "COMMODITY_BEVERAGE_BEER",
  "COMMODITY_BEVERAGE_WATER",
  "COMMODITY_BEVERAGE_WINE",
  "COMMODITY_LIGHT_CANDLE",
  "COMMODITY_LIGHT_LAMP",
  "COMMODITY_LIGHT_LANTERN_BULLSEYE",
  "COMMODITY_LIGHT_LANTERN_HOODED",
  "COMMODITY_LIGHT_TORCH"
};

const RPG_Item_CommodityUnion_XMLTree_Type::value RPG_Item_CommodityUnion_XMLTree_Type::
_xsd_RPG_Item_CommodityUnion_XMLTree_Type_indexes_[8] =
{
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_BEVERAGE_BEER,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_BEVERAGE_WATER,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_BEVERAGE_WINE,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_LIGHT_CANDLE,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_LIGHT_LAMP,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_LIGHT_LANTERN_BULLSEYE,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_LIGHT_LANTERN_HOODED,
  ::RPG_Item_CommodityUnion_XMLTree_Type::COMMODITY_LIGHT_TORCH
};

// RPG_Item_Money_XMLTree_Type
//

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_Money_XMLTree_Type_convert ();
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_Money_XMLTree_Type_convert ();
}

RPG_Item_Money_XMLTree_Type::
RPG_Item_Money_XMLTree_Type (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_Money_XMLTree_Type_convert ();
}

RPG_Item_Money_XMLTree_Type* RPG_Item_Money_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_Money_XMLTree_Type (*this, f, c);
}

RPG_Item_Money_XMLTree_Type::value RPG_Item_Money_XMLTree_Type::
_xsd_RPG_Item_Money_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_Money_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_Money_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_Money_XMLTree_Type_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_Money_XMLTree_Type_indexes_ + 6 || _xsd_RPG_Item_Money_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_Money_XMLTree_Type::
_xsd_RPG_Item_Money_XMLTree_Type_literals_[6] =
{
  "MONEY_COIN_COPPER",
  "MONEY_COIN_SILVER",
  "MONEY_COIN_GOLD",
  "MONEY_COIN_PLATINUM",
  "MONEY_GEM",
  "MONEY_PRECIOUS"
};

const RPG_Item_Money_XMLTree_Type::value RPG_Item_Money_XMLTree_Type::
_xsd_RPG_Item_Money_XMLTree_Type_indexes_[6] =
{
  ::RPG_Item_Money_XMLTree_Type::MONEY_COIN_COPPER,
  ::RPG_Item_Money_XMLTree_Type::MONEY_COIN_GOLD,
  ::RPG_Item_Money_XMLTree_Type::MONEY_COIN_PLATINUM,
  ::RPG_Item_Money_XMLTree_Type::MONEY_COIN_SILVER,
  ::RPG_Item_Money_XMLTree_Type::MONEY_GEM,
  ::RPG_Item_Money_XMLTree_Type::MONEY_PRECIOUS
};

// RPG_Item_WeaponCategory_XMLTree_Type
//

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert ();
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert ();
}

RPG_Item_WeaponCategory_XMLTree_Type::
RPG_Item_WeaponCategory_XMLTree_Type (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert ();
}

RPG_Item_WeaponCategory_XMLTree_Type* RPG_Item_WeaponCategory_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_WeaponCategory_XMLTree_Type (*this, f, c);
}

RPG_Item_WeaponCategory_XMLTree_Type::value RPG_Item_WeaponCategory_XMLTree_Type::
_xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_WeaponCategory_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_WeaponCategory_XMLTree_Type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_WeaponCategory_XMLTree_Type_indexes_ + 3 || _xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_WeaponCategory_XMLTree_Type::
_xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[3] =
{
  "WEAPONCATEGORY_SIMPLE",
  "WEAPONCATEGORY_MARTIAL",
  "WEAPONCATEGORY_EXOTIC"
};

const RPG_Item_WeaponCategory_XMLTree_Type::value RPG_Item_WeaponCategory_XMLTree_Type::
_xsd_RPG_Item_WeaponCategory_XMLTree_Type_indexes_[3] =
{
  ::RPG_Item_WeaponCategory_XMLTree_Type::WEAPONCATEGORY_EXOTIC,
  ::RPG_Item_WeaponCategory_XMLTree_Type::WEAPONCATEGORY_MARTIAL,
  ::RPG_Item_WeaponCategory_XMLTree_Type::WEAPONCATEGORY_SIMPLE
};

// RPG_Item_WeaponClass_XMLTree_Type
//

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_WeaponClass_XMLTree_Type_convert ();
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_WeaponClass_XMLTree_Type_convert ();
}

RPG_Item_WeaponClass_XMLTree_Type::
RPG_Item_WeaponClass_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_WeaponClass_XMLTree_Type_convert ();
}

RPG_Item_WeaponClass_XMLTree_Type* RPG_Item_WeaponClass_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_WeaponClass_XMLTree_Type (*this, f, c);
}

RPG_Item_WeaponClass_XMLTree_Type::value RPG_Item_WeaponClass_XMLTree_Type::
_xsd_RPG_Item_WeaponClass_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_WeaponClass_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_WeaponClass_XMLTree_Type_indexes_ + 5,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_WeaponClass_XMLTree_Type_indexes_ + 5 || _xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_WeaponClass_XMLTree_Type::
_xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[5] =
{
  "WEAPONCLASS_UNARMED",
  "WEAPONCLASS_LIGHT_MELEE",
  "WEAPONCLASS_ONE_HANDED_MELEE",
  "WEAPONCLASS_TWO_HANDED_MELEE",
  "WEAPONCLASS_RANGED"
};

const RPG_Item_WeaponClass_XMLTree_Type::value RPG_Item_WeaponClass_XMLTree_Type::
_xsd_RPG_Item_WeaponClass_XMLTree_Type_indexes_[5] =
{
  ::RPG_Item_WeaponClass_XMLTree_Type::WEAPONCLASS_LIGHT_MELEE,
  ::RPG_Item_WeaponClass_XMLTree_Type::WEAPONCLASS_ONE_HANDED_MELEE,
  ::RPG_Item_WeaponClass_XMLTree_Type::WEAPONCLASS_RANGED,
  ::RPG_Item_WeaponClass_XMLTree_Type::WEAPONCLASS_TWO_HANDED_MELEE,
  ::RPG_Item_WeaponClass_XMLTree_Type::WEAPONCLASS_UNARMED
};

// RPG_Item_WeaponType_XMLTree_Type
//

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_WeaponType_XMLTree_Type_convert ();
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_WeaponType_XMLTree_Type_convert ();
}

RPG_Item_WeaponType_XMLTree_Type::
RPG_Item_WeaponType_XMLTree_Type (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_WeaponType_XMLTree_Type_convert ();
}

RPG_Item_WeaponType_XMLTree_Type* RPG_Item_WeaponType_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_WeaponType_XMLTree_Type (*this, f, c);
}

RPG_Item_WeaponType_XMLTree_Type::value RPG_Item_WeaponType_XMLTree_Type::
_xsd_RPG_Item_WeaponType_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_WeaponType_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_WeaponType_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_WeaponType_XMLTree_Type_indexes_ + 73,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_WeaponType_XMLTree_Type_indexes_ + 73 || _xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_WeaponType_XMLTree_Type::
_xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[73] =
{
  "UNARMED_WEAPON_GAUNTLET",
  "UNARMED_WEAPON_STRIKE",
  "LIGHT_MELEE_WEAPON_DAGGER",
  "LIGHT_MELEE_WEAPON_DAGGER_PUNCHING",
  "LIGHT_MELEE_WEAPON_GAUNTLET_SPIKED",
  "LIGHT_MELEE_WEAPON_MACE_LIGHT",
  "LIGHT_MELEE_WEAPON_SICKLE",
  "ONE_HANDED_MELEE_WEAPON_CLUB",
  "ONE_HANDED_MELEE_WEAPON_MACE_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_MORNINGSTAR",
  "ONE_HANDED_MELEE_WEAPON_SHORTSPEAR",
  "TWO_HANDED_MELEE_WEAPON_LONGSPEAR",
  "TWO_HANDED_MELEE_WEAPON_QUARTERSTAFF",
  "TWO_HANDED_MELEE_WEAPON_SPEAR",
  "RANGED_WEAPON_CROSSBOW_LIGHT",
  "RANGED_WEAPON_CROSSBOW_HEAVY",
  "RANGED_WEAPON_DART",
  "RANGED_WEAPON_JAVELIN",
  "RANGED_WEAPON_SLING",
  "LIGHT_MELEE_WEAPON_AXE_THROWING",
  "LIGHT_MELEE_WEAPON_HAMMER_LIGHT",
  "LIGHT_MELEE_WEAPON_AXE_HAND",
  "LIGHT_MELEE_WEAPON_KUKRI",
  "LIGHT_MELEE_WEAPON_PICK_LIGHT",
  "LIGHT_MELEE_WEAPON_SAP",
  "LIGHT_MELEE_WEAPON_SHIELD_LIGHT",
  "LIGHT_MELEE_WEAPON_ARMOR_SPIKED",
  "LIGHT_MELEE_WEAPON_SHIELD_LIGHT_SPIKED",
  "LIGHT_MELEE_WEAPON_SWORD_SHORT",
  "ONE_HANDED_MELEE_WEAPON_AXE_BATTLE",
  "ONE_HANDED_MELEE_WEAPON_FLAIL_LIGHT",
  "ONE_HANDED_MELEE_WEAPON_SWORD_LONG",
  "ONE_HANDED_MELEE_WEAPON_PICK_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_RAPIER",
  "ONE_HANDED_MELEE_WEAPON_SCIMITAR",
  "ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY",
  "ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY_SPIKED",
  "ONE_HANDED_MELEE_WEAPON_TRIDENT",
  "ONE_HANDED_MELEE_WEAPON_HAMMER_WAR",
  "TWO_HANDED_MELEE_WEAPON_FALCHION",
  "TWO_HANDED_MELEE_WEAPON_GLAIVE",
  "TWO_HANDED_MELEE_WEAPON_AXE_GREAT",
  "TWO_HANDED_MELEE_WEAPON_CLUB_GREAT",
  "TWO_HANDED_MELEE_WEAPON_FLAIL_HEAVY",
  "TWO_HANDED_MELEE_WEAPON_SWORD_GREAT",
  "TWO_HANDED_MELEE_WEAPON_GUISARME",
  "TWO_HANDED_MELEE_WEAPON_HALBERD",
  "TWO_HANDED_MELEE_WEAPON_LANCE",
  "TWO_HANDED_MELEE_WEAPON_RANSEUR",
  "TWO_HANDED_MELEE_WEAPON_SCYTHE",
  "RANGED_WEAPON_BOW_SHORT",
  "RANGED_WEAPON_BOW_SHORT_COMPOSITE",
  "RANGED_WEAPON_BOW_LONG",
  "RANGED_WEAPON_BOW_LONG_COMPOSITE",
  "LIGHT_MELEE_WEAPON_KAMA",
  "LIGHT_MELEE_WEAPON_NUNCHAKU",
  "LIGHT_MELEE_WEAPON_SAI",
  "LIGHT_MELEE_WEAPON_SIANGHAM",
  "ONE_HANDED_MELEE_WEAPON_SWORD_BASTARD",
  "ONE_HANDED_MELEE_WEAPON_AXE_WAR_DWARVEN",
  "ONE_HANDED_MELEE_WEAPON_WHIP",
  "TWO_HANDED_MELEE_WEAPON_AXE_ORC_DOUBLE",
  "TWO_HANDED_MELEE_WEAPON_CHAIN_SPIKED",
  "TWO_HANDED_MELEE_WEAPON_FLAIL_DIRE",
  "TWO_HANDED_MELEE_WEAPON_HAMMER_GNOME_HOOKED",
  "TWO_HANDED_MELEE_WEAPON_SWORD_TWO_BLADED",
  "TWO_HANDED_MELEE_WEAPON_URGROSH_DWARVEN",
  "RANGED_WEAPON_BOLAS",
  "RANGED_WEAPON_CROSSBOW_HAND",
  "RANGED_WEAPON_CROSSBOW_REPEATING_LIGHT",
  "RANGED_WEAPON_CROSSBOW_REPEATING_HEAVY",
  "RANGED_WEAPON_NET",
  "RANGED_WEAPON_SHURIKEN"
};

const RPG_Item_WeaponType_XMLTree_Type::value RPG_Item_WeaponType_XMLTree_Type::
_xsd_RPG_Item_WeaponType_XMLTree_Type_indexes_[73] =
{
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_ARMOR_SPIKED,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_AXE_HAND,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_AXE_THROWING,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_DAGGER,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_DAGGER_PUNCHING,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_GAUNTLET_SPIKED,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_HAMMER_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_KAMA,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_KUKRI,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_MACE_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_NUNCHAKU,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_PICK_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SAI,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SAP,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SHIELD_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SHIELD_LIGHT_SPIKED,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SIANGHAM,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SICKLE,
  ::RPG_Item_WeaponType_XMLTree_Type::LIGHT_MELEE_WEAPON_SWORD_SHORT,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_AXE_BATTLE,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_AXE_WAR_DWARVEN,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_CLUB,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_FLAIL_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_HAMMER_WAR,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_MACE_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_MORNINGSTAR,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_PICK_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_RAPIER,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SCIMITAR,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY_SPIKED,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SHORTSPEAR,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SWORD_BASTARD,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_SWORD_LONG,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_TRIDENT,
  ::RPG_Item_WeaponType_XMLTree_Type::ONE_HANDED_MELEE_WEAPON_WHIP,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_BOLAS,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_BOW_LONG,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_BOW_LONG_COMPOSITE,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_BOW_SHORT,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_BOW_SHORT_COMPOSITE,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_CROSSBOW_HAND,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_CROSSBOW_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_CROSSBOW_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_CROSSBOW_REPEATING_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_CROSSBOW_REPEATING_LIGHT,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_DART,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_JAVELIN,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_NET,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_SHURIKEN,
  ::RPG_Item_WeaponType_XMLTree_Type::RANGED_WEAPON_SLING,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_AXE_GREAT,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_AXE_ORC_DOUBLE,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_CHAIN_SPIKED,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_CLUB_GREAT,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FALCHION,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FLAIL_DIRE,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_FLAIL_HEAVY,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_GLAIVE,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_GUISARME,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_HALBERD,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_HAMMER_GNOME_HOOKED,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_LANCE,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_LONGSPEAR,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_QUARTERSTAFF,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_RANSEUR,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SCYTHE,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SPEAR,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SWORD_GREAT,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_SWORD_TWO_BLADED,
  ::RPG_Item_WeaponType_XMLTree_Type::TWO_HANDED_MELEE_WEAPON_URGROSH_DWARVEN,
  ::RPG_Item_WeaponType_XMLTree_Type::UNARMED_WEAPON_GAUNTLET,
  ::RPG_Item_WeaponType_XMLTree_Type::UNARMED_WEAPON_STRIKE
};

// RPG_Item_StorePrice_XMLTree_Type
//

RPG_Item_StorePrice_XMLTree_Type::
RPG_Item_StorePrice_XMLTree_Type ()
: ::xml_schema::type (),
  numGoldPieces_ (::xml_schema::flags (), this),
  numSilverPieces_ (::xml_schema::flags (), this)
{
}

RPG_Item_StorePrice_XMLTree_Type::
RPG_Item_StorePrice_XMLTree_Type (const RPG_Item_StorePrice_XMLTree_Type& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numGoldPieces_ (x.numGoldPieces_, f, this),
  numSilverPieces_ (x.numSilverPieces_, f, this)
{
}

RPG_Item_StorePrice_XMLTree_Type::
RPG_Item_StorePrice_XMLTree_Type (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numGoldPieces_ (f, this),
  numSilverPieces_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_StorePrice_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // numGoldPieces
    //
    if (n.name () == "numGoldPieces" && n.namespace_ () == "urn:rpg")
    {
      if (!this->numGoldPieces_)
      {
        this->numGoldPieces_.set (numGoldPieces_traits::create (i, f, this));
        continue;
      }
    }

    // numSilverPieces
    //
    if (n.name () == "numSilverPieces" && n.namespace_ () == "urn:rpg")
    {
      if (!this->numSilverPieces_)
      {
        this->numSilverPieces_.set (numSilverPieces_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

RPG_Item_StorePrice_XMLTree_Type* RPG_Item_StorePrice_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_StorePrice_XMLTree_Type (*this, f, c);
}

RPG_Item_StorePrice_XMLTree_Type::
~RPG_Item_StorePrice_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_StorePrice_XMLTree_Type& x, const RPG_Item_StorePrice_XMLTree_Type& y)
{
  if (!(x.numGoldPieces () == y.numGoldPieces ()))
    return false;

  if (!(x.numSilverPieces () == y.numSilverPieces ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_StorePrice_XMLTree_Type& x, const RPG_Item_StorePrice_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_CriticalHitProperties_XMLTree_Type
//

RPG_Item_CriticalHitProperties_XMLTree_Type::
RPG_Item_CriticalHitProperties_XMLTree_Type (const minToHitRoll_type& minToHitRoll,
                                             const damageModifier_type& damageModifier)
: ::xml_schema::type (),
  minToHitRoll_ (minToHitRoll, ::xml_schema::flags (), this),
  damageModifier_ (damageModifier, ::xml_schema::flags (), this)
{
}

RPG_Item_CriticalHitProperties_XMLTree_Type::
RPG_Item_CriticalHitProperties_XMLTree_Type (const RPG_Item_CriticalHitProperties_XMLTree_Type& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minToHitRoll_ (x.minToHitRoll_, f, this),
  damageModifier_ (x.damageModifier_, f, this)
{
}

RPG_Item_CriticalHitProperties_XMLTree_Type::
RPG_Item_CriticalHitProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minToHitRoll_ (f, this),
  damageModifier_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_CriticalHitProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // minToHitRoll
    //
    if (n.name () == "minToHitRoll" && n.namespace_ () == "urn:rpg")
    {
      if (!minToHitRoll_.present ())
      {
        this->minToHitRoll_.set (minToHitRoll_traits::create (i, f, this));
        continue;
      }
    }

    // damageModifier
    //
    if (n.name () == "damageModifier" && n.namespace_ () == "urn:rpg")
    {
      if (!damageModifier_.present ())
      {
        this->damageModifier_.set (damageModifier_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!minToHitRoll_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minToHitRoll",
      "urn:rpg");
  }

  if (!damageModifier_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "damageModifier",
      "urn:rpg");
  }
}

RPG_Item_CriticalHitProperties_XMLTree_Type* RPG_Item_CriticalHitProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CriticalHitProperties_XMLTree_Type (*this, f, c);
}

RPG_Item_CriticalHitProperties_XMLTree_Type::
~RPG_Item_CriticalHitProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_CriticalHitProperties_XMLTree_Type& x, const RPG_Item_CriticalHitProperties_XMLTree_Type& y)
{
  if (!(x.minToHitRoll () == y.minToHitRoll ()))
    return false;

  if (!(x.damageModifier () == y.damageModifier ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_CriticalHitProperties_XMLTree_Type& x, const RPG_Item_CriticalHitProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_CreationCost_XMLTree_Type
//

RPG_Item_CreationCost_XMLTree_Type::
RPG_Item_CreationCost_XMLTree_Type ()
: ::xml_schema::type (),
  numGoldPieces_ (::xml_schema::flags (), this),
  numExperiencePoints_ (::xml_schema::flags (), this)
{
}

RPG_Item_CreationCost_XMLTree_Type::
RPG_Item_CreationCost_XMLTree_Type (const RPG_Item_CreationCost_XMLTree_Type& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  numGoldPieces_ (x.numGoldPieces_, f, this),
  numExperiencePoints_ (x.numExperiencePoints_, f, this)
{
}

RPG_Item_CreationCost_XMLTree_Type::
RPG_Item_CreationCost_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  numGoldPieces_ (f, this),
  numExperiencePoints_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_CreationCost_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // numGoldPieces
    //
    if (n.name () == "numGoldPieces" && n.namespace_ () == "urn:rpg")
    {
      if (!this->numGoldPieces_)
      {
        this->numGoldPieces_.set (numGoldPieces_traits::create (i, f, this));
        continue;
      }
    }

    // numExperiencePoints
    //
    if (n.name () == "numExperiencePoints" && n.namespace_ () == "urn:rpg")
    {
      if (!this->numExperiencePoints_)
      {
        this->numExperiencePoints_.set (numExperiencePoints_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

RPG_Item_CreationCost_XMLTree_Type* RPG_Item_CreationCost_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CreationCost_XMLTree_Type (*this, f, c);
}

RPG_Item_CreationCost_XMLTree_Type::
~RPG_Item_CreationCost_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_CreationCost_XMLTree_Type& x, const RPG_Item_CreationCost_XMLTree_Type& y)
{
  if (!(x.numGoldPieces () == y.numGoldPieces ()))
    return false;

  if (!(x.numExperiencePoints () == y.numExperiencePoints ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_CreationCost_XMLTree_Type& x, const RPG_Item_CreationCost_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_BaseProperties_XMLTree_Type
//

RPG_Item_BaseProperties_XMLTree_Type::
RPG_Item_BaseProperties_XMLTree_Type (const baseWeight_type& baseWeight,
                                      const baseStorePrice_type& baseStorePrice)
: ::xml_schema::type (),
  baseWeight_ (baseWeight, ::xml_schema::flags (), this),
  baseStorePrice_ (baseStorePrice, ::xml_schema::flags (), this),
  costToCreate_ (::xml_schema::flags (), this)
{
}

RPG_Item_BaseProperties_XMLTree_Type::
RPG_Item_BaseProperties_XMLTree_Type (const baseWeight_type& baseWeight,
                                      ::std::auto_ptr< baseStorePrice_type >& baseStorePrice)
: ::xml_schema::type (),
  baseWeight_ (baseWeight, ::xml_schema::flags (), this),
  baseStorePrice_ (baseStorePrice, ::xml_schema::flags (), this),
  costToCreate_ (::xml_schema::flags (), this)
{
}

RPG_Item_BaseProperties_XMLTree_Type::
RPG_Item_BaseProperties_XMLTree_Type (const RPG_Item_BaseProperties_XMLTree_Type& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  baseWeight_ (x.baseWeight_, f, this),
  baseStorePrice_ (x.baseStorePrice_, f, this),
  costToCreate_ (x.costToCreate_, f, this)
{
}

RPG_Item_BaseProperties_XMLTree_Type::
RPG_Item_BaseProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  baseWeight_ (f, this),
  baseStorePrice_ (f, this),
  costToCreate_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_BaseProperties_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // baseWeight
    //
    if (n.name () == "baseWeight" && n.namespace_ () == "urn:rpg")
    {
      if (!baseWeight_.present ())
      {
        this->baseWeight_.set (baseWeight_traits::create (i, f, this));
        continue;
      }
    }

    // baseStorePrice
    //
    if (n.name () == "baseStorePrice" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< baseStorePrice_type > r (
        baseStorePrice_traits::create (i, f, this));

      if (!baseStorePrice_.present ())
      {
        this->baseStorePrice_.set (r);
        continue;
      }
    }

    // costToCreate
    //
    if (n.name () == "costToCreate" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< costToCreate_type > r (
        costToCreate_traits::create (i, f, this));

      if (!this->costToCreate_)
      {
        this->costToCreate_.set (r);
        continue;
      }
    }

    break;
  }

  if (!baseWeight_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseWeight",
      "urn:rpg");
  }

  if (!baseStorePrice_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseStorePrice",
      "urn:rpg");
  }
}

RPG_Item_BaseProperties_XMLTree_Type* RPG_Item_BaseProperties_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_BaseProperties_XMLTree_Type (*this, f, c);
}

RPG_Item_BaseProperties_XMLTree_Type::
~RPG_Item_BaseProperties_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_BaseProperties_XMLTree_Type& x, const RPG_Item_BaseProperties_XMLTree_Type& y)
{
  if (!(x.baseWeight () == y.baseWeight ()))
    return false;

  if (!(x.baseStorePrice () == y.baseStorePrice ()))
    return false;

  if (!(x.costToCreate () == y.costToCreate ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_BaseProperties_XMLTree_Type& x, const RPG_Item_BaseProperties_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_MagicalPrerequisites_XMLTree_Type
//

RPG_Item_MagicalPrerequisites_XMLTree_Type::
RPG_Item_MagicalPrerequisites_XMLTree_Type ()
: ::xml_schema::type (),
  minCasterLevel_ (::xml_schema::flags (), this)
{
}

RPG_Item_MagicalPrerequisites_XMLTree_Type::
RPG_Item_MagicalPrerequisites_XMLTree_Type (const RPG_Item_MagicalPrerequisites_XMLTree_Type& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  minCasterLevel_ (x.minCasterLevel_, f, this)
{
}

RPG_Item_MagicalPrerequisites_XMLTree_Type::
RPG_Item_MagicalPrerequisites_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  minCasterLevel_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_MagicalPrerequisites_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // minCasterLevel
    //
    if (n.name () == "minCasterLevel" && n.namespace_ () == "urn:rpg")
    {
      if (!this->minCasterLevel_)
      {
        this->minCasterLevel_.set (minCasterLevel_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

RPG_Item_MagicalPrerequisites_XMLTree_Type* RPG_Item_MagicalPrerequisites_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_MagicalPrerequisites_XMLTree_Type (*this, f, c);
}

RPG_Item_MagicalPrerequisites_XMLTree_Type::
~RPG_Item_MagicalPrerequisites_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_MagicalPrerequisites_XMLTree_Type& x, const RPG_Item_MagicalPrerequisites_XMLTree_Type& y)
{
  if (!(x.minCasterLevel () == y.minCasterLevel ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_MagicalPrerequisites_XMLTree_Type& x, const RPG_Item_MagicalPrerequisites_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_PropertiesBase_XMLTree_Type
//

RPG_Item_PropertiesBase_XMLTree_Type::
RPG_Item_PropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                      const baseStorePrice_type& baseStorePrice)
: ::RPG_Item_BaseProperties_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  aura_ (::xml_schema::flags (), this),
  prerequisites_ (::xml_schema::flags (), this)
{
}

RPG_Item_PropertiesBase_XMLTree_Type::
RPG_Item_PropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                      ::std::auto_ptr< baseStorePrice_type >& baseStorePrice)
: ::RPG_Item_BaseProperties_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  aura_ (::xml_schema::flags (), this),
  prerequisites_ (::xml_schema::flags (), this)
{
}

RPG_Item_PropertiesBase_XMLTree_Type::
RPG_Item_PropertiesBase_XMLTree_Type (const RPG_Item_PropertiesBase_XMLTree_Type& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::RPG_Item_BaseProperties_XMLTree_Type (x, f, c),
  aura_ (x.aura_, f, this),
  prerequisites_ (x.prerequisites_, f, this)
{
}

RPG_Item_PropertiesBase_XMLTree_Type::
RPG_Item_PropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
: ::RPG_Item_BaseProperties_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  aura_ (f, this),
  prerequisites_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_PropertiesBase_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_BaseProperties_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // aura
    //
    if (n.name () == "aura" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< aura_type > r (
        aura_traits::create (i, f, this));

      if (!this->aura_)
      {
        this->aura_.set (r);
        continue;
      }
    }

    // prerequisites
    //
    if (n.name () == "prerequisites" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< prerequisites_type > r (
        prerequisites_traits::create (i, f, this));

      if (!this->prerequisites_)
      {
        this->prerequisites_.set (r);
        continue;
      }
    }

    break;
  }
}

RPG_Item_PropertiesBase_XMLTree_Type* RPG_Item_PropertiesBase_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_PropertiesBase_XMLTree_Type (*this, f, c);
}

RPG_Item_PropertiesBase_XMLTree_Type::
~RPG_Item_PropertiesBase_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_PropertiesBase_XMLTree_Type& x, const RPG_Item_PropertiesBase_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_BaseProperties_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_BaseProperties_XMLTree_Type& > (y)))
    return false;

  if (!(x.aura () == y.aura ()))
    return false;

  if (!(x.prerequisites () == y.prerequisites ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_PropertiesBase_XMLTree_Type& x, const RPG_Item_PropertiesBase_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_CommodityPropertiesBase_XMLTree_Type
//

RPG_Item_CommodityPropertiesBase_XMLTree_Type::
RPG_Item_CommodityPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                               const baseStorePrice_type& baseStorePrice,
                                               const type_type& type,
                                               const subType_type& subType)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  subType_ (subType, ::xml_schema::flags (), this)
{
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::
RPG_Item_CommodityPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                               ::std::auto_ptr< baseStorePrice_type >& baseStorePrice,
                                               const type_type& type,
                                               const subType_type& subType)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  subType_ (subType, ::xml_schema::flags (), this)
{
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::
RPG_Item_CommodityPropertiesBase_XMLTree_Type (const RPG_Item_CommodityPropertiesBase_XMLTree_Type& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (x, f, c),
  type_ (x.type_, f, this),
  subType_ (x.subType_, f, this)
{
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::
RPG_Item_CommodityPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  subType_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_CommodityPropertiesBase_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_PropertiesBase_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // subType
    //
    if (n.name () == "subType" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< subType_type > r (
        subType_traits::create (i, f, this));

      if (!subType_.present ())
      {
        this->subType_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!subType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "subType",
      "urn:rpg");
  }
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type* RPG_Item_CommodityPropertiesBase_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_CommodityPropertiesBase_XMLTree_Type (*this, f, c);
}

RPG_Item_CommodityPropertiesBase_XMLTree_Type::
~RPG_Item_CommodityPropertiesBase_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_CommodityPropertiesBase_XMLTree_Type& x, const RPG_Item_CommodityPropertiesBase_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.subType () == y.subType ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_CommodityPropertiesBase_XMLTree_Type& x, const RPG_Item_CommodityPropertiesBase_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_WeaponPropertiesBase_XMLTree_Type
//

RPG_Item_WeaponPropertiesBase_XMLTree_Type::
RPG_Item_WeaponPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                            const baseStorePrice_type& baseStorePrice,
                                            const type_type& type,
                                            const category_type& category,
                                            const weaponClass_type& weaponClass,
                                            const baseDamage_type& baseDamage,
                                            const criticalHit_type& criticalHit)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  category_ (category, ::xml_schema::flags (), this),
  weaponClass_ (weaponClass, ::xml_schema::flags (), this),
  baseDamage_ (baseDamage, ::xml_schema::flags (), this),
  criticalHit_ (criticalHit, ::xml_schema::flags (), this),
  rangeIncrement_ (::xml_schema::flags (), this),
  typeOfDamage_ (::xml_schema::flags (), this),
  isNonLethal_ (isNonLethal_default_value (), ::xml_schema::flags (), this),
  isReachWeapon_ (isReachWeapon_default_value (), ::xml_schema::flags (), this),
  isDoubleWeapon_ (isDoubleWeapon_default_value (), ::xml_schema::flags (), this)
{
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::
RPG_Item_WeaponPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                            ::std::auto_ptr< baseStorePrice_type >& baseStorePrice,
                                            const type_type& type,
                                            const category_type& category,
                                            const weaponClass_type& weaponClass,
                                            ::std::auto_ptr< baseDamage_type >& baseDamage,
                                            ::std::auto_ptr< criticalHit_type >& criticalHit)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  category_ (category, ::xml_schema::flags (), this),
  weaponClass_ (weaponClass, ::xml_schema::flags (), this),
  baseDamage_ (baseDamage, ::xml_schema::flags (), this),
  criticalHit_ (criticalHit, ::xml_schema::flags (), this),
  rangeIncrement_ (::xml_schema::flags (), this),
  typeOfDamage_ (::xml_schema::flags (), this),
  isNonLethal_ (isNonLethal_default_value (), ::xml_schema::flags (), this),
  isReachWeapon_ (isReachWeapon_default_value (), ::xml_schema::flags (), this),
  isDoubleWeapon_ (isDoubleWeapon_default_value (), ::xml_schema::flags (), this)
{
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::
RPG_Item_WeaponPropertiesBase_XMLTree_Type (const RPG_Item_WeaponPropertiesBase_XMLTree_Type& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (x, f, c),
  type_ (x.type_, f, this),
  category_ (x.category_, f, this),
  weaponClass_ (x.weaponClass_, f, this),
  baseDamage_ (x.baseDamage_, f, this),
  criticalHit_ (x.criticalHit_, f, this),
  rangeIncrement_ (x.rangeIncrement_, f, this),
  typeOfDamage_ (x.typeOfDamage_, f, this),
  isNonLethal_ (x.isNonLethal_, f, this),
  isReachWeapon_ (x.isReachWeapon_, f, this),
  isDoubleWeapon_ (x.isDoubleWeapon_, f, this)
{
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::
RPG_Item_WeaponPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  category_ (f, this),
  weaponClass_ (f, this),
  baseDamage_ (f, this),
  criticalHit_ (f, this),
  rangeIncrement_ (f, this),
  typeOfDamage_ (f, this),
  isNonLethal_ (f, this),
  isReachWeapon_ (f, this),
  isDoubleWeapon_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void RPG_Item_WeaponPropertiesBase_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_PropertiesBase_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // category
    //
    if (n.name () == "category" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< category_type > r (
        category_traits::create (i, f, this));

      if (!category_.present ())
      {
        this->category_.set (r);
        continue;
      }
    }

    // weaponClass
    //
    if (n.name () == "weaponClass" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< weaponClass_type > r (
        weaponClass_traits::create (i, f, this));

      if (!weaponClass_.present ())
      {
        this->weaponClass_.set (r);
        continue;
      }
    }

    // baseDamage
    //
    if (n.name () == "baseDamage" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< baseDamage_type > r (
        baseDamage_traits::create (i, f, this));

      if (!baseDamage_.present ())
      {
        this->baseDamage_.set (r);
        continue;
      }
    }

    // criticalHit
    //
    if (n.name () == "criticalHit" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< criticalHit_type > r (
        criticalHit_traits::create (i, f, this));

      if (!criticalHit_.present ())
      {
        this->criticalHit_.set (r);
        continue;
      }
    }

    // rangeIncrement
    //
    if (n.name () == "rangeIncrement" && n.namespace_ () == "urn:rpg")
    {
      if (!this->rangeIncrement_)
      {
        this->rangeIncrement_.set (rangeIncrement_traits::create (i, f, this));
        continue;
      }
    }

    // typeOfDamage
    //
    if (n.name () == "typeOfDamage" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< typeOfDamage_type > r (
        typeOfDamage_traits::create (i, f, this));

      this->typeOfDamage_.push_back (r);
      continue;
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!category_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "category",
      "urn:rpg");
  }

  if (!weaponClass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "weaponClass",
      "urn:rpg");
  }

  if (!baseDamage_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseDamage",
      "urn:rpg");
  }

  if (!criticalHit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "criticalHit",
      "urn:rpg");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "isNonLethal" && n.namespace_ ().empty ())
    {
      this->isNonLethal_.set (isNonLethal_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "isReachWeapon" && n.namespace_ ().empty ())
    {
      this->isReachWeapon_.set (isReachWeapon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "isDoubleWeapon" && n.namespace_ ().empty ())
    {
      this->isDoubleWeapon_.set (isDoubleWeapon_traits::create (i, f, this));
      continue;
    }
  }

  if (!isNonLethal_.present ())
  {
    this->isNonLethal_.set (isNonLethal_default_value ());
  }

  if (!isReachWeapon_.present ())
  {
    this->isReachWeapon_.set (isReachWeapon_default_value ());
  }

  if (!isDoubleWeapon_.present ())
  {
    this->isDoubleWeapon_.set (isDoubleWeapon_default_value ());
  }
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type* RPG_Item_WeaponPropertiesBase_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_WeaponPropertiesBase_XMLTree_Type (*this, f, c);
}

RPG_Item_WeaponPropertiesBase_XMLTree_Type::
~RPG_Item_WeaponPropertiesBase_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_WeaponPropertiesBase_XMLTree_Type& x, const RPG_Item_WeaponPropertiesBase_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.category () == y.category ()))
    return false;

  if (!(x.weaponClass () == y.weaponClass ()))
    return false;

  if (!(x.baseDamage () == y.baseDamage ()))
    return false;

  if (!(x.criticalHit () == y.criticalHit ()))
    return false;

  if (!(x.rangeIncrement () == y.rangeIncrement ()))
    return false;

  if (!(x.typeOfDamage () == y.typeOfDamage ()))
    return false;

  if (!(x.isNonLethal () == y.isNonLethal ()))
    return false;

  if (!(x.isReachWeapon () == y.isReachWeapon ()))
    return false;

  if (!(x.isDoubleWeapon () == y.isDoubleWeapon ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_WeaponPropertiesBase_XMLTree_Type& x, const RPG_Item_WeaponPropertiesBase_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_WeaponPropertiesXML_XMLTree_Type
//

RPG_Item_WeaponPropertiesXML_XMLTree_Type::
RPG_Item_WeaponPropertiesXML_XMLTree_Type (const baseWeight_type& baseWeight,
                                           const baseStorePrice_type& baseStorePrice,
                                           const type_type& type,
                                           const category_type& category,
                                           const weaponClass_type& weaponClass,
                                           const baseDamage_type& baseDamage,
                                           const criticalHit_type& criticalHit)
: ::RPG_Item_WeaponPropertiesBase_XMLTree_Type (baseWeight,
                                                baseStorePrice,
                                                type,
                                                category,
                                                weaponClass,
                                                baseDamage,
                                                criticalHit),
  toHitModifier_ (::xml_schema::flags (), this)
{
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type::
RPG_Item_WeaponPropertiesXML_XMLTree_Type (const baseWeight_type& baseWeight,
                                           ::std::auto_ptr< baseStorePrice_type >& baseStorePrice,
                                           const type_type& type,
                                           const category_type& category,
                                           const weaponClass_type& weaponClass,
                                           ::std::auto_ptr< baseDamage_type >& baseDamage,
                                           ::std::auto_ptr< criticalHit_type >& criticalHit)
: ::RPG_Item_WeaponPropertiesBase_XMLTree_Type (baseWeight,
                                                baseStorePrice,
                                                type,
                                                category,
                                                weaponClass,
                                                baseDamage,
                                                criticalHit),
  toHitModifier_ (::xml_schema::flags (), this)
{
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type::
RPG_Item_WeaponPropertiesXML_XMLTree_Type (const RPG_Item_WeaponPropertiesXML_XMLTree_Type& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::RPG_Item_WeaponPropertiesBase_XMLTree_Type (x, f, c),
  toHitModifier_ (x.toHitModifier_, f, this)
{
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type::
RPG_Item_WeaponPropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::RPG_Item_WeaponPropertiesBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  toHitModifier_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void RPG_Item_WeaponPropertiesXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_WeaponPropertiesBase_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // toHitModifier
    //
    if (n.name () == "toHitModifier" && n.namespace_ () == "urn:rpg")
    {
      if (!this->toHitModifier_)
      {
        this->toHitModifier_.set (toHitModifier_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type* RPG_Item_WeaponPropertiesXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_WeaponPropertiesXML_XMLTree_Type (*this, f, c);
}

RPG_Item_WeaponPropertiesXML_XMLTree_Type::
~RPG_Item_WeaponPropertiesXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_WeaponPropertiesXML_XMLTree_Type& x, const RPG_Item_WeaponPropertiesXML_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_WeaponPropertiesBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_WeaponPropertiesBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.toHitModifier () == y.toHitModifier ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_WeaponPropertiesXML_XMLTree_Type& x, const RPG_Item_WeaponPropertiesXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_ArmorCategory_XMLTree_Type
//

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert ();
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert ();
}

RPG_Item_ArmorCategory_XMLTree_Type::
RPG_Item_ArmorCategory_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert ();
}

RPG_Item_ArmorCategory_XMLTree_Type* RPG_Item_ArmorCategory_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_ArmorCategory_XMLTree_Type (*this, f, c);
}

RPG_Item_ArmorCategory_XMLTree_Type::value RPG_Item_ArmorCategory_XMLTree_Type::
_xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_ArmorCategory_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_ArmorCategory_XMLTree_Type_indexes_ + 6,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_ArmorCategory_XMLTree_Type_indexes_ + 6 || _xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_ArmorCategory_XMLTree_Type::
_xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[6] =
{
  "ARMORCATEGORY_GLOVES",
  "ARMORCATEGORY_LIGHT",
  "ARMORCATEGORY_MEDIUM",
  "ARMORCATEGORY_HEAVY",
  "ARMORCATEGORY_HELMET",
  "ARMORCATEGORY_SHIELD"
};

const RPG_Item_ArmorCategory_XMLTree_Type::value RPG_Item_ArmorCategory_XMLTree_Type::
_xsd_RPG_Item_ArmorCategory_XMLTree_Type_indexes_[6] =
{
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_GLOVES,
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_HEAVY,
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_HELMET,
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_LIGHT,
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_MEDIUM,
  ::RPG_Item_ArmorCategory_XMLTree_Type::ARMORCATEGORY_SHIELD
};

// RPG_Item_ArmorType_XMLTree_Type
//

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_RPG_Item_ArmorType_XMLTree_Type_convert ();
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_RPG_Item_ArmorType_XMLTree_Type_convert ();
}

RPG_Item_ArmorType_XMLTree_Type::
RPG_Item_ArmorType_XMLTree_Type (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_RPG_Item_ArmorType_XMLTree_Type_convert ();
}

RPG_Item_ArmorType_XMLTree_Type* RPG_Item_ArmorType_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_ArmorType_XMLTree_Type (*this, f, c);
}

RPG_Item_ArmorType_XMLTree_Type::value RPG_Item_ArmorType_XMLTree_Type::
_xsd_RPG_Item_ArmorType_XMLTree_Type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RPG_Item_ArmorType_XMLTree_Type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_RPG_Item_ArmorType_XMLTree_Type_indexes_,
                    _xsd_RPG_Item_ArmorType_XMLTree_Type_indexes_ + 19,
                    *this,
                    c));

  if (i == _xsd_RPG_Item_ArmorType_XMLTree_Type_indexes_ + 19 || _xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const RPG_Item_ArmorType_XMLTree_Type::
_xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[19] =
{
  "ARMOR_NONE",
  "ARMOR_PADDED",
  "ARMOR_LEATHER",
  "ARMOR_LEATHER_STUDDED",
  "ARMOR_CHAIN_SHIRT",
  "ARMOR_HIDE",
  "ARMOR_MAIL_SCALE",
  "ARMOR_MAIL_CHAIN",
  "ARMOR_PLATE_BREAST",
  "ARMOR_MAIL_SPLINT",
  "ARMOR_MAIL_BANDED",
  "ARMOR_PLATE_HALF",
  "ARMOR_PLATE_FULL",
  "ARMOR_BUCKLER",
  "ARMOR_SHIELD_LIGHT_WOODEN",
  "ARMOR_SHIELD_LIGHT_STEEL",
  "ARMOR_SHIELD_HEAVY_WOODEN",
  "ARMOR_SHIELD_HEAVY_STEEL",
  "ARMOR_SHIELD_TOWER"
};

const RPG_Item_ArmorType_XMLTree_Type::value RPG_Item_ArmorType_XMLTree_Type::
_xsd_RPG_Item_ArmorType_XMLTree_Type_indexes_[19] =
{
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_BUCKLER,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_CHAIN_SHIRT,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_HIDE,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_LEATHER,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_LEATHER_STUDDED,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_MAIL_BANDED,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_MAIL_CHAIN,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_MAIL_SCALE,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_MAIL_SPLINT,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_NONE,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_PADDED,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_PLATE_BREAST,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_PLATE_FULL,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_PLATE_HALF,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_SHIELD_HEAVY_STEEL,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_SHIELD_HEAVY_WOODEN,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_SHIELD_LIGHT_STEEL,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_SHIELD_LIGHT_WOODEN,
  ::RPG_Item_ArmorType_XMLTree_Type::ARMOR_SHIELD_TOWER
};

// RPG_Item_ArmorPropertiesBase_XMLTree_Type
//

RPG_Item_ArmorPropertiesBase_XMLTree_Type::
RPG_Item_ArmorPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                           const baseStorePrice_type& baseStorePrice,
                                           const type_type& type,
                                           const category_type& category,
                                           const baseBonus_type& baseBonus,
                                           const maxDexterityBonus_type& maxDexterityBonus,
                                           const checkPenalty_type& checkPenalty,
                                           const arcaneSpellFailure_type& arcaneSpellFailure,
                                           const baseSpeed_type& baseSpeed)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  category_ (category, ::xml_schema::flags (), this),
  baseBonus_ (baseBonus, ::xml_schema::flags (), this),
  maxDexterityBonus_ (maxDexterityBonus, ::xml_schema::flags (), this),
  checkPenalty_ (checkPenalty, ::xml_schema::flags (), this),
  arcaneSpellFailure_ (arcaneSpellFailure, ::xml_schema::flags (), this),
  baseSpeed_ (baseSpeed, ::xml_schema::flags (), this)
{
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::
RPG_Item_ArmorPropertiesBase_XMLTree_Type (const baseWeight_type& baseWeight,
                                           ::std::auto_ptr< baseStorePrice_type >& baseStorePrice,
                                           const type_type& type,
                                           const category_type& category,
                                           const baseBonus_type& baseBonus,
                                           const maxDexterityBonus_type& maxDexterityBonus,
                                           const checkPenalty_type& checkPenalty,
                                           const arcaneSpellFailure_type& arcaneSpellFailure,
                                           const baseSpeed_type& baseSpeed)
: ::RPG_Item_PropertiesBase_XMLTree_Type (baseWeight,
                                          baseStorePrice),
  type_ (type, ::xml_schema::flags (), this),
  category_ (category, ::xml_schema::flags (), this),
  baseBonus_ (baseBonus, ::xml_schema::flags (), this),
  maxDexterityBonus_ (maxDexterityBonus, ::xml_schema::flags (), this),
  checkPenalty_ (checkPenalty, ::xml_schema::flags (), this),
  arcaneSpellFailure_ (arcaneSpellFailure, ::xml_schema::flags (), this),
  baseSpeed_ (baseSpeed, ::xml_schema::flags (), this)
{
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::
RPG_Item_ArmorPropertiesBase_XMLTree_Type (const RPG_Item_ArmorPropertiesBase_XMLTree_Type& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (x, f, c),
  type_ (x.type_, f, this),
  category_ (x.category_, f, this),
  baseBonus_ (x.baseBonus_, f, this),
  maxDexterityBonus_ (x.maxDexterityBonus_, f, this),
  checkPenalty_ (x.checkPenalty_, f, this),
  arcaneSpellFailure_ (x.arcaneSpellFailure_, f, this),
  baseSpeed_ (x.baseSpeed_, f, this)
{
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::
RPG_Item_ArmorPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
: ::RPG_Item_PropertiesBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  category_ (f, this),
  baseBonus_ (f, this),
  maxDexterityBonus_ (f, this),
  checkPenalty_ (f, this),
  arcaneSpellFailure_ (f, this),
  baseSpeed_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_ArmorPropertiesBase_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_PropertiesBase_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // category
    //
    if (n.name () == "category" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< category_type > r (
        category_traits::create (i, f, this));

      if (!category_.present ())
      {
        this->category_.set (r);
        continue;
      }
    }

    // baseBonus
    //
    if (n.name () == "baseBonus" && n.namespace_ () == "urn:rpg")
    {
      if (!baseBonus_.present ())
      {
        this->baseBonus_.set (baseBonus_traits::create (i, f, this));
        continue;
      }
    }

    // maxDexterityBonus
    //
    if (n.name () == "maxDexterityBonus" && n.namespace_ () == "urn:rpg")
    {
      if (!maxDexterityBonus_.present ())
      {
        this->maxDexterityBonus_.set (maxDexterityBonus_traits::create (i, f, this));
        continue;
      }
    }

    // checkPenalty
    //
    if (n.name () == "checkPenalty" && n.namespace_ () == "urn:rpg")
    {
      if (!checkPenalty_.present ())
      {
        this->checkPenalty_.set (checkPenalty_traits::create (i, f, this));
        continue;
      }
    }

    // arcaneSpellFailure
    //
    if (n.name () == "arcaneSpellFailure" && n.namespace_ () == "urn:rpg")
    {
      if (!arcaneSpellFailure_.present ())
      {
        this->arcaneSpellFailure_.set (arcaneSpellFailure_traits::create (i, f, this));
        continue;
      }
    }

    // baseSpeed
    //
    if (n.name () == "baseSpeed" && n.namespace_ () == "urn:rpg")
    {
      if (!baseSpeed_.present ())
      {
        this->baseSpeed_.set (baseSpeed_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }

  if (!category_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "category",
      "urn:rpg");
  }

  if (!baseBonus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseBonus",
      "urn:rpg");
  }

  if (!maxDexterityBonus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "maxDexterityBonus",
      "urn:rpg");
  }

  if (!checkPenalty_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "checkPenalty",
      "urn:rpg");
  }

  if (!arcaneSpellFailure_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "arcaneSpellFailure",
      "urn:rpg");
  }

  if (!baseSpeed_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseSpeed",
      "urn:rpg");
  }
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type* RPG_Item_ArmorPropertiesBase_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_ArmorPropertiesBase_XMLTree_Type (*this, f, c);
}

RPG_Item_ArmorPropertiesBase_XMLTree_Type::
~RPG_Item_ArmorPropertiesBase_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_ArmorPropertiesBase_XMLTree_Type& x, const RPG_Item_ArmorPropertiesBase_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.type () == y.type ()))
    return false;

  if (!(x.category () == y.category ()))
    return false;

  if (!(x.baseBonus () == y.baseBonus ()))
    return false;

  if (!(x.maxDexterityBonus () == y.maxDexterityBonus ()))
    return false;

  if (!(x.checkPenalty () == y.checkPenalty ()))
    return false;

  if (!(x.arcaneSpellFailure () == y.arcaneSpellFailure ()))
    return false;

  if (!(x.baseSpeed () == y.baseSpeed ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_ArmorPropertiesBase_XMLTree_Type& x, const RPG_Item_ArmorPropertiesBase_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_ArmorPropertiesXML_XMLTree_Type
//

RPG_Item_ArmorPropertiesXML_XMLTree_Type::
RPG_Item_ArmorPropertiesXML_XMLTree_Type (const baseWeight_type& baseWeight,
                                          const baseStorePrice_type& baseStorePrice,
                                          const type_type& type,
                                          const category_type& category,
                                          const baseBonus_type& baseBonus,
                                          const maxDexterityBonus_type& maxDexterityBonus,
                                          const checkPenalty_type& checkPenalty,
                                          const arcaneSpellFailure_type& arcaneSpellFailure,
                                          const baseSpeed_type& baseSpeed)
: ::RPG_Item_ArmorPropertiesBase_XMLTree_Type (baseWeight,
                                               baseStorePrice,
                                               type,
                                               category,
                                               baseBonus,
                                               maxDexterityBonus,
                                               checkPenalty,
                                               arcaneSpellFailure,
                                               baseSpeed),
  defenseModifier_ (::xml_schema::flags (), this)
{
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type::
RPG_Item_ArmorPropertiesXML_XMLTree_Type (const baseWeight_type& baseWeight,
                                          ::std::auto_ptr< baseStorePrice_type >& baseStorePrice,
                                          const type_type& type,
                                          const category_type& category,
                                          const baseBonus_type& baseBonus,
                                          const maxDexterityBonus_type& maxDexterityBonus,
                                          const checkPenalty_type& checkPenalty,
                                          const arcaneSpellFailure_type& arcaneSpellFailure,
                                          const baseSpeed_type& baseSpeed)
: ::RPG_Item_ArmorPropertiesBase_XMLTree_Type (baseWeight,
                                               baseStorePrice,
                                               type,
                                               category,
                                               baseBonus,
                                               maxDexterityBonus,
                                               checkPenalty,
                                               arcaneSpellFailure,
                                               baseSpeed),
  defenseModifier_ (::xml_schema::flags (), this)
{
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type::
RPG_Item_ArmorPropertiesXML_XMLTree_Type (const RPG_Item_ArmorPropertiesXML_XMLTree_Type& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::RPG_Item_ArmorPropertiesBase_XMLTree_Type (x, f, c),
  defenseModifier_ (x.defenseModifier_, f, this)
{
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type::
RPG_Item_ArmorPropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
: ::RPG_Item_ArmorPropertiesBase_XMLTree_Type (e, f | ::xml_schema::flags::base, c),
  defenseModifier_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_ArmorPropertiesXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RPG_Item_ArmorPropertiesBase_XMLTree_Type::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // defenseModifier
    //
    if (n.name () == "defenseModifier" && n.namespace_ () == "urn:rpg")
    {
      if (!this->defenseModifier_)
      {
        this->defenseModifier_.set (defenseModifier_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type* RPG_Item_ArmorPropertiesXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_ArmorPropertiesXML_XMLTree_Type (*this, f, c);
}

RPG_Item_ArmorPropertiesXML_XMLTree_Type::
~RPG_Item_ArmorPropertiesXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_ArmorPropertiesXML_XMLTree_Type& x, const RPG_Item_ArmorPropertiesXML_XMLTree_Type& y)
{
  if (!(static_cast< const ::RPG_Item_ArmorPropertiesBase_XMLTree_Type& > (x) ==
        static_cast< const ::RPG_Item_ArmorPropertiesBase_XMLTree_Type& > (y)))
    return false;

  if (!(x.defenseModifier () == y.defenseModifier ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_ArmorPropertiesXML_XMLTree_Type& x, const RPG_Item_ArmorPropertiesXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_XML_XMLTree_Type
//

RPG_Item_XML_XMLTree_Type::
RPG_Item_XML_XMLTree_Type (const type_type& type)
: ::xml_schema::type (),
  type_ (type, ::xml_schema::flags (), this),
  armor_ (::xml_schema::flags (), this),
  commodity_ (::xml_schema::flags (), this),
  weapon_ (::xml_schema::flags (), this)
{
}

RPG_Item_XML_XMLTree_Type::
RPG_Item_XML_XMLTree_Type (const RPG_Item_XML_XMLTree_Type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  armor_ (x.armor_, f, this),
  commodity_ (x.commodity_, f, this),
  weapon_ (x.weapon_, f, this)
{
}

RPG_Item_XML_XMLTree_Type::
RPG_Item_XML_XMLTree_Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (f, this),
  armor_ (f, this),
  commodity_ (f, this),
  weapon_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_XML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // armor
    //
    if (n.name () == "armor" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< armor_type > r (
        armor_traits::create (i, f, this));

      if (!this->armor_)
      {
        this->armor_.set (r);
        continue;
      }
    }

    // commodity
    //
    if (n.name () == "commodity" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< commodity_type > r (
        commodity_traits::create (i, f, this));

      if (!this->commodity_)
      {
        this->commodity_.set (r);
        continue;
      }
    }

    // weapon
    //
    if (n.name () == "weapon" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< weapon_type > r (
        weapon_traits::create (i, f, this));

      if (!this->weapon_)
      {
        this->weapon_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "urn:rpg");
  }
}

RPG_Item_XML_XMLTree_Type* RPG_Item_XML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_XML_XMLTree_Type (*this, f, c);
}

RPG_Item_XML_XMLTree_Type::
~RPG_Item_XML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_XML_XMLTree_Type& x, const RPG_Item_XML_XMLTree_Type& y)
{
  if (!(x.type () == y.type ()))
    return false;

  if (!(x.armor () == y.armor ()))
    return false;

  if (!(x.commodity () == y.commodity ()))
    return false;

  if (!(x.weapon () == y.weapon ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_XML_XMLTree_Type& x, const RPG_Item_XML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_InventoryXML_XMLTree_Type
//

RPG_Item_InventoryXML_XMLTree_Type::
RPG_Item_InventoryXML_XMLTree_Type ()
: ::xml_schema::type (),
  item_ (::xml_schema::flags (), this)
{
}

RPG_Item_InventoryXML_XMLTree_Type::
RPG_Item_InventoryXML_XMLTree_Type (const RPG_Item_InventoryXML_XMLTree_Type& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  item_ (x.item_, f, this)
{
}

RPG_Item_InventoryXML_XMLTree_Type::
RPG_Item_InventoryXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  item_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_InventoryXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // item
    //
    if (n.name () == "item" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< item_type > r (
        item_traits::create (i, f, this));

      this->item_.push_back (r);
      continue;
    }

    break;
  }
}

RPG_Item_InventoryXML_XMLTree_Type* RPG_Item_InventoryXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_InventoryXML_XMLTree_Type (*this, f, c);
}

RPG_Item_InventoryXML_XMLTree_Type::
~RPG_Item_InventoryXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_InventoryXML_XMLTree_Type& x, const RPG_Item_InventoryXML_XMLTree_Type& y)
{
  if (!(x.item () == y.item ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_InventoryXML_XMLTree_Type& x, const RPG_Item_InventoryXML_XMLTree_Type& y)
{
  return !(x == y);
}

// RPG_Item_DictionaryXML_XMLTree_Type
//

RPG_Item_DictionaryXML_XMLTree_Type::
RPG_Item_DictionaryXML_XMLTree_Type ()
: ::xml_schema::type (),
  armor_ (::xml_schema::flags (), this),
  commodity_ (::xml_schema::flags (), this),
  weapon_ (::xml_schema::flags (), this)
{
}

RPG_Item_DictionaryXML_XMLTree_Type::
RPG_Item_DictionaryXML_XMLTree_Type (const RPG_Item_DictionaryXML_XMLTree_Type& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  armor_ (x.armor_, f, this),
  commodity_ (x.commodity_, f, this),
  weapon_ (x.weapon_, f, this)
{
}

RPG_Item_DictionaryXML_XMLTree_Type::
RPG_Item_DictionaryXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  armor_ (f, this),
  commodity_ (f, this),
  weapon_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void RPG_Item_DictionaryXML_XMLTree_Type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // armor
    //
    if (n.name () == "armor" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< armor_type > r (
        armor_traits::create (i, f, this));

      this->armor_.push_back (r);
      continue;
    }

    // commodity
    //
    if (n.name () == "commodity" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< commodity_type > r (
        commodity_traits::create (i, f, this));

      this->commodity_.push_back (r);
      continue;
    }

    // weapon
    //
    if (n.name () == "weapon" && n.namespace_ () == "urn:rpg")
    {
      ::std::auto_ptr< weapon_type > r (
        weapon_traits::create (i, f, this));

      this->weapon_.push_back (r);
      continue;
    }

    break;
  }
}

RPG_Item_DictionaryXML_XMLTree_Type* RPG_Item_DictionaryXML_XMLTree_Type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RPG_Item_DictionaryXML_XMLTree_Type (*this, f, c);
}

RPG_Item_DictionaryXML_XMLTree_Type::
~RPG_Item_DictionaryXML_XMLTree_Type ()
{
}

bool
operator== (const RPG_Item_DictionaryXML_XMLTree_Type& x, const RPG_Item_DictionaryXML_XMLTree_Type& y)
{
  if (!(x.armor () == y.armor ()))
    return false;

  if (!(x.commodity () == y.commodity ()))
    return false;

  if (!(x.weapon () == y.weapon ()))
    return false;

  return true;
}

bool
operator!= (const RPG_Item_DictionaryXML_XMLTree_Type& x, const RPG_Item_DictionaryXML_XMLTree_Type& y)
{
  return !(x == y);
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_Type_XMLTree_Type::value i)
{
  return o << RPG_Item_Type_XMLTree_Type::_xsd_RPG_Item_Type_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_Type_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_CommodityType_XMLTree_Type::value i)
{
  return o << RPG_Item_CommodityType_XMLTree_Type::_xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CommodityType_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_CommodityBeverage_XMLTree_Type::value i)
{
  return o << RPG_Item_CommodityBeverage_XMLTree_Type::_xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CommodityBeverage_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_CommodityLight_XMLTree_Type::value i)
{
  return o << RPG_Item_CommodityLight_XMLTree_Type::_xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CommodityLight_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_CommodityUnion_XMLTree_Type::value i)
{
  return o << RPG_Item_CommodityUnion_XMLTree_Type::_xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CommodityUnion_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_Money_XMLTree_Type::value i)
{
  return o << RPG_Item_Money_XMLTree_Type::_xsd_RPG_Item_Money_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_Money_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_WeaponCategory_XMLTree_Type::value i)
{
  return o << RPG_Item_WeaponCategory_XMLTree_Type::_xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_WeaponCategory_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_WeaponClass_XMLTree_Type::value i)
{
  return o << RPG_Item_WeaponClass_XMLTree_Type::_xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_WeaponClass_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_WeaponType_XMLTree_Type::value i)
{
  return o << RPG_Item_WeaponType_XMLTree_Type::_xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_WeaponType_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_StorePrice_XMLTree_Type& i)
{
  if (i.numGoldPieces ())
  {
    o << ::std::endl << "numGoldPieces: " << *i.numGoldPieces ();
  }

  if (i.numSilverPieces ())
  {
    o << ::std::endl << "numSilverPieces: " << *i.numSilverPieces ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CriticalHitProperties_XMLTree_Type& i)
{
  o << ::std::endl << "minToHitRoll: " << i.minToHitRoll ();
  o << ::std::endl << "damageModifier: " << i.damageModifier ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CreationCost_XMLTree_Type& i)
{
  if (i.numGoldPieces ())
  {
    o << ::std::endl << "numGoldPieces: " << *i.numGoldPieces ();
  }

  if (i.numExperiencePoints ())
  {
    o << ::std::endl << "numExperiencePoints: " << *i.numExperiencePoints ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_BaseProperties_XMLTree_Type& i)
{
  o << ::std::endl << "baseWeight: " << i.baseWeight ();
  o << ::std::endl << "baseStorePrice: " << i.baseStorePrice ();
  if (i.costToCreate ())
  {
    o << ::std::endl << "costToCreate: " << *i.costToCreate ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_MagicalPrerequisites_XMLTree_Type& i)
{
  if (i.minCasterLevel ())
  {
    o << ::std::endl << "minCasterLevel: " << *i.minCasterLevel ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_PropertiesBase_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_BaseProperties_XMLTree_Type& > (i);

  if (i.aura ())
  {
    o << ::std::endl << "aura: " << *i.aura ();
  }

  if (i.prerequisites ())
  {
    o << ::std::endl << "prerequisites: " << *i.prerequisites ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_CommodityPropertiesBase_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "subType: " << i.subType ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_WeaponPropertiesBase_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "category: " << i.category ();
  o << ::std::endl << "weaponClass: " << i.weaponClass ();
  o << ::std::endl << "baseDamage: " << i.baseDamage ();
  o << ::std::endl << "criticalHit: " << i.criticalHit ();
  if (i.rangeIncrement ())
  {
    o << ::std::endl << "rangeIncrement: " << *i.rangeIncrement ();
  }

  for (RPG_Item_WeaponPropertiesBase_XMLTree_Type::typeOfDamage_const_iterator
       b (i.typeOfDamage ().begin ()), e (i.typeOfDamage ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "typeOfDamage: " << *b;
  }

  o << ::std::endl << "isNonLethal: " << i.isNonLethal ();
  o << ::std::endl << "isReachWeapon: " << i.isReachWeapon ();
  o << ::std::endl << "isDoubleWeapon: " << i.isDoubleWeapon ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_WeaponPropertiesXML_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_WeaponPropertiesBase_XMLTree_Type& > (i);

  if (i.toHitModifier ())
  {
    o << ::std::endl << "toHitModifier: " << *i.toHitModifier ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_ArmorCategory_XMLTree_Type::value i)
{
  return o << RPG_Item_ArmorCategory_XMLTree_Type::_xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_ArmorCategory_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, RPG_Item_ArmorType_XMLTree_Type::value i)
{
  return o << RPG_Item_ArmorType_XMLTree_Type::_xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_ArmorType_XMLTree_Type& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_ArmorPropertiesBase_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  o << ::std::endl << "type: " << i.type ();
  o << ::std::endl << "category: " << i.category ();
  o << ::std::endl << "baseBonus: " << i.baseBonus ();
  o << ::std::endl << "maxDexterityBonus: " << i.maxDexterityBonus ();
  o << ::std::endl << "checkPenalty: " << i.checkPenalty ();
  o << ::std::endl << "arcaneSpellFailure: " << i.arcaneSpellFailure ();
  o << ::std::endl << "baseSpeed: " << i.baseSpeed ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_ArmorPropertiesXML_XMLTree_Type& i)
{
  o << static_cast< const ::RPG_Item_ArmorPropertiesBase_XMLTree_Type& > (i);

  if (i.defenseModifier ())
  {
    o << ::std::endl << "defenseModifier: " << *i.defenseModifier ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_XML_XMLTree_Type& i)
{
  o << ::std::endl << "type: " << i.type ();
  if (i.armor ())
  {
    o << ::std::endl << "armor: " << *i.armor ();
  }

  if (i.commodity ())
  {
    o << ::std::endl << "commodity: " << *i.commodity ();
  }

  if (i.weapon ())
  {
    o << ::std::endl << "weapon: " << *i.weapon ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_InventoryXML_XMLTree_Type& i)
{
  for (RPG_Item_InventoryXML_XMLTree_Type::item_const_iterator
       b (i.item ().begin ()), e (i.item ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "item: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const RPG_Item_DictionaryXML_XMLTree_Type& i)
{
  for (RPG_Item_DictionaryXML_XMLTree_Type::armor_const_iterator
       b (i.armor ().begin ()), e (i.armor ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "armor: " << *b;
  }

  for (RPG_Item_DictionaryXML_XMLTree_Type::commodity_const_iterator
       b (i.commodity ().begin ()), e (i.commodity ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "commodity: " << *b;
  }

  for (RPG_Item_DictionaryXML_XMLTree_Type::weapon_const_iterator
       b (i.weapon ().begin ()), e (i.weapon ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "weapon: " << *b;
  }

  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_Type_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_Type_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_Type_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CommodityType_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_CommodityType_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_CommodityType_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CommodityBeverage_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_CommodityBeverage_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_CommodityBeverage_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CommodityLight_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_CommodityLight_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_CommodityLight_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CommodityUnion_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_CommodityUnion_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_CommodityUnion_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_Money_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_Money_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_Money_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_WeaponCategory_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_WeaponCategory_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_WeaponCategory_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_WeaponClass_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_WeaponClass_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_WeaponClass_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_WeaponType_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_WeaponType_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_WeaponType_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_StorePrice_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // numGoldPieces
  //
  if (i.numGoldPieces ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numGoldPieces",
        "urn:rpg",
        e));

    s << *i.numGoldPieces ();
  }

  // numSilverPieces
  //
  if (i.numSilverPieces ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numSilverPieces",
        "urn:rpg",
        e));

    s << *i.numSilverPieces ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CriticalHitProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // minToHitRoll
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "minToHitRoll",
        "urn:rpg",
        e));

    s << i.minToHitRoll ();
  }

  // damageModifier
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "damageModifier",
        "urn:rpg",
        e));

    s << i.damageModifier ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CreationCost_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // numGoldPieces
  //
  if (i.numGoldPieces ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numGoldPieces",
        "urn:rpg",
        e));

    s << *i.numGoldPieces ();
  }

  // numExperiencePoints
  //
  if (i.numExperiencePoints ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "numExperiencePoints",
        "urn:rpg",
        e));

    s << *i.numExperiencePoints ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_BaseProperties_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // baseWeight
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseWeight",
        "urn:rpg",
        e));

    s << i.baseWeight ();
  }

  // baseStorePrice
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseStorePrice",
        "urn:rpg",
        e));

    s << i.baseStorePrice ();
  }

  // costToCreate
  //
  if (i.costToCreate ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "costToCreate",
        "urn:rpg",
        e));

    s << *i.costToCreate ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_MagicalPrerequisites_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // minCasterLevel
  //
  if (i.minCasterLevel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "minCasterLevel",
        "urn:rpg",
        e));

    s << *i.minCasterLevel ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_PropertiesBase_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_BaseProperties_XMLTree_Type& > (i);

  // aura
  //
  if (i.aura ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "aura",
        "urn:rpg",
        e));

    s << *i.aura ();
  }

  // prerequisites
  //
  if (i.prerequisites ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "prerequisites",
        "urn:rpg",
        e));

    s << *i.prerequisites ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_CommodityPropertiesBase_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // subType
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "subType",
        "urn:rpg",
        e));

    s << i.subType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_WeaponPropertiesBase_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // category
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "category",
        "urn:rpg",
        e));

    s << i.category ();
  }

  // weaponClass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weaponClass",
        "urn:rpg",
        e));

    s << i.weaponClass ();
  }

  // baseDamage
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseDamage",
        "urn:rpg",
        e));

    s << i.baseDamage ();
  }

  // criticalHit
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "criticalHit",
        "urn:rpg",
        e));

    s << i.criticalHit ();
  }

  // rangeIncrement
  //
  if (i.rangeIncrement ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "rangeIncrement",
        "urn:rpg",
        e));

    s << *i.rangeIncrement ();
  }

  // typeOfDamage
  //
  for (RPG_Item_WeaponPropertiesBase_XMLTree_Type::typeOfDamage_const_iterator
       b (i.typeOfDamage ().begin ()), n (i.typeOfDamage ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "typeOfDamage",
        "urn:rpg",
        e));

    s << *b;
  }

  // isNonLethal
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isNonLethal",
        e));

    a << i.isNonLethal ();
  }

  // isReachWeapon
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isReachWeapon",
        e));

    a << i.isReachWeapon ();
  }

  // isDoubleWeapon
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isDoubleWeapon",
        e));

    a << i.isDoubleWeapon ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_WeaponPropertiesXML_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_WeaponPropertiesBase_XMLTree_Type& > (i);

  // toHitModifier
  //
  if (i.toHitModifier ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "toHitModifier",
        "urn:rpg",
        e));

    s << *i.toHitModifier ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_ArmorCategory_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_ArmorCategory_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_ArmorCategory_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_ArmorType_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const RPG_Item_ArmorType_XMLTree_Type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const RPG_Item_ArmorType_XMLTree_Type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_ArmorPropertiesBase_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_PropertiesBase_XMLTree_Type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // category
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "category",
        "urn:rpg",
        e));

    s << i.category ();
  }

  // baseBonus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseBonus",
        "urn:rpg",
        e));

    s << i.baseBonus ();
  }

  // maxDexterityBonus
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "maxDexterityBonus",
        "urn:rpg",
        e));

    s << i.maxDexterityBonus ();
  }

  // checkPenalty
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "checkPenalty",
        "urn:rpg",
        e));

    s << i.checkPenalty ();
  }

  // arcaneSpellFailure
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "arcaneSpellFailure",
        "urn:rpg",
        e));

    s << i.arcaneSpellFailure ();
  }

  // baseSpeed
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "baseSpeed",
        "urn:rpg",
        e));

    s << i.baseSpeed ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_ArmorPropertiesXML_XMLTree_Type& i)
{
  e << static_cast< const ::RPG_Item_ArmorPropertiesBase_XMLTree_Type& > (i);

  // defenseModifier
  //
  if (i.defenseModifier ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "defenseModifier",
        "urn:rpg",
        e));

    s << *i.defenseModifier ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_XML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        "urn:rpg",
        e));

    s << i.type ();
  }

  // armor
  //
  if (i.armor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "armor",
        "urn:rpg",
        e));

    s << *i.armor ();
  }

  // commodity
  //
  if (i.commodity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "commodity",
        "urn:rpg",
        e));

    s << *i.commodity ();
  }

  // weapon
  //
  if (i.weapon ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weapon",
        "urn:rpg",
        e));

    s << *i.weapon ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_InventoryXML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // item
  //
  for (RPG_Item_InventoryXML_XMLTree_Type::item_const_iterator
       b (i.item ().begin ()), n (i.item ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "item",
        "urn:rpg",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RPG_Item_DictionaryXML_XMLTree_Type& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // armor
  //
  for (RPG_Item_DictionaryXML_XMLTree_Type::armor_const_iterator
       b (i.armor ().begin ()), n (i.armor ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "armor",
        "urn:rpg",
        e));

    s << *b;
  }

  // commodity
  //
  for (RPG_Item_DictionaryXML_XMLTree_Type::commodity_const_iterator
       b (i.commodity ().begin ()), n (i.commodity ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "commodity",
        "urn:rpg",
        e));

    s << *b;
  }

  // weapon
  //
  for (RPG_Item_DictionaryXML_XMLTree_Type::weapon_const_iterator
       b (i.weapon ().begin ()), n (i.weapon ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "weapon",
        "urn:rpg",
        e));

    s << *b;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

