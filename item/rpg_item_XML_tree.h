// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___RPG_ITEM_XML_TREE_H
#define CXX___RPG_ITEM_XML_TREE_H

// Begin prologue.
//
#include "rpg_item_exports.h"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include "rpg_XMLSchema_XML_tree.h"

// Forward declarations.
//
class RPG_Item_Type_XMLTree_Type;
class RPG_Item_CommodityType_XMLTree_Type;
class RPG_Item_CommodityBeverage_XMLTree_Type;
class RPG_Item_CommodityLight_XMLTree_Type;
class RPG_Item_CommodityUnion_XMLTree_Type;
class RPG_Item_Money_XMLTree_Type;
class RPG_Item_WeaponCategory_XMLTree_Type;
class RPG_Item_WeaponClass_XMLTree_Type;
class RPG_Item_WeaponType_XMLTree_Type;
class RPG_Item_StorePrice_XMLTree_Type;
class RPG_Item_CriticalHitProperties_XMLTree_Type;
class RPG_Item_CreationCost_XMLTree_Type;
class RPG_Item_BaseProperties_XMLTree_Type;
class RPG_Item_MagicalPrerequisites_XMLTree_Type;
class RPG_Item_PropertiesBase_XMLTree_Type;
class RPG_Item_CommodityPropertiesBase_XMLTree_Type;
class RPG_Item_WeaponPropertiesBase_XMLTree_Type;
class RPG_Item_WeaponPropertiesXML_XMLTree_Type;
class RPG_Item_ArmorCategory_XMLTree_Type;
class RPG_Item_ArmorType_XMLTree_Type;
class RPG_Item_ArmorPropertiesBase_XMLTree_Type;
class RPG_Item_ArmorPropertiesXML_XMLTree_Type;
class RPG_Item_XML_XMLTree_Type;
class RPG_Item_InventoryXML_XMLTree_Type;
class RPG_Item_DictionaryXML_XMLTree_Type;

#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/istream-fwd.hxx>

#include "rpg_dice_XML_tree.h"

#include "rpg_common_XML_tree.h"

#include "rpg_magic_XML_tree.h"

class RPG_Item_Export RPG_Item_Type_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ITEM_ARMOR,
    ITEM_COMMODITY,
    ITEM_OTHER,
    ITEM_VALUABLE,
    ITEM_WEAPON
  };

  RPG_Item_Type_XMLTree_Type (value v);

  RPG_Item_Type_XMLTree_Type (const char* v);

  RPG_Item_Type_XMLTree_Type (const ::std::string& v);

  RPG_Item_Type_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_Type_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  RPG_Item_Type_XMLTree_Type (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  RPG_Item_Type_XMLTree_Type (const ::xercesc::DOMAttr& a,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  RPG_Item_Type_XMLTree_Type (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  RPG_Item_Type_XMLTree_Type (const RPG_Item_Type_XMLTree_Type& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

  virtual RPG_Item_Type_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_Type_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_Type_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_Type_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_Type_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Item_Type_XMLTree_Type_indexes_[5];
};

class RPG_Item_Export RPG_Item_CommodityType_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    COMMODITY_BEVERAGE,
    COMMODITY_FOOD,
    COMMODITY_LIGHT,
    COMMODITY_OTHER
  };

  RPG_Item_CommodityType_XMLTree_Type (value v);

  RPG_Item_CommodityType_XMLTree_Type (const char* v);

  RPG_Item_CommodityType_XMLTree_Type (const ::std::string& v);

  RPG_Item_CommodityType_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_CommodityType_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_CommodityType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_CommodityType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_CommodityType_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_CommodityType_XMLTree_Type (const RPG_Item_CommodityType_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Item_CommodityType_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_CommodityType_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_CommodityType_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_CommodityType_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_CommodityType_XMLTree_Type_literals_[4];
  static const value _xsd_RPG_Item_CommodityType_XMLTree_Type_indexes_[4];
};

class RPG_Item_Export RPG_Item_CommodityBeverage_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    COMMODITY_BEVERAGE_BEER,
    COMMODITY_BEVERAGE_WATER,
    COMMODITY_BEVERAGE_WINE
  };

  RPG_Item_CommodityBeverage_XMLTree_Type (value v);

  RPG_Item_CommodityBeverage_XMLTree_Type (const char* v);

  RPG_Item_CommodityBeverage_XMLTree_Type (const ::std::string& v);

  RPG_Item_CommodityBeverage_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_CommodityBeverage_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Item_CommodityBeverage_XMLTree_Type (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Item_CommodityBeverage_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Item_CommodityBeverage_XMLTree_Type (const ::std::string& s,
                                           const ::xercesc::DOMElement* e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  RPG_Item_CommodityBeverage_XMLTree_Type (const RPG_Item_CommodityBeverage_XMLTree_Type& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

  virtual RPG_Item_CommodityBeverage_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_CommodityBeverage_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Item_CommodityBeverage_XMLTree_Type_indexes_[3];
};

class RPG_Item_Export RPG_Item_CommodityLight_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    COMMODITY_LIGHT_CANDLE,
    COMMODITY_LIGHT_LAMP,
    COMMODITY_LIGHT_LANTERN_BULLSEYE,
    COMMODITY_LIGHT_LANTERN_HOODED,
    COMMODITY_LIGHT_TORCH
  };

  RPG_Item_CommodityLight_XMLTree_Type (value v);

  RPG_Item_CommodityLight_XMLTree_Type (const char* v);

  RPG_Item_CommodityLight_XMLTree_Type (const ::std::string& v);

  RPG_Item_CommodityLight_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_CommodityLight_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityLight_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityLight_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityLight_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityLight_XMLTree_Type (const RPG_Item_CommodityLight_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Item_CommodityLight_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_CommodityLight_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_CommodityLight_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_CommodityLight_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_CommodityLight_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Item_CommodityLight_XMLTree_Type_indexes_[5];
};

class RPG_Item_Export RPG_Item_CommodityUnion_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    COMMODITY_BEVERAGE_BEER,
    COMMODITY_BEVERAGE_WATER,
    COMMODITY_BEVERAGE_WINE,
    COMMODITY_LIGHT_CANDLE,
    COMMODITY_LIGHT_LAMP,
    COMMODITY_LIGHT_LANTERN_BULLSEYE,
    COMMODITY_LIGHT_LANTERN_HOODED,
    COMMODITY_LIGHT_TORCH
  };

  RPG_Item_CommodityUnion_XMLTree_Type (value v);

  RPG_Item_CommodityUnion_XMLTree_Type (const char* v);

  RPG_Item_CommodityUnion_XMLTree_Type (const ::std::string& v);

  RPG_Item_CommodityUnion_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_CommodityUnion_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityUnion_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityUnion_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityUnion_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_CommodityUnion_XMLTree_Type (const RPG_Item_CommodityUnion_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Item_CommodityUnion_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_CommodityUnion_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_CommodityUnion_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_CommodityUnion_XMLTree_Type_literals_[8];
  static const value _xsd_RPG_Item_CommodityUnion_XMLTree_Type_indexes_[8];
};

class RPG_Item_Export RPG_Item_Money_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    MONEY_COIN_COPPER,
    MONEY_COIN_SILVER,
    MONEY_COIN_GOLD,
    MONEY_COIN_PLATINUM,
    MONEY_GEM,
    MONEY_PRECIOUS
  };

  RPG_Item_Money_XMLTree_Type (value v);

  RPG_Item_Money_XMLTree_Type (const char* v);

  RPG_Item_Money_XMLTree_Type (const ::std::string& v);

  RPG_Item_Money_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_Money_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  RPG_Item_Money_XMLTree_Type (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  RPG_Item_Money_XMLTree_Type (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  RPG_Item_Money_XMLTree_Type (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  RPG_Item_Money_XMLTree_Type (const RPG_Item_Money_XMLTree_Type& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

  virtual RPG_Item_Money_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_Money_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_Money_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_Money_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_Money_XMLTree_Type_literals_[6];
  static const value _xsd_RPG_Item_Money_XMLTree_Type_indexes_[6];
};

class RPG_Item_Export RPG_Item_WeaponCategory_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    WEAPONCATEGORY_SIMPLE,
    WEAPONCATEGORY_MARTIAL,
    WEAPONCATEGORY_EXOTIC
  };

  RPG_Item_WeaponCategory_XMLTree_Type (value v);

  RPG_Item_WeaponCategory_XMLTree_Type (const char* v);

  RPG_Item_WeaponCategory_XMLTree_Type (const ::std::string& v);

  RPG_Item_WeaponCategory_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_WeaponCategory_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_WeaponCategory_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_WeaponCategory_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_WeaponCategory_XMLTree_Type (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_WeaponCategory_XMLTree_Type (const RPG_Item_WeaponCategory_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Item_WeaponCategory_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_WeaponCategory_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_WeaponCategory_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_WeaponCategory_XMLTree_Type_literals_[3];
  static const value _xsd_RPG_Item_WeaponCategory_XMLTree_Type_indexes_[3];
};

class RPG_Item_Export RPG_Item_WeaponClass_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    WEAPONCLASS_UNARMED,
    WEAPONCLASS_LIGHT_MELEE,
    WEAPONCLASS_ONE_HANDED_MELEE,
    WEAPONCLASS_TWO_HANDED_MELEE,
    WEAPONCLASS_RANGED
  };

  RPG_Item_WeaponClass_XMLTree_Type (value v);

  RPG_Item_WeaponClass_XMLTree_Type (const char* v);

  RPG_Item_WeaponClass_XMLTree_Type (const ::std::string& v);

  RPG_Item_WeaponClass_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_WeaponClass_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Item_WeaponClass_XMLTree_Type (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Item_WeaponClass_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Item_WeaponClass_XMLTree_Type (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  RPG_Item_WeaponClass_XMLTree_Type (const RPG_Item_WeaponClass_XMLTree_Type& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

  virtual RPG_Item_WeaponClass_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_WeaponClass_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_WeaponClass_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_WeaponClass_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_WeaponClass_XMLTree_Type_literals_[5];
  static const value _xsd_RPG_Item_WeaponClass_XMLTree_Type_indexes_[5];
};

class RPG_Item_Export RPG_Item_WeaponType_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    UNARMED_WEAPON_GAUNTLET,
    UNARMED_WEAPON_STRIKE,
    LIGHT_MELEE_WEAPON_DAGGER,
    LIGHT_MELEE_WEAPON_DAGGER_PUNCHING,
    LIGHT_MELEE_WEAPON_GAUNTLET_SPIKED,
    LIGHT_MELEE_WEAPON_MACE_LIGHT,
    LIGHT_MELEE_WEAPON_SICKLE,
    ONE_HANDED_MELEE_WEAPON_CLUB,
    ONE_HANDED_MELEE_WEAPON_MACE_HEAVY,
    ONE_HANDED_MELEE_WEAPON_MORNINGSTAR,
    ONE_HANDED_MELEE_WEAPON_SHORTSPEAR,
    TWO_HANDED_MELEE_WEAPON_LONGSPEAR,
    TWO_HANDED_MELEE_WEAPON_QUARTERSTAFF,
    TWO_HANDED_MELEE_WEAPON_SPEAR,
    RANGED_WEAPON_CROSSBOW_LIGHT,
    RANGED_WEAPON_CROSSBOW_HEAVY,
    RANGED_WEAPON_DART,
    RANGED_WEAPON_JAVELIN,
    RANGED_WEAPON_SLING,
    LIGHT_MELEE_WEAPON_AXE_THROWING,
    LIGHT_MELEE_WEAPON_HAMMER_LIGHT,
    LIGHT_MELEE_WEAPON_AXE_HAND,
    LIGHT_MELEE_WEAPON_KUKRI,
    LIGHT_MELEE_WEAPON_PICK_LIGHT,
    LIGHT_MELEE_WEAPON_SAP,
    LIGHT_MELEE_WEAPON_SHIELD_LIGHT,
    LIGHT_MELEE_WEAPON_ARMOR_SPIKED,
    LIGHT_MELEE_WEAPON_SHIELD_LIGHT_SPIKED,
    LIGHT_MELEE_WEAPON_SWORD_SHORT,
    ONE_HANDED_MELEE_WEAPON_AXE_BATTLE,
    ONE_HANDED_MELEE_WEAPON_FLAIL_LIGHT,
    ONE_HANDED_MELEE_WEAPON_SWORD_LONG,
    ONE_HANDED_MELEE_WEAPON_PICK_HEAVY,
    ONE_HANDED_MELEE_WEAPON_RAPIER,
    ONE_HANDED_MELEE_WEAPON_SCIMITAR,
    ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY,
    ONE_HANDED_MELEE_WEAPON_SHIELD_HEAVY_SPIKED,
    ONE_HANDED_MELEE_WEAPON_TRIDENT,
    ONE_HANDED_MELEE_WEAPON_HAMMER_WAR,
    TWO_HANDED_MELEE_WEAPON_FALCHION,
    TWO_HANDED_MELEE_WEAPON_GLAIVE,
    TWO_HANDED_MELEE_WEAPON_AXE_GREAT,
    TWO_HANDED_MELEE_WEAPON_CLUB_GREAT,
    TWO_HANDED_MELEE_WEAPON_FLAIL_HEAVY,
    TWO_HANDED_MELEE_WEAPON_SWORD_GREAT,
    TWO_HANDED_MELEE_WEAPON_GUISARME,
    TWO_HANDED_MELEE_WEAPON_HALBERD,
    TWO_HANDED_MELEE_WEAPON_LANCE,
    TWO_HANDED_MELEE_WEAPON_RANSEUR,
    TWO_HANDED_MELEE_WEAPON_SCYTHE,
    RANGED_WEAPON_BOW_SHORT,
    RANGED_WEAPON_BOW_SHORT_COMPOSITE,
    RANGED_WEAPON_BOW_LONG,
    RANGED_WEAPON_BOW_LONG_COMPOSITE,
    LIGHT_MELEE_WEAPON_KAMA,
    LIGHT_MELEE_WEAPON_NUNCHAKU,
    LIGHT_MELEE_WEAPON_SAI,
    LIGHT_MELEE_WEAPON_SIANGHAM,
    ONE_HANDED_MELEE_WEAPON_SWORD_BASTARD,
    ONE_HANDED_MELEE_WEAPON_AXE_WAR_DWARVEN,
    ONE_HANDED_MELEE_WEAPON_WHIP,
    TWO_HANDED_MELEE_WEAPON_AXE_ORC_DOUBLE,
    TWO_HANDED_MELEE_WEAPON_CHAIN_SPIKED,
    TWO_HANDED_MELEE_WEAPON_FLAIL_DIRE,
    TWO_HANDED_MELEE_WEAPON_HAMMER_GNOME_HOOKED,
    TWO_HANDED_MELEE_WEAPON_SWORD_TWO_BLADED,
    TWO_HANDED_MELEE_WEAPON_URGROSH_DWARVEN,
    RANGED_WEAPON_BOLAS,
    RANGED_WEAPON_CROSSBOW_HAND,
    RANGED_WEAPON_CROSSBOW_REPEATING_LIGHT,
    RANGED_WEAPON_CROSSBOW_REPEATING_HEAVY,
    RANGED_WEAPON_NET,
    RANGED_WEAPON_SHURIKEN
  };

  RPG_Item_WeaponType_XMLTree_Type (value v);

  RPG_Item_WeaponType_XMLTree_Type (const char* v);

  RPG_Item_WeaponType_XMLTree_Type (const ::std::string& v);

  RPG_Item_WeaponType_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_WeaponType_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_WeaponType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_WeaponType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_WeaponType_XMLTree_Type (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_WeaponType_XMLTree_Type (const RPG_Item_WeaponType_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Item_WeaponType_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_WeaponType_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_WeaponType_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_WeaponType_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_WeaponType_XMLTree_Type_literals_[73];
  static const value _xsd_RPG_Item_WeaponType_XMLTree_Type_indexes_[73];
};

class RPG_Item_Export RPG_Item_StorePrice_XMLTree_Type: public ::xml_schema::type
{
  public:
  // numGoldPieces
  // 
  typedef ::xml_schema::unsigned_int numGoldPieces_type;
  typedef ::xsd::cxx::tree::optional< numGoldPieces_type > numGoldPieces_optional;
  typedef ::xsd::cxx::tree::traits< numGoldPieces_type, char > numGoldPieces_traits;

  const numGoldPieces_optional&
  numGoldPieces () const;

  numGoldPieces_optional&
  numGoldPieces ();

  void
  numGoldPieces (const numGoldPieces_type& x);

  void
  numGoldPieces (const numGoldPieces_optional& x);

  // numSilverPieces
  // 
  typedef ::xml_schema::unsigned_int numSilverPieces_type;
  typedef ::xsd::cxx::tree::optional< numSilverPieces_type > numSilverPieces_optional;
  typedef ::xsd::cxx::tree::traits< numSilverPieces_type, char > numSilverPieces_traits;

  const numSilverPieces_optional&
  numSilverPieces () const;

  numSilverPieces_optional&
  numSilverPieces ();

  void
  numSilverPieces (const numSilverPieces_type& x);

  void
  numSilverPieces (const numSilverPieces_optional& x);

  // Constructors.
  //
  RPG_Item_StorePrice_XMLTree_Type ();

  RPG_Item_StorePrice_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_StorePrice_XMLTree_Type (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  RPG_Item_StorePrice_XMLTree_Type (const RPG_Item_StorePrice_XMLTree_Type& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

  virtual RPG_Item_StorePrice_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_StorePrice_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  numGoldPieces_optional numGoldPieces_;
  numSilverPieces_optional numSilverPieces_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_StorePrice_XMLTree_Type&, const RPG_Item_StorePrice_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_StorePrice_XMLTree_Type&, const RPG_Item_StorePrice_XMLTree_Type&);


class RPG_Item_Export RPG_Item_CriticalHitProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // minToHitRoll
  // 
  typedef ::xml_schema::unsigned_byte minToHitRoll_type;
  typedef ::xsd::cxx::tree::traits< minToHitRoll_type, char > minToHitRoll_traits;

  const minToHitRoll_type&
  minToHitRoll () const;

  minToHitRoll_type&
  minToHitRoll ();

  void
  minToHitRoll (const minToHitRoll_type& x);

  // damageModifier
  // 
  typedef ::xml_schema::unsigned_byte damageModifier_type;
  typedef ::xsd::cxx::tree::traits< damageModifier_type, char > damageModifier_traits;

  const damageModifier_type&
  damageModifier () const;

  damageModifier_type&
  damageModifier ();

  void
  damageModifier (const damageModifier_type& x);

  // Constructors.
  //
  RPG_Item_CriticalHitProperties_XMLTree_Type (const minToHitRoll_type&,
                                               const damageModifier_type&);

  RPG_Item_CriticalHitProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  RPG_Item_CriticalHitProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  RPG_Item_CriticalHitProperties_XMLTree_Type (const RPG_Item_CriticalHitProperties_XMLTree_Type& x,
                                               ::xml_schema::flags f = 0,
                                               ::xml_schema::container* c = 0);

  virtual RPG_Item_CriticalHitProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_CriticalHitProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< minToHitRoll_type > minToHitRoll_;
  ::xsd::cxx::tree::one< damageModifier_type > damageModifier_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_CriticalHitProperties_XMLTree_Type&, const RPG_Item_CriticalHitProperties_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_CriticalHitProperties_XMLTree_Type&, const RPG_Item_CriticalHitProperties_XMLTree_Type&);


class RPG_Item_Export RPG_Item_CreationCost_XMLTree_Type: public ::xml_schema::type
{
  public:
  // numGoldPieces
  // 
  typedef ::xml_schema::unsigned_int numGoldPieces_type;
  typedef ::xsd::cxx::tree::optional< numGoldPieces_type > numGoldPieces_optional;
  typedef ::xsd::cxx::tree::traits< numGoldPieces_type, char > numGoldPieces_traits;

  const numGoldPieces_optional&
  numGoldPieces () const;

  numGoldPieces_optional&
  numGoldPieces ();

  void
  numGoldPieces (const numGoldPieces_type& x);

  void
  numGoldPieces (const numGoldPieces_optional& x);

  // numExperiencePoints
  // 
  typedef ::xml_schema::unsigned_int numExperiencePoints_type;
  typedef ::xsd::cxx::tree::optional< numExperiencePoints_type > numExperiencePoints_optional;
  typedef ::xsd::cxx::tree::traits< numExperiencePoints_type, char > numExperiencePoints_traits;

  const numExperiencePoints_optional&
  numExperiencePoints () const;

  numExperiencePoints_optional&
  numExperiencePoints ();

  void
  numExperiencePoints (const numExperiencePoints_type& x);

  void
  numExperiencePoints (const numExperiencePoints_optional& x);

  // Constructors.
  //
  RPG_Item_CreationCost_XMLTree_Type ();

  RPG_Item_CreationCost_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Item_CreationCost_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Item_CreationCost_XMLTree_Type (const RPG_Item_CreationCost_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Item_CreationCost_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_CreationCost_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  numGoldPieces_optional numGoldPieces_;
  numExperiencePoints_optional numExperiencePoints_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_CreationCost_XMLTree_Type&, const RPG_Item_CreationCost_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_CreationCost_XMLTree_Type&, const RPG_Item_CreationCost_XMLTree_Type&);


class RPG_Item_Export RPG_Item_BaseProperties_XMLTree_Type: public ::xml_schema::type
{
  public:
  // baseWeight
  // 
  typedef ::xml_schema::unsigned_short baseWeight_type;
  typedef ::xsd::cxx::tree::traits< baseWeight_type, char > baseWeight_traits;

  const baseWeight_type&
  baseWeight () const;

  baseWeight_type&
  baseWeight ();

  void
  baseWeight (const baseWeight_type& x);

  // baseStorePrice
  // 
  typedef ::RPG_Item_StorePrice_XMLTree_Type baseStorePrice_type;
  typedef ::xsd::cxx::tree::traits< baseStorePrice_type, char > baseStorePrice_traits;

  const baseStorePrice_type&
  baseStorePrice () const;

  baseStorePrice_type&
  baseStorePrice ();

  void
  baseStorePrice (const baseStorePrice_type& x);

  void
  baseStorePrice (::std::auto_ptr< baseStorePrice_type > p);

  // costToCreate
  // 
  typedef ::RPG_Item_CreationCost_XMLTree_Type costToCreate_type;
  typedef ::xsd::cxx::tree::optional< costToCreate_type > costToCreate_optional;
  typedef ::xsd::cxx::tree::traits< costToCreate_type, char > costToCreate_traits;

  const costToCreate_optional&
  costToCreate () const;

  costToCreate_optional&
  costToCreate ();

  void
  costToCreate (const costToCreate_type& x);

  void
  costToCreate (const costToCreate_optional& x);

  void
  costToCreate (::std::auto_ptr< costToCreate_type > p);

  // Constructors.
  //
  RPG_Item_BaseProperties_XMLTree_Type (const baseWeight_type&,
                                        const baseStorePrice_type&);

  RPG_Item_BaseProperties_XMLTree_Type (const baseWeight_type&,
                                        ::std::auto_ptr< baseStorePrice_type >&);

  RPG_Item_BaseProperties_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_BaseProperties_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_BaseProperties_XMLTree_Type (const RPG_Item_BaseProperties_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Item_BaseProperties_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_BaseProperties_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< baseWeight_type > baseWeight_;
  ::xsd::cxx::tree::one< baseStorePrice_type > baseStorePrice_;
  costToCreate_optional costToCreate_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_BaseProperties_XMLTree_Type&, const RPG_Item_BaseProperties_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_BaseProperties_XMLTree_Type&, const RPG_Item_BaseProperties_XMLTree_Type&);


class RPG_Item_Export RPG_Item_MagicalPrerequisites_XMLTree_Type: public ::xml_schema::type
{
  public:
  // minCasterLevel
  // 
  typedef ::xml_schema::unsigned_byte minCasterLevel_type;
  typedef ::xsd::cxx::tree::optional< minCasterLevel_type > minCasterLevel_optional;
  typedef ::xsd::cxx::tree::traits< minCasterLevel_type, char > minCasterLevel_traits;

  const minCasterLevel_optional&
  minCasterLevel () const;

  minCasterLevel_optional&
  minCasterLevel ();

  void
  minCasterLevel (const minCasterLevel_type& x);

  void
  minCasterLevel (const minCasterLevel_optional& x);

  // Constructors.
  //
  RPG_Item_MagicalPrerequisites_XMLTree_Type ();

  RPG_Item_MagicalPrerequisites_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Item_MagicalPrerequisites_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Item_MagicalPrerequisites_XMLTree_Type (const RPG_Item_MagicalPrerequisites_XMLTree_Type& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  virtual RPG_Item_MagicalPrerequisites_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_MagicalPrerequisites_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  minCasterLevel_optional minCasterLevel_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_MagicalPrerequisites_XMLTree_Type&, const RPG_Item_MagicalPrerequisites_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_MagicalPrerequisites_XMLTree_Type&, const RPG_Item_MagicalPrerequisites_XMLTree_Type&);


class RPG_Item_Export RPG_Item_PropertiesBase_XMLTree_Type: public ::RPG_Item_BaseProperties_XMLTree_Type
{
  public:
  // aura
  // 
  typedef ::RPG_Magic_School_XMLTree_Type aura_type;
  typedef ::xsd::cxx::tree::optional< aura_type > aura_optional;
  typedef ::xsd::cxx::tree::traits< aura_type, char > aura_traits;

  const aura_optional&
  aura () const;

  aura_optional&
  aura ();

  void
  aura (const aura_type& x);

  void
  aura (const aura_optional& x);

  void
  aura (::std::auto_ptr< aura_type > p);

  // prerequisites
  // 
  typedef ::RPG_Item_MagicalPrerequisites_XMLTree_Type prerequisites_type;
  typedef ::xsd::cxx::tree::optional< prerequisites_type > prerequisites_optional;
  typedef ::xsd::cxx::tree::traits< prerequisites_type, char > prerequisites_traits;

  const prerequisites_optional&
  prerequisites () const;

  prerequisites_optional&
  prerequisites ();

  void
  prerequisites (const prerequisites_type& x);

  void
  prerequisites (const prerequisites_optional& x);

  void
  prerequisites (::std::auto_ptr< prerequisites_type > p);

  // Constructors.
  //
  RPG_Item_PropertiesBase_XMLTree_Type (const baseWeight_type&,
                                        const baseStorePrice_type&);

  RPG_Item_PropertiesBase_XMLTree_Type (const baseWeight_type&,
                                        ::std::auto_ptr< baseStorePrice_type >&);

  RPG_Item_PropertiesBase_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_PropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  RPG_Item_PropertiesBase_XMLTree_Type (const RPG_Item_PropertiesBase_XMLTree_Type& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

  virtual RPG_Item_PropertiesBase_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_PropertiesBase_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  aura_optional aura_;
  prerequisites_optional prerequisites_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_PropertiesBase_XMLTree_Type&, const RPG_Item_PropertiesBase_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_PropertiesBase_XMLTree_Type&, const RPG_Item_PropertiesBase_XMLTree_Type&);


class RPG_Item_Export RPG_Item_CommodityPropertiesBase_XMLTree_Type: public ::RPG_Item_PropertiesBase_XMLTree_Type
{
  public:
  // type
  // 
  typedef ::RPG_Item_CommodityType_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // subType
  // 
  typedef ::RPG_Item_CommodityUnion_XMLTree_Type subType_type;
  typedef ::xsd::cxx::tree::traits< subType_type, char > subType_traits;

  const subType_type&
  subType () const;

  subType_type&
  subType ();

  void
  subType (const subType_type& x);

  void
  subType (::std::auto_ptr< subType_type > p);

  // Constructors.
  //
  RPG_Item_CommodityPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                                 const baseStorePrice_type&,
                                                 const type_type&,
                                                 const subType_type&);

  RPG_Item_CommodityPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                                 ::std::auto_ptr< baseStorePrice_type >&,
                                                 const type_type&,
                                                 const subType_type&);

  RPG_Item_CommodityPropertiesBase_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Item_CommodityPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  RPG_Item_CommodityPropertiesBase_XMLTree_Type (const RPG_Item_CommodityPropertiesBase_XMLTree_Type& x,
                                                 ::xml_schema::flags f = 0,
                                                 ::xml_schema::container* c = 0);

  virtual RPG_Item_CommodityPropertiesBase_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_CommodityPropertiesBase_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< subType_type > subType_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_CommodityPropertiesBase_XMLTree_Type&, const RPG_Item_CommodityPropertiesBase_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_CommodityPropertiesBase_XMLTree_Type&, const RPG_Item_CommodityPropertiesBase_XMLTree_Type&);


class RPG_Item_Export RPG_Item_WeaponPropertiesBase_XMLTree_Type: public ::RPG_Item_PropertiesBase_XMLTree_Type
{
  public:
  // type
  // 
  typedef ::RPG_Item_WeaponType_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // category
  // 
  typedef ::RPG_Item_WeaponCategory_XMLTree_Type category_type;
  typedef ::xsd::cxx::tree::traits< category_type, char > category_traits;

  const category_type&
  category () const;

  category_type&
  category ();

  void
  category (const category_type& x);

  void
  category (::std::auto_ptr< category_type > p);

  // weaponClass
  // 
  typedef ::RPG_Item_WeaponClass_XMLTree_Type weaponClass_type;
  typedef ::xsd::cxx::tree::traits< weaponClass_type, char > weaponClass_traits;

  const weaponClass_type&
  weaponClass () const;

  weaponClass_type&
  weaponClass ();

  void
  weaponClass (const weaponClass_type& x);

  void
  weaponClass (::std::auto_ptr< weaponClass_type > p);

  // baseDamage
  // 
  typedef ::RPG_Dice_Roll_XMLTree_Type baseDamage_type;
  typedef ::xsd::cxx::tree::traits< baseDamage_type, char > baseDamage_traits;

  const baseDamage_type&
  baseDamage () const;

  baseDamage_type&
  baseDamage ();

  void
  baseDamage (const baseDamage_type& x);

  void
  baseDamage (::std::auto_ptr< baseDamage_type > p);

  // criticalHit
  // 
  typedef ::RPG_Item_CriticalHitProperties_XMLTree_Type criticalHit_type;
  typedef ::xsd::cxx::tree::traits< criticalHit_type, char > criticalHit_traits;

  const criticalHit_type&
  criticalHit () const;

  criticalHit_type&
  criticalHit ();

  void
  criticalHit (const criticalHit_type& x);

  void
  criticalHit (::std::auto_ptr< criticalHit_type > p);

  // rangeIncrement
  // 
  typedef ::xml_schema::unsigned_byte rangeIncrement_type;
  typedef ::xsd::cxx::tree::optional< rangeIncrement_type > rangeIncrement_optional;
  typedef ::xsd::cxx::tree::traits< rangeIncrement_type, char > rangeIncrement_traits;

  const rangeIncrement_optional&
  rangeIncrement () const;

  rangeIncrement_optional&
  rangeIncrement ();

  void
  rangeIncrement (const rangeIncrement_type& x);

  void
  rangeIncrement (const rangeIncrement_optional& x);

  // typeOfDamage
  // 
  typedef ::RPG_Common_PhysicalDamageType_XMLTree_Type typeOfDamage_type;
  typedef ::xsd::cxx::tree::sequence< typeOfDamage_type > typeOfDamage_sequence;
  typedef typeOfDamage_sequence::iterator typeOfDamage_iterator;
  typedef typeOfDamage_sequence::const_iterator typeOfDamage_const_iterator;
  typedef ::xsd::cxx::tree::traits< typeOfDamage_type, char > typeOfDamage_traits;

  const typeOfDamage_sequence&
  typeOfDamage () const;

  typeOfDamage_sequence&
  typeOfDamage ();

  void
  typeOfDamage (const typeOfDamage_sequence& s);

  // isNonLethal
  // 
  typedef ::xml_schema::boolean isNonLethal_type;
  typedef ::xsd::cxx::tree::traits< isNonLethal_type, char > isNonLethal_traits;

  const isNonLethal_type&
  isNonLethal () const;

  isNonLethal_type&
  isNonLethal ();

  void
  isNonLethal (const isNonLethal_type& x);

  static isNonLethal_type
  isNonLethal_default_value ();

  // isReachWeapon
  // 
  typedef ::xml_schema::boolean isReachWeapon_type;
  typedef ::xsd::cxx::tree::traits< isReachWeapon_type, char > isReachWeapon_traits;

  const isReachWeapon_type&
  isReachWeapon () const;

  isReachWeapon_type&
  isReachWeapon ();

  void
  isReachWeapon (const isReachWeapon_type& x);

  static isReachWeapon_type
  isReachWeapon_default_value ();

  // isDoubleWeapon
  // 
  typedef ::xml_schema::boolean isDoubleWeapon_type;
  typedef ::xsd::cxx::tree::traits< isDoubleWeapon_type, char > isDoubleWeapon_traits;

  const isDoubleWeapon_type&
  isDoubleWeapon () const;

  isDoubleWeapon_type&
  isDoubleWeapon ();

  void
  isDoubleWeapon (const isDoubleWeapon_type& x);

  static isDoubleWeapon_type
  isDoubleWeapon_default_value ();

  // Constructors.
  //
  RPG_Item_WeaponPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                              const baseStorePrice_type&,
                                              const type_type&,
                                              const category_type&,
                                              const weaponClass_type&,
                                              const baseDamage_type&,
                                              const criticalHit_type&);

  RPG_Item_WeaponPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                              ::std::auto_ptr< baseStorePrice_type >&,
                                              const type_type&,
                                              const category_type&,
                                              const weaponClass_type&,
                                              ::std::auto_ptr< baseDamage_type >&,
                                              ::std::auto_ptr< criticalHit_type >&);

  RPG_Item_WeaponPropertiesBase_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Item_WeaponPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  RPG_Item_WeaponPropertiesBase_XMLTree_Type (const RPG_Item_WeaponPropertiesBase_XMLTree_Type& x,
                                              ::xml_schema::flags f = 0,
                                              ::xml_schema::container* c = 0);

  virtual RPG_Item_WeaponPropertiesBase_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_WeaponPropertiesBase_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< category_type > category_;
  ::xsd::cxx::tree::one< weaponClass_type > weaponClass_;
  ::xsd::cxx::tree::one< baseDamage_type > baseDamage_;
  ::xsd::cxx::tree::one< criticalHit_type > criticalHit_;
  rangeIncrement_optional rangeIncrement_;
  typeOfDamage_sequence typeOfDamage_;
  ::xsd::cxx::tree::one< isNonLethal_type > isNonLethal_;
  ::xsd::cxx::tree::one< isReachWeapon_type > isReachWeapon_;
  ::xsd::cxx::tree::one< isDoubleWeapon_type > isDoubleWeapon_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_WeaponPropertiesBase_XMLTree_Type&, const RPG_Item_WeaponPropertiesBase_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_WeaponPropertiesBase_XMLTree_Type&, const RPG_Item_WeaponPropertiesBase_XMLTree_Type&);


class RPG_Item_Export RPG_Item_WeaponPropertiesXML_XMLTree_Type: public ::RPG_Item_WeaponPropertiesBase_XMLTree_Type
{
  public:
  // toHitModifier
  // 
  typedef ::xml_schema::byte toHitModifier_type;
  typedef ::xsd::cxx::tree::optional< toHitModifier_type > toHitModifier_optional;
  typedef ::xsd::cxx::tree::traits< toHitModifier_type, char > toHitModifier_traits;

  const toHitModifier_optional&
  toHitModifier () const;

  toHitModifier_optional&
  toHitModifier ();

  void
  toHitModifier (const toHitModifier_type& x);

  void
  toHitModifier (const toHitModifier_optional& x);

  // Constructors.
  //
  RPG_Item_WeaponPropertiesXML_XMLTree_Type (const baseWeight_type&,
                                             const baseStorePrice_type&,
                                             const type_type&,
                                             const category_type&,
                                             const weaponClass_type&,
                                             const baseDamage_type&,
                                             const criticalHit_type&);

  RPG_Item_WeaponPropertiesXML_XMLTree_Type (const baseWeight_type&,
                                             ::std::auto_ptr< baseStorePrice_type >&,
                                             const type_type&,
                                             const category_type&,
                                             const weaponClass_type&,
                                             ::std::auto_ptr< baseDamage_type >&,
                                             ::std::auto_ptr< criticalHit_type >&);

  RPG_Item_WeaponPropertiesXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Item_WeaponPropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Item_WeaponPropertiesXML_XMLTree_Type (const RPG_Item_WeaponPropertiesXML_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Item_WeaponPropertiesXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_WeaponPropertiesXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  toHitModifier_optional toHitModifier_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_WeaponPropertiesXML_XMLTree_Type&, const RPG_Item_WeaponPropertiesXML_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_WeaponPropertiesXML_XMLTree_Type&, const RPG_Item_WeaponPropertiesXML_XMLTree_Type&);


class RPG_Item_Export RPG_Item_ArmorCategory_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ARMORCATEGORY_GLOVES,
    ARMORCATEGORY_LIGHT,
    ARMORCATEGORY_MEDIUM,
    ARMORCATEGORY_HEAVY,
    ARMORCATEGORY_HELMET,
    ARMORCATEGORY_SHIELD
  };

  RPG_Item_ArmorCategory_XMLTree_Type (value v);

  RPG_Item_ArmorCategory_XMLTree_Type (const char* v);

  RPG_Item_ArmorCategory_XMLTree_Type (const ::std::string& v);

  RPG_Item_ArmorCategory_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_ArmorCategory_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_ArmorCategory_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_ArmorCategory_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_ArmorCategory_XMLTree_Type (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_ArmorCategory_XMLTree_Type (const RPG_Item_ArmorCategory_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Item_ArmorCategory_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_ArmorCategory_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_ArmorCategory_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_ArmorCategory_XMLTree_Type_literals_[6];
  static const value _xsd_RPG_Item_ArmorCategory_XMLTree_Type_indexes_[6];
};

class RPG_Item_Export RPG_Item_ArmorType_XMLTree_Type: public ::xml_schema::string
{
  public:
  enum value
  {
    ARMOR_NONE,
    ARMOR_PADDED,
    ARMOR_LEATHER,
    ARMOR_LEATHER_STUDDED,
    ARMOR_CHAIN_SHIRT,
    ARMOR_HIDE,
    ARMOR_MAIL_SCALE,
    ARMOR_MAIL_CHAIN,
    ARMOR_PLATE_BREAST,
    ARMOR_MAIL_SPLINT,
    ARMOR_MAIL_BANDED,
    ARMOR_PLATE_HALF,
    ARMOR_PLATE_FULL,
    ARMOR_BUCKLER,
    ARMOR_SHIELD_LIGHT_WOODEN,
    ARMOR_SHIELD_LIGHT_STEEL,
    ARMOR_SHIELD_HEAVY_WOODEN,
    ARMOR_SHIELD_HEAVY_STEEL,
    ARMOR_SHIELD_TOWER
  };

  RPG_Item_ArmorType_XMLTree_Type (value v);

  RPG_Item_ArmorType_XMLTree_Type (const char* v);

  RPG_Item_ArmorType_XMLTree_Type (const ::std::string& v);

  RPG_Item_ArmorType_XMLTree_Type (const ::xml_schema::string& v);

  RPG_Item_ArmorType_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Item_ArmorType_XMLTree_Type (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Item_ArmorType_XMLTree_Type (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Item_ArmorType_XMLTree_Type (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  RPG_Item_ArmorType_XMLTree_Type (const RPG_Item_ArmorType_XMLTree_Type& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

  virtual RPG_Item_ArmorType_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RPG_Item_ArmorType_XMLTree_Type&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_RPG_Item_ArmorType_XMLTree_Type_convert ();
  }

  protected:
  value
  _xsd_RPG_Item_ArmorType_XMLTree_Type_convert () const;

  public:
  static const char* const _xsd_RPG_Item_ArmorType_XMLTree_Type_literals_[19];
  static const value _xsd_RPG_Item_ArmorType_XMLTree_Type_indexes_[19];
};

class RPG_Item_Export RPG_Item_ArmorPropertiesBase_XMLTree_Type: public ::RPG_Item_PropertiesBase_XMLTree_Type
{
  public:
  // type
  // 
  typedef ::RPG_Item_ArmorType_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // category
  // 
  typedef ::RPG_Item_ArmorCategory_XMLTree_Type category_type;
  typedef ::xsd::cxx::tree::traits< category_type, char > category_traits;

  const category_type&
  category () const;

  category_type&
  category ();

  void
  category (const category_type& x);

  void
  category (::std::auto_ptr< category_type > p);

  // baseBonus
  // 
  typedef ::xml_schema::unsigned_byte baseBonus_type;
  typedef ::xsd::cxx::tree::traits< baseBonus_type, char > baseBonus_traits;

  const baseBonus_type&
  baseBonus () const;

  baseBonus_type&
  baseBonus ();

  void
  baseBonus (const baseBonus_type& x);

  // maxDexterityBonus
  // 
  typedef ::xml_schema::unsigned_byte maxDexterityBonus_type;
  typedef ::xsd::cxx::tree::traits< maxDexterityBonus_type, char > maxDexterityBonus_traits;

  const maxDexterityBonus_type&
  maxDexterityBonus () const;

  maxDexterityBonus_type&
  maxDexterityBonus ();

  void
  maxDexterityBonus (const maxDexterityBonus_type& x);

  // checkPenalty
  // 
  typedef ::xml_schema::byte checkPenalty_type;
  typedef ::xsd::cxx::tree::traits< checkPenalty_type, char > checkPenalty_traits;

  const checkPenalty_type&
  checkPenalty () const;

  checkPenalty_type&
  checkPenalty ();

  void
  checkPenalty (const checkPenalty_type& x);

  // arcaneSpellFailure
  // 
  typedef ::xml_schema::unsigned_byte arcaneSpellFailure_type;
  typedef ::xsd::cxx::tree::traits< arcaneSpellFailure_type, char > arcaneSpellFailure_traits;

  const arcaneSpellFailure_type&
  arcaneSpellFailure () const;

  arcaneSpellFailure_type&
  arcaneSpellFailure ();

  void
  arcaneSpellFailure (const arcaneSpellFailure_type& x);

  // baseSpeed
  // 
  typedef ::xml_schema::unsigned_byte baseSpeed_type;
  typedef ::xsd::cxx::tree::traits< baseSpeed_type, char > baseSpeed_traits;

  const baseSpeed_type&
  baseSpeed () const;

  baseSpeed_type&
  baseSpeed ();

  void
  baseSpeed (const baseSpeed_type& x);

  // Constructors.
  //
  RPG_Item_ArmorPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                             const baseStorePrice_type&,
                                             const type_type&,
                                             const category_type&,
                                             const baseBonus_type&,
                                             const maxDexterityBonus_type&,
                                             const checkPenalty_type&,
                                             const arcaneSpellFailure_type&,
                                             const baseSpeed_type&);

  RPG_Item_ArmorPropertiesBase_XMLTree_Type (const baseWeight_type&,
                                             ::std::auto_ptr< baseStorePrice_type >&,
                                             const type_type&,
                                             const category_type&,
                                             const baseBonus_type&,
                                             const maxDexterityBonus_type&,
                                             const checkPenalty_type&,
                                             const arcaneSpellFailure_type&,
                                             const baseSpeed_type&);

  RPG_Item_ArmorPropertiesBase_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Item_ArmorPropertiesBase_XMLTree_Type (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  RPG_Item_ArmorPropertiesBase_XMLTree_Type (const RPG_Item_ArmorPropertiesBase_XMLTree_Type& x,
                                             ::xml_schema::flags f = 0,
                                             ::xml_schema::container* c = 0);

  virtual RPG_Item_ArmorPropertiesBase_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_ArmorPropertiesBase_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  ::xsd::cxx::tree::one< category_type > category_;
  ::xsd::cxx::tree::one< baseBonus_type > baseBonus_;
  ::xsd::cxx::tree::one< maxDexterityBonus_type > maxDexterityBonus_;
  ::xsd::cxx::tree::one< checkPenalty_type > checkPenalty_;
  ::xsd::cxx::tree::one< arcaneSpellFailure_type > arcaneSpellFailure_;
  ::xsd::cxx::tree::one< baseSpeed_type > baseSpeed_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_ArmorPropertiesBase_XMLTree_Type&, const RPG_Item_ArmorPropertiesBase_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_ArmorPropertiesBase_XMLTree_Type&, const RPG_Item_ArmorPropertiesBase_XMLTree_Type&);


class RPG_Item_Export RPG_Item_ArmorPropertiesXML_XMLTree_Type: public ::RPG_Item_ArmorPropertiesBase_XMLTree_Type
{
  public:
  // defenseModifier
  // 
  typedef ::xml_schema::byte defenseModifier_type;
  typedef ::xsd::cxx::tree::optional< defenseModifier_type > defenseModifier_optional;
  typedef ::xsd::cxx::tree::traits< defenseModifier_type, char > defenseModifier_traits;

  const defenseModifier_optional&
  defenseModifier () const;

  defenseModifier_optional&
  defenseModifier ();

  void
  defenseModifier (const defenseModifier_type& x);

  void
  defenseModifier (const defenseModifier_optional& x);

  // Constructors.
  //
  RPG_Item_ArmorPropertiesXML_XMLTree_Type (const baseWeight_type&,
                                            const baseStorePrice_type&,
                                            const type_type&,
                                            const category_type&,
                                            const baseBonus_type&,
                                            const maxDexterityBonus_type&,
                                            const checkPenalty_type&,
                                            const arcaneSpellFailure_type&,
                                            const baseSpeed_type&);

  RPG_Item_ArmorPropertiesXML_XMLTree_Type (const baseWeight_type&,
                                            ::std::auto_ptr< baseStorePrice_type >&,
                                            const type_type&,
                                            const category_type&,
                                            const baseBonus_type&,
                                            const maxDexterityBonus_type&,
                                            const checkPenalty_type&,
                                            const arcaneSpellFailure_type&,
                                            const baseSpeed_type&);

  RPG_Item_ArmorPropertiesXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Item_ArmorPropertiesXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  RPG_Item_ArmorPropertiesXML_XMLTree_Type (const RPG_Item_ArmorPropertiesXML_XMLTree_Type& x,
                                            ::xml_schema::flags f = 0,
                                            ::xml_schema::container* c = 0);

  virtual RPG_Item_ArmorPropertiesXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_ArmorPropertiesXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  defenseModifier_optional defenseModifier_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_ArmorPropertiesXML_XMLTree_Type&, const RPG_Item_ArmorPropertiesXML_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_ArmorPropertiesXML_XMLTree_Type&, const RPG_Item_ArmorPropertiesXML_XMLTree_Type&);


class RPG_Item_Export RPG_Item_XML_XMLTree_Type: public ::xml_schema::type
{
  public:
  // type
  // 
  typedef ::RPG_Item_Type_XMLTree_Type type_type;
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  const type_type&
  type () const;

  type_type&
  type ();

  void
  type (const type_type& x);

  void
  type (::std::auto_ptr< type_type > p);

  // armor
  // 
  typedef ::RPG_Item_ArmorPropertiesXML_XMLTree_Type armor_type;
  typedef ::xsd::cxx::tree::optional< armor_type > armor_optional;
  typedef ::xsd::cxx::tree::traits< armor_type, char > armor_traits;

  const armor_optional&
  armor () const;

  armor_optional&
  armor ();

  void
  armor (const armor_type& x);

  void
  armor (const armor_optional& x);

  void
  armor (::std::auto_ptr< armor_type > p);

  // commodity
  // 
  typedef ::RPG_Item_CommodityPropertiesBase_XMLTree_Type commodity_type;
  typedef ::xsd::cxx::tree::optional< commodity_type > commodity_optional;
  typedef ::xsd::cxx::tree::traits< commodity_type, char > commodity_traits;

  const commodity_optional&
  commodity () const;

  commodity_optional&
  commodity ();

  void
  commodity (const commodity_type& x);

  void
  commodity (const commodity_optional& x);

  void
  commodity (::std::auto_ptr< commodity_type > p);

  // weapon
  // 
  typedef ::RPG_Item_WeaponPropertiesXML_XMLTree_Type weapon_type;
  typedef ::xsd::cxx::tree::optional< weapon_type > weapon_optional;
  typedef ::xsd::cxx::tree::traits< weapon_type, char > weapon_traits;

  const weapon_optional&
  weapon () const;

  weapon_optional&
  weapon ();

  void
  weapon (const weapon_type& x);

  void
  weapon (const weapon_optional& x);

  void
  weapon (::std::auto_ptr< weapon_type > p);

  // Constructors.
  //
  RPG_Item_XML_XMLTree_Type (const type_type&);

  RPG_Item_XML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  RPG_Item_XML_XMLTree_Type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  RPG_Item_XML_XMLTree_Type (const RPG_Item_XML_XMLTree_Type& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

  virtual RPG_Item_XML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_XML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  ::xsd::cxx::tree::one< type_type > type_;
  armor_optional armor_;
  commodity_optional commodity_;
  weapon_optional weapon_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_XML_XMLTree_Type&, const RPG_Item_XML_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_XML_XMLTree_Type&, const RPG_Item_XML_XMLTree_Type&);


class RPG_Item_Export RPG_Item_InventoryXML_XMLTree_Type: public ::xml_schema::type
{
  public:
  // item
  // 
  typedef ::RPG_Item_XML_XMLTree_Type item_type;
  typedef ::xsd::cxx::tree::sequence< item_type > item_sequence;
  typedef item_sequence::iterator item_iterator;
  typedef item_sequence::const_iterator item_const_iterator;
  typedef ::xsd::cxx::tree::traits< item_type, char > item_traits;

  const item_sequence&
  item () const;

  item_sequence&
  item ();

  void
  item (const item_sequence& s);

  // Constructors.
  //
  RPG_Item_InventoryXML_XMLTree_Type ();

  RPG_Item_InventoryXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Item_InventoryXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  RPG_Item_InventoryXML_XMLTree_Type (const RPG_Item_InventoryXML_XMLTree_Type& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

  virtual RPG_Item_InventoryXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_InventoryXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  item_sequence item_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_InventoryXML_XMLTree_Type&, const RPG_Item_InventoryXML_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_InventoryXML_XMLTree_Type&, const RPG_Item_InventoryXML_XMLTree_Type&);


class RPG_Item_Export RPG_Item_DictionaryXML_XMLTree_Type: public ::xml_schema::type
{
  public:
  // armor
  // 
  typedef ::RPG_Item_ArmorPropertiesXML_XMLTree_Type armor_type;
  typedef ::xsd::cxx::tree::sequence< armor_type > armor_sequence;
  typedef armor_sequence::iterator armor_iterator;
  typedef armor_sequence::const_iterator armor_const_iterator;
  typedef ::xsd::cxx::tree::traits< armor_type, char > armor_traits;

  const armor_sequence&
  armor () const;

  armor_sequence&
  armor ();

  void
  armor (const armor_sequence& s);

  // commodity
  // 
  typedef ::RPG_Item_CommodityPropertiesBase_XMLTree_Type commodity_type;
  typedef ::xsd::cxx::tree::sequence< commodity_type > commodity_sequence;
  typedef commodity_sequence::iterator commodity_iterator;
  typedef commodity_sequence::const_iterator commodity_const_iterator;
  typedef ::xsd::cxx::tree::traits< commodity_type, char > commodity_traits;

  const commodity_sequence&
  commodity () const;

  commodity_sequence&
  commodity ();

  void
  commodity (const commodity_sequence& s);

  // weapon
  // 
  typedef ::RPG_Item_WeaponPropertiesXML_XMLTree_Type weapon_type;
  typedef ::xsd::cxx::tree::sequence< weapon_type > weapon_sequence;
  typedef weapon_sequence::iterator weapon_iterator;
  typedef weapon_sequence::const_iterator weapon_const_iterator;
  typedef ::xsd::cxx::tree::traits< weapon_type, char > weapon_traits;

  const weapon_sequence&
  weapon () const;

  weapon_sequence&
  weapon ();

  void
  weapon (const weapon_sequence& s);

  // Constructors.
  //
  RPG_Item_DictionaryXML_XMLTree_Type ();

  RPG_Item_DictionaryXML_XMLTree_Type (::xml_schema::istream< ACE_InputCDR >& s,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_DictionaryXML_XMLTree_Type (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  RPG_Item_DictionaryXML_XMLTree_Type (const RPG_Item_DictionaryXML_XMLTree_Type& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

  virtual RPG_Item_DictionaryXML_XMLTree_Type*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~RPG_Item_DictionaryXML_XMLTree_Type ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  void
  parse (::xml_schema::istream< ACE_InputCDR >&,
         ::xml_schema::flags);

  armor_sequence armor_;
  commodity_sequence commodity_;
  weapon_sequence weapon_;
};

RPG_Item_Export
bool
operator== (const RPG_Item_DictionaryXML_XMLTree_Type&, const RPG_Item_DictionaryXML_XMLTree_Type&);

RPG_Item_Export
bool
operator!= (const RPG_Item_DictionaryXML_XMLTree_Type&, const RPG_Item_DictionaryXML_XMLTree_Type&);


#include <iosfwd>

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_Type_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_Type_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_CommodityType_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CommodityType_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_CommodityBeverage_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CommodityBeverage_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_CommodityLight_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CommodityLight_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_CommodityUnion_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CommodityUnion_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_Money_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_Money_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_WeaponCategory_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_WeaponCategory_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_WeaponClass_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_WeaponClass_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_WeaponType_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_WeaponType_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_StorePrice_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CriticalHitProperties_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CreationCost_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_BaseProperties_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_MagicalPrerequisites_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_PropertiesBase_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_CommodityPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_WeaponPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_WeaponPropertiesXML_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_ArmorCategory_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_ArmorCategory_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, RPG_Item_ArmorType_XMLTree_Type::value);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_ArmorType_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_ArmorPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_ArmorPropertiesXML_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_XML_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_InventoryXML_XMLTree_Type&);

RPG_Item_Export
::std::ostream&
operator<< (::std::ostream&, const RPG_Item_DictionaryXML_XMLTree_Type&);

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_Type_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_Type_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_Type_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CommodityType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_CommodityType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_CommodityType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CommodityBeverage_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_CommodityBeverage_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_CommodityBeverage_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CommodityLight_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_CommodityLight_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_CommodityLight_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CommodityUnion_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_CommodityUnion_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_CommodityUnion_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_Money_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_Money_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_Money_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_WeaponCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_WeaponCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_WeaponCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_WeaponClass_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_WeaponClass_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_WeaponClass_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_WeaponType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_WeaponType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_WeaponType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_StorePrice_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CriticalHitProperties_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CreationCost_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_BaseProperties_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_MagicalPrerequisites_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_PropertiesBase_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_CommodityPropertiesBase_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_WeaponPropertiesBase_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_WeaponPropertiesXML_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_ArmorCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_ArmorCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_ArmorCategory_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_ArmorType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMAttr&, const RPG_Item_ArmorType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xml_schema::list_stream&,
            const RPG_Item_ArmorType_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_ArmorPropertiesBase_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_ArmorPropertiesXML_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_XML_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_InventoryXML_XMLTree_Type&);

RPG_Item_Export
void
operator<< (::xercesc::DOMElement&, const RPG_Item_DictionaryXML_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_Type_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CommodityType_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CommodityBeverage_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CommodityLight_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CommodityUnion_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_Money_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_WeaponCategory_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_WeaponClass_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_WeaponType_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_StorePrice_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CriticalHitProperties_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CreationCost_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_BaseProperties_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_MagicalPrerequisites_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_PropertiesBase_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_CommodityPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_WeaponPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_WeaponPropertiesXML_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_ArmorCategory_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_ArmorType_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_ArmorPropertiesBase_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_ArmorPropertiesXML_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_XML_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_InventoryXML_XMLTree_Type&);

RPG_Item_Export
::xml_schema::ostream< ACE_OutputCDR >&
operator<< (::xml_schema::ostream< ACE_OutputCDR >&,
            const RPG_Item_DictionaryXML_XMLTree_Type&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___RPG_ITEM_XML_TREE_H
