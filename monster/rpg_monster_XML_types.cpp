// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "rpg_monster_XML_types.h"

// RPG_Monster_Type_Type_pskel
//

void RPG_Monster_Type_Type_pskel::
metaType_parser (::RPG_Monster_MetaType_Type_pskel& p)
{
  this->metaType_parser_ = &p;
}

void RPG_Monster_Type_Type_pskel::
subType_parser (::RPG_Monster_SubType_Type_pskel& p)
{
  this->subType_parser_ = &p;
}

void RPG_Monster_Type_Type_pskel::
parsers (::RPG_Monster_MetaType_Type_pskel& metaType,
         ::RPG_Monster_SubType_Type_pskel& subType)
{
  this->metaType_parser_ = &metaType;
  this->subType_parser_ = &subType;
}

RPG_Monster_Type_Type_pskel::
RPG_Monster_Type_Type_pskel ()
: metaType_parser_ (0),
  subType_parser_ (0)
{
}

// RPG_Monster_NaturalArmorClass_Type_pskel
//

void RPG_Monster_NaturalArmorClass_Type_pskel::
normal_parser (::xml_schema::byte_pskel& p)
{
  this->normal_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
touch_parser (::xml_schema::byte_pskel& p)
{
  this->touch_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
flatFooted_parser (::xml_schema::byte_pskel& p)
{
  this->flatFooted_parser_ = &p;
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
parsers (::xml_schema::byte_pskel& normal,
         ::xml_schema::byte_pskel& touch,
         ::xml_schema::byte_pskel& flatFooted)
{
  this->normal_parser_ = &normal;
  this->touch_parser_ = &touch;
  this->flatFooted_parser_ = &flatFooted;
}

RPG_Monster_NaturalArmorClass_Type_pskel::
RPG_Monster_NaturalArmorClass_Type_pskel ()
: normal_parser_ (0),
  touch_parser_ (0),
  flatFooted_parser_ (0)
{
}

// RPG_Monster_AttackAction_Type_pskel
//

void RPG_Monster_AttackAction_Type_pskel::
weapon_parser (::RPG_Monster_WeaponTypeUnion_Type_pskel& p)
{
  this->weapon_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
attackBonus_parser (::xml_schema::byte_pskel& p)
{
  this->attackBonus_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
attackForm_parser (::RPG_Combat_AttackForm_Type_pskel& p)
{
  this->attackForm_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
damage_parser (::RPG_Combat_Damage_Type_pskel& p)
{
  this->damage_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
numAttacksPerRound_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->numAttacksPerRound_parser_ = &p;
}

void RPG_Monster_AttackAction_Type_pskel::
parsers (::RPG_Monster_WeaponTypeUnion_Type_pskel& weapon,
         ::xml_schema::byte_pskel& attackBonus,
         ::RPG_Combat_AttackForm_Type_pskel& attackForm,
         ::RPG_Combat_Damage_Type_pskel& damage,
         ::xml_schema::unsigned_byte_pskel& numAttacksPerRound)
{
  this->weapon_parser_ = &weapon;
  this->attackBonus_parser_ = &attackBonus;
  this->attackForm_parser_ = &attackForm;
  this->damage_parser_ = &damage;
  this->numAttacksPerRound_parser_ = &numAttacksPerRound;
}

RPG_Monster_AttackAction_Type_pskel::
RPG_Monster_AttackAction_Type_pskel ()
: weapon_parser_ (0),
  attackBonus_parser_ (0),
  attackForm_parser_ (0),
  damage_parser_ (0),
  numAttacksPerRound_parser_ (0)
{
}

// RPG_Monster_Attack_Type_pskel
//

void RPG_Monster_Attack_Type_pskel::
baseAttackBonus_parser (::xml_schema::byte_pskel& p)
{
  this->baseAttackBonus_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
grappleBonus_parser (::xml_schema::byte_pskel& p)
{
  this->grappleBonus_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
standardAttackAction_parser (::RPG_Monster_AttackAction_Type_pskel& p)
{
  this->standardAttackAction_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
fullAttackAction_parser (::RPG_Monster_AttackAction_Type_pskel& p)
{
  this->fullAttackAction_parser_ = &p;
}

void RPG_Monster_Attack_Type_pskel::
parsers (::xml_schema::byte_pskel& baseAttackBonus,
         ::xml_schema::byte_pskel& grappleBonus,
         ::RPG_Monster_AttackAction_Type_pskel& standardAttackAction,
         ::RPG_Monster_AttackAction_Type_pskel& fullAttackAction)
{
  this->baseAttackBonus_parser_ = &baseAttackBonus;
  this->grappleBonus_parser_ = &grappleBonus;
  this->standardAttackAction_parser_ = &standardAttackAction;
  this->fullAttackAction_parser_ = &fullAttackAction;
}

RPG_Monster_Attack_Type_pskel::
RPG_Monster_Attack_Type_pskel ()
: baseAttackBonus_parser_ (0),
  grappleBonus_parser_ (0),
  standardAttackAction_parser_ (0),
  fullAttackAction_parser_ (0)
{
}

// RPG_Monster_SavingThrowModifiers_Type_pskel
//

void RPG_Monster_SavingThrowModifiers_Type_pskel::
fortitude_parser (::xml_schema::byte_pskel& p)
{
  this->fortitude_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
reflex_parser (::xml_schema::byte_pskel& p)
{
  this->reflex_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
will_parser (::xml_schema::byte_pskel& p)
{
  this->will_parser_ = &p;
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
parsers (::xml_schema::byte_pskel& fortitude,
         ::xml_schema::byte_pskel& reflex,
         ::xml_schema::byte_pskel& will)
{
  this->fortitude_parser_ = &fortitude;
  this->reflex_parser_ = &reflex;
  this->will_parser_ = &will;
}

RPG_Monster_SavingThrowModifiers_Type_pskel::
RPG_Monster_SavingThrowModifiers_Type_pskel ()
: fortitude_parser_ (0),
  reflex_parser_ (0),
  will_parser_ (0)
{
}

// RPG_Monster_OrganizationSlaverStep_Type_pskel
//

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Dice_ValueRange_Type_pskel& range)
{
  this->name_parser_ = &name;
  this->range_parser_ = &range;
}

RPG_Monster_OrganizationSlaverStep_Type_pskel::
RPG_Monster_OrganizationSlaverStep_Type_pskel ()
: name_parser_ (0),
  range_parser_ (0)
{
}

// RPG_Monster_OrganizationStep_Type_pskel
//

void RPG_Monster_OrganizationStep_Type_pskel::
type_parser (::RPG_Monster_Organization_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
slaves_parser (::RPG_Monster_OrganizationSlaverStep_Type_pskel& p)
{
  this->slaves_parser_ = &p;
}

void RPG_Monster_OrganizationStep_Type_pskel::
parsers (::RPG_Monster_Organization_Type_pskel& type,
         ::RPG_Dice_ValueRange_Type_pskel& range,
         ::RPG_Monster_OrganizationSlaverStep_Type_pskel& slaves)
{
  this->type_parser_ = &type;
  this->range_parser_ = &range;
  this->slaves_parser_ = &slaves;
}

RPG_Monster_OrganizationStep_Type_pskel::
RPG_Monster_OrganizationStep_Type_pskel ()
: type_parser_ (0),
  range_parser_ (0),
  slaves_parser_ (0)
{
}

// RPG_Monster_Organizations_Type_pskel
//

void RPG_Monster_Organizations_Type_pskel::
step_parser (::RPG_Monster_OrganizationStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Monster_Organizations_Type_pskel::
parsers (::RPG_Monster_OrganizationStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Monster_Organizations_Type_pskel::
RPG_Monster_Organizations_Type_pskel ()
: step_parser_ (0)
{
}

// RPG_Monster_AdvancementStep_Type_pskel
//

void RPG_Monster_AdvancementStep_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Monster_AdvancementStep_Type_pskel::
range_parser (::RPG_Dice_ValueRange_Type_pskel& p)
{
  this->range_parser_ = &p;
}

void RPG_Monster_AdvancementStep_Type_pskel::
parsers (::RPG_Character_Size_Type_pskel& size,
         ::RPG_Dice_ValueRange_Type_pskel& range)
{
  this->size_parser_ = &size;
  this->range_parser_ = &range;
}

RPG_Monster_AdvancementStep_Type_pskel::
RPG_Monster_AdvancementStep_Type_pskel ()
: size_parser_ (0),
  range_parser_ (0)
{
}

// RPG_Monster_Advancement_Type_pskel
//

void RPG_Monster_Advancement_Type_pskel::
step_parser (::RPG_Monster_AdvancementStep_Type_pskel& p)
{
  this->step_parser_ = &p;
}

void RPG_Monster_Advancement_Type_pskel::
parsers (::RPG_Monster_AdvancementStep_Type_pskel& step)
{
  this->step_parser_ = &step;
}

RPG_Monster_Advancement_Type_pskel::
RPG_Monster_Advancement_Type_pskel ()
: step_parser_ (0)
{
}

// RPG_Monster_PropertiesXML_Type_pskel
//

void RPG_Monster_PropertiesXML_Type_pskel::
name_parser (::xml_schema::string_pskel& p)
{
  this->name_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
size_parser (::RPG_Character_Size_Type_pskel& p)
{
  this->size_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
type_parser (::RPG_Monster_Type_Type_pskel& p)
{
  this->type_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
hitDice_parser (::RPG_Dice_Roll_Type_pskel& p)
{
  this->hitDice_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
initiative_parser (::xml_schema::byte_pskel& p)
{
  this->initiative_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
speed_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->speed_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
armorClass_parser (::RPG_Monster_NaturalArmorClass_Type_pskel& p)
{
  this->armorClass_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
attack_parser (::RPG_Monster_Attack_Type_pskel& p)
{
  this->attack_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
space_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->space_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
reach_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->reach_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
saves_parser (::RPG_Monster_SavingThrowModifiers_Type_pskel& p)
{
  this->saves_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
attributes_parser (::RPG_Character_Attributes_Type_pskel& p)
{
  this->attributes_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
skills_parser (::RPG_Character_Skills_Type_pskel& p)
{
  this->skills_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
feats_parser (::RPG_Character_Feats_Type_pskel& p)
{
  this->feats_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
environment_parser (::RPG_Character_Environment_Type_pskel& p)
{
  this->environment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
organizations_parser (::RPG_Monster_Organizations_Type_pskel& p)
{
  this->organizations_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
challengeRating_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->challengeRating_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
treasureModifier_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->treasureModifier_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
alignment_parser (::RPG_Character_Alignment_Type_pskel& p)
{
  this->alignment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
advancements_parser (::RPG_Monster_Advancement_Type_pskel& p)
{
  this->advancements_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
levelAdjustment_parser (::xml_schema::unsigned_byte_pskel& p)
{
  this->levelAdjustment_parser_ = &p;
}

void RPG_Monster_PropertiesXML_Type_pskel::
parsers (::xml_schema::string_pskel& name,
         ::RPG_Character_Size_Type_pskel& size,
         ::RPG_Monster_Type_Type_pskel& type,
         ::RPG_Dice_Roll_Type_pskel& hitDice,
         ::xml_schema::byte_pskel& initiative,
         ::xml_schema::unsigned_byte_pskel& speed,
         ::RPG_Monster_NaturalArmorClass_Type_pskel& armorClass,
         ::RPG_Monster_Attack_Type_pskel& attack,
         ::xml_schema::unsigned_byte_pskel& space,
         ::xml_schema::unsigned_byte_pskel& reach,
         ::RPG_Monster_SavingThrowModifiers_Type_pskel& saves,
         ::RPG_Character_Attributes_Type_pskel& attributes,
         ::RPG_Character_Skills_Type_pskel& skills,
         ::RPG_Character_Feats_Type_pskel& feats,
         ::RPG_Character_Environment_Type_pskel& environment,
         ::RPG_Monster_Organizations_Type_pskel& organizations,
         ::xml_schema::unsigned_byte_pskel& challengeRating,
         ::xml_schema::unsigned_byte_pskel& treasureModifier,
         ::RPG_Character_Alignment_Type_pskel& alignment,
         ::RPG_Monster_Advancement_Type_pskel& advancements,
         ::xml_schema::unsigned_byte_pskel& levelAdjustment)
{
  this->name_parser_ = &name;
  this->size_parser_ = &size;
  this->type_parser_ = &type;
  this->hitDice_parser_ = &hitDice;
  this->initiative_parser_ = &initiative;
  this->speed_parser_ = &speed;
  this->armorClass_parser_ = &armorClass;
  this->attack_parser_ = &attack;
  this->space_parser_ = &space;
  this->reach_parser_ = &reach;
  this->saves_parser_ = &saves;
  this->attributes_parser_ = &attributes;
  this->skills_parser_ = &skills;
  this->feats_parser_ = &feats;
  this->environment_parser_ = &environment;
  this->organizations_parser_ = &organizations;
  this->challengeRating_parser_ = &challengeRating;
  this->treasureModifier_parser_ = &treasureModifier;
  this->alignment_parser_ = &alignment;
  this->advancements_parser_ = &advancements;
  this->levelAdjustment_parser_ = &levelAdjustment;
}

RPG_Monster_PropertiesXML_Type_pskel::
RPG_Monster_PropertiesXML_Type_pskel ()
: name_parser_ (0),
  size_parser_ (0),
  type_parser_ (0),
  hitDice_parser_ (0),
  initiative_parser_ (0),
  speed_parser_ (0),
  armorClass_parser_ (0),
  attack_parser_ (0),
  space_parser_ (0),
  reach_parser_ (0),
  saves_parser_ (0),
  attributes_parser_ (0),
  skills_parser_ (0),
  feats_parser_ (0),
  environment_parser_ (0),
  organizations_parser_ (0),
  challengeRating_parser_ (0),
  treasureModifier_parser_ (0),
  alignment_parser_ (0),
  advancements_parser_ (0),
  levelAdjustment_parser_ (0)
{
}

// RPG_Monster_Dictionary_Type_pskel
//

void RPG_Monster_Dictionary_Type_pskel::
monster_parser (::RPG_Monster_PropertiesXML_Type_pskel& p)
{
  this->monster_parser_ = &p;
}

void RPG_Monster_Dictionary_Type_pskel::
parsers (::RPG_Monster_PropertiesXML_Type_pskel& monster)
{
  this->monster_parser_ = &monster;
}

RPG_Monster_Dictionary_Type_pskel::
RPG_Monster_Dictionary_Type_pskel ()
: monster_parser_ (0)
{
}

// RPG_Monster_Type_Type_pskel
//

void RPG_Monster_Type_Type_pskel::
metaType (const RPG_Monster_MetaType&)
{
}

void RPG_Monster_Type_Type_pskel::
subType (const RPG_Monster_SubType&)
{
}

bool RPG_Monster_Type_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "metaType" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->metaType_parser_;

    if (this->metaType_parser_)
      this->metaType_parser_->pre ();

    return true;
  }

  if (n == "subType" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->subType_parser_;

    if (this->subType_parser_)
      this->subType_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Type_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "metaType" && ns == "urn:rpg")
  {
    if (this->metaType_parser_)
      this->metaType (this->metaType_parser_->post_RPG_Monster_MetaType_Type ());

    return true;
  }

  if (n == "subType" && ns == "urn:rpg")
  {
    if (this->subType_parser_)
      this->subType (this->subType_parser_->post_RPG_Monster_SubType_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_NaturalArmorClass_Type_pskel
//

void RPG_Monster_NaturalArmorClass_Type_pskel::
normal (signed char)
{
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
touch (signed char)
{
}

void RPG_Monster_NaturalArmorClass_Type_pskel::
flatFooted (signed char)
{
}

bool RPG_Monster_NaturalArmorClass_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "normal" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->normal_parser_;

    if (this->normal_parser_)
      this->normal_parser_->pre ();

    return true;
  }

  if (n == "touch" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->touch_parser_;

    if (this->touch_parser_)
      this->touch_parser_->pre ();

    return true;
  }

  if (n == "flatFooted" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->flatFooted_parser_;

    if (this->flatFooted_parser_)
      this->flatFooted_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_NaturalArmorClass_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "normal" && ns == "urn:rpg")
  {
    if (this->normal_parser_)
      this->normal (this->normal_parser_->post_byte ());

    return true;
  }

  if (n == "touch" && ns == "urn:rpg")
  {
    if (this->touch_parser_)
      this->touch (this->touch_parser_->post_byte ());

    return true;
  }

  if (n == "flatFooted" && ns == "urn:rpg")
  {
    if (this->flatFooted_parser_)
      this->flatFooted (this->flatFooted_parser_->post_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_AttackAction_Type_pskel
//

void RPG_Monster_AttackAction_Type_pskel::
weapon (const RPG_Monster_WeaponTypeUnion&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
attackBonus (signed char)
{
}

void RPG_Monster_AttackAction_Type_pskel::
attackForm (const RPG_Combat_AttackForm&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
damage (const RPG_Combat_Damage&)
{
}

void RPG_Monster_AttackAction_Type_pskel::
numAttacksPerRound (unsigned char)
{
}

bool RPG_Monster_AttackAction_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->weapon_parser_;

    if (this->weapon_parser_)
      this->weapon_parser_->pre ();

    return true;
  }

  if (n == "attackBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackBonus_parser_;

    if (this->attackBonus_parser_)
      this->attackBonus_parser_->pre ();

    return true;
  }

  if (n == "attackForm" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attackForm_parser_;

    if (this->attackForm_parser_)
      this->attackForm_parser_->pre ();

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->damage_parser_;

    if (this->damage_parser_)
      this->damage_parser_->pre ();

    return true;
  }

  if (n == "numAttacksPerRound" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->numAttacksPerRound_parser_;

    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_AttackAction_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "weapon" && ns == "urn:rpg")
  {
    if (this->weapon_parser_)
      this->weapon (this->weapon_parser_->post_RPG_Monster_WeaponTypeUnion_Type ());

    return true;
  }

  if (n == "attackBonus" && ns == "urn:rpg")
  {
    if (this->attackBonus_parser_)
      this->attackBonus (this->attackBonus_parser_->post_byte ());

    return true;
  }

  if (n == "attackForm" && ns == "urn:rpg")
  {
    if (this->attackForm_parser_)
      this->attackForm (this->attackForm_parser_->post_RPG_Combat_AttackForm_Type ());

    return true;
  }

  if (n == "damage" && ns == "urn:rpg")
  {
    if (this->damage_parser_)
      this->damage (this->damage_parser_->post_RPG_Combat_Damage_Type ());

    return true;
  }

  if (n == "numAttacksPerRound" && ns == "urn:rpg")
  {
    if (this->numAttacksPerRound_parser_)
      this->numAttacksPerRound (this->numAttacksPerRound_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_Attack_Type_pskel
//

void RPG_Monster_Attack_Type_pskel::
baseAttackBonus (signed char)
{
}

void RPG_Monster_Attack_Type_pskel::
grappleBonus (signed char)
{
}

void RPG_Monster_Attack_Type_pskel::
standardAttackAction (const RPG_Monster_AttackAction&)
{
}

void RPG_Monster_Attack_Type_pskel::
fullAttackAction (const RPG_Monster_AttackAction&)
{
}

bool RPG_Monster_Attack_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "baseAttackBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->baseAttackBonus_parser_;

    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus_parser_->pre ();

    return true;
  }

  if (n == "grappleBonus" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->grappleBonus_parser_;

    if (this->grappleBonus_parser_)
      this->grappleBonus_parser_->pre ();

    return true;
  }

  if (n == "standardAttackAction" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->standardAttackAction_parser_;

    if (this->standardAttackAction_parser_)
      this->standardAttackAction_parser_->pre ();

    return true;
  }

  if (n == "fullAttackAction" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fullAttackAction_parser_;

    if (this->fullAttackAction_parser_)
      this->fullAttackAction_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Attack_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "baseAttackBonus" && ns == "urn:rpg")
  {
    if (this->baseAttackBonus_parser_)
      this->baseAttackBonus (this->baseAttackBonus_parser_->post_byte ());

    return true;
  }

  if (n == "grappleBonus" && ns == "urn:rpg")
  {
    if (this->grappleBonus_parser_)
      this->grappleBonus (this->grappleBonus_parser_->post_byte ());

    return true;
  }

  if (n == "standardAttackAction" && ns == "urn:rpg")
  {
    if (this->standardAttackAction_parser_)
      this->standardAttackAction (this->standardAttackAction_parser_->post_RPG_Monster_AttackAction_Type ());

    return true;
  }

  if (n == "fullAttackAction" && ns == "urn:rpg")
  {
    if (this->fullAttackAction_parser_)
      this->fullAttackAction (this->fullAttackAction_parser_->post_RPG_Monster_AttackAction_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_SavingThrowModifiers_Type_pskel
//

void RPG_Monster_SavingThrowModifiers_Type_pskel::
fortitude (signed char)
{
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
reflex (signed char)
{
}

void RPG_Monster_SavingThrowModifiers_Type_pskel::
will (signed char)
{
}

bool RPG_Monster_SavingThrowModifiers_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "fortitude" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->fortitude_parser_;

    if (this->fortitude_parser_)
      this->fortitude_parser_->pre ();

    return true;
  }

  if (n == "reflex" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reflex_parser_;

    if (this->reflex_parser_)
      this->reflex_parser_->pre ();

    return true;
  }

  if (n == "will" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->will_parser_;

    if (this->will_parser_)
      this->will_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_SavingThrowModifiers_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "fortitude" && ns == "urn:rpg")
  {
    if (this->fortitude_parser_)
      this->fortitude (this->fortitude_parser_->post_byte ());

    return true;
  }

  if (n == "reflex" && ns == "urn:rpg")
  {
    if (this->reflex_parser_)
      this->reflex (this->reflex_parser_->post_byte ());

    return true;
  }

  if (n == "will" && ns == "urn:rpg")
  {
    if (this->will_parser_)
      this->will (this->will_parser_->post_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_OrganizationSlaverStep_Type_pskel
//

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Monster_OrganizationSlaverStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

bool RPG_Monster_OrganizationSlaverStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_OrganizationSlaverStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_OrganizationStep_Type_pskel
//

void RPG_Monster_OrganizationStep_Type_pskel::
type (const RPG_Monster_Organization&)
{
}

void RPG_Monster_OrganizationStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

void RPG_Monster_OrganizationStep_Type_pskel::
slaves (const RPG_Monster_OrganizationSlaverStep&)
{
}

bool RPG_Monster_OrganizationStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  if (n == "slaves" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->slaves_parser_;

    if (this->slaves_parser_)
      this->slaves_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_OrganizationStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Monster_Organization_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  if (n == "slaves" && ns == "urn:rpg")
  {
    if (this->slaves_parser_)
      this->slaves (this->slaves_parser_->post_RPG_Monster_OrganizationSlaverStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_Organizations_Type_pskel
//

void RPG_Monster_Organizations_Type_pskel::
step (const RPG_Monster_OrganizationStep&)
{
}

bool RPG_Monster_Organizations_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

    if (this->step_parser_)
      this->step_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Organizations_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    if (this->step_parser_)
      this->step (this->step_parser_->post_RPG_Monster_OrganizationStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_AdvancementStep_Type_pskel
//

void RPG_Monster_AdvancementStep_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Monster_AdvancementStep_Type_pskel::
range (const RPG_Dice_ValueRange&)
{
}

bool RPG_Monster_AdvancementStep_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

    if (this->range_parser_)
      this->range_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_AdvancementStep_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Character_Size_Type ());

    return true;
  }

  if (n == "range" && ns == "urn:rpg")
  {
    if (this->range_parser_)
      this->range (this->range_parser_->post_RPG_Dice_ValueRange_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_Advancement_Type_pskel
//

void RPG_Monster_Advancement_Type_pskel::
step (const RPG_Monster_AdvancementStep&)
{
}

bool RPG_Monster_Advancement_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->step_parser_;

    if (this->step_parser_)
      this->step_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Advancement_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "step" && ns == "urn:rpg")
  {
    if (this->step_parser_)
      this->step (this->step_parser_->post_RPG_Monster_AdvancementStep_Type ());

    return true;
  }

  return false;
}

// RPG_Monster_PropertiesXML_Type_pskel
//

void RPG_Monster_PropertiesXML_Type_pskel::
name (const ::std::string&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
size (const RPG_Character_Size&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
type (const RPG_Monster_Type&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
hitDice (const RPG_Dice_Roll&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
initiative (signed char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
speed (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
armorClass (const RPG_Monster_NaturalArmorClass&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
attack (const RPG_Monster_Attack&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
space (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
reach (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
saves (const RPG_Monster_SavingThrowModifiers&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
attributes (const RPG_Character_Attributes&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
skills (const RPG_Character_Skills&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
feats (const RPG_Character_Feats&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
environment (const RPG_Character_Environment&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
organizations (const RPG_Monster_Organizations&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
challengeRating (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
treasureModifier (unsigned char)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
alignment (const RPG_Character_Alignment&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
advancements (const RPG_Monster_Advancement&)
{
}

void RPG_Monster_PropertiesXML_Type_pskel::
levelAdjustment (unsigned char)
{
}

bool RPG_Monster_PropertiesXML_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

    if (this->name_parser_)
      this->name_parser_->pre ();

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->size_parser_;

    if (this->size_parser_)
      this->size_parser_->pre ();

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->type_parser_;

    if (this->type_parser_)
      this->type_parser_->pre ();

    return true;
  }

  if (n == "hitDice" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->hitDice_parser_;

    if (this->hitDice_parser_)
      this->hitDice_parser_->pre ();

    return true;
  }

  if (n == "initiative" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->initiative_parser_;

    if (this->initiative_parser_)
      this->initiative_parser_->pre ();

    return true;
  }

  if (n == "speed" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->speed_parser_;

    if (this->speed_parser_)
      this->speed_parser_->pre ();

    return true;
  }

  if (n == "armorClass" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->armorClass_parser_;

    if (this->armorClass_parser_)
      this->armorClass_parser_->pre ();

    return true;
  }

  if (n == "attack" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attack_parser_;

    if (this->attack_parser_)
      this->attack_parser_->pre ();

    return true;
  }

  if (n == "space" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->space_parser_;

    if (this->space_parser_)
      this->space_parser_->pre ();

    return true;
  }

  if (n == "reach" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->reach_parser_;

    if (this->reach_parser_)
      this->reach_parser_->pre ();

    return true;
  }

  if (n == "saves" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->saves_parser_;

    if (this->saves_parser_)
      this->saves_parser_->pre ();

    return true;
  }

  if (n == "attributes" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->attributes_parser_;

    if (this->attributes_parser_)
      this->attributes_parser_->pre ();

    return true;
  }

  if (n == "skills" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->skills_parser_;

    if (this->skills_parser_)
      this->skills_parser_->pre ();

    return true;
  }

  if (n == "feats" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->feats_parser_;

    if (this->feats_parser_)
      this->feats_parser_->pre ();

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->environment_parser_;

    if (this->environment_parser_)
      this->environment_parser_->pre ();

    return true;
  }

  if (n == "organizations" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->organizations_parser_;

    if (this->organizations_parser_)
      this->organizations_parser_->pre ();

    return true;
  }

  if (n == "challengeRating" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->challengeRating_parser_;

    if (this->challengeRating_parser_)
      this->challengeRating_parser_->pre ();

    return true;
  }

  if (n == "treasureModifier" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->treasureModifier_parser_;

    if (this->treasureModifier_parser_)
      this->treasureModifier_parser_->pre ();

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->alignment_parser_;

    if (this->alignment_parser_)
      this->alignment_parser_->pre ();

    return true;
  }

  if (n == "advancements" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->advancements_parser_;

    if (this->advancements_parser_)
      this->advancements_parser_->pre ();

    return true;
  }

  if (n == "levelAdjustment" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->levelAdjustment_parser_;

    if (this->levelAdjustment_parser_)
      this->levelAdjustment_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_PropertiesXML_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "name" && ns == "urn:rpg")
  {
    if (this->name_parser_)
      this->name (this->name_parser_->post_string ());

    return true;
  }

  if (n == "size" && ns == "urn:rpg")
  {
    if (this->size_parser_)
      this->size (this->size_parser_->post_RPG_Character_Size_Type ());

    return true;
  }

  if (n == "type" && ns == "urn:rpg")
  {
    if (this->type_parser_)
      this->type (this->type_parser_->post_RPG_Monster_Type_Type ());

    return true;
  }

  if (n == "hitDice" && ns == "urn:rpg")
  {
    if (this->hitDice_parser_)
      this->hitDice (this->hitDice_parser_->post_RPG_Dice_Roll_Type ());

    return true;
  }

  if (n == "initiative" && ns == "urn:rpg")
  {
    if (this->initiative_parser_)
      this->initiative (this->initiative_parser_->post_byte ());

    return true;
  }

  if (n == "speed" && ns == "urn:rpg")
  {
    if (this->speed_parser_)
      this->speed (this->speed_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "armorClass" && ns == "urn:rpg")
  {
    if (this->armorClass_parser_)
      this->armorClass (this->armorClass_parser_->post_RPG_Monster_NaturalArmorClass_Type ());

    return true;
  }

  if (n == "attack" && ns == "urn:rpg")
  {
    if (this->attack_parser_)
      this->attack (this->attack_parser_->post_RPG_Monster_Attack_Type ());

    return true;
  }

  if (n == "space" && ns == "urn:rpg")
  {
    if (this->space_parser_)
      this->space (this->space_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "reach" && ns == "urn:rpg")
  {
    if (this->reach_parser_)
      this->reach (this->reach_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "saves" && ns == "urn:rpg")
  {
    if (this->saves_parser_)
      this->saves (this->saves_parser_->post_RPG_Monster_SavingThrowModifiers_Type ());

    return true;
  }

  if (n == "attributes" && ns == "urn:rpg")
  {
    if (this->attributes_parser_)
      this->attributes (this->attributes_parser_->post_RPG_Character_Attributes_Type ());

    return true;
  }

  if (n == "skills" && ns == "urn:rpg")
  {
    if (this->skills_parser_)
      this->skills (this->skills_parser_->post_RPG_Character_Skills_Type ());

    return true;
  }

  if (n == "feats" && ns == "urn:rpg")
  {
    if (this->feats_parser_)
      this->feats (this->feats_parser_->post_RPG_Character_Feats_Type ());

    return true;
  }

  if (n == "environment" && ns == "urn:rpg")
  {
    if (this->environment_parser_)
      this->environment (this->environment_parser_->post_RPG_Character_Environment_Type ());

    return true;
  }

  if (n == "organizations" && ns == "urn:rpg")
  {
    if (this->organizations_parser_)
      this->organizations (this->organizations_parser_->post_RPG_Monster_Organizations_Type ());

    return true;
  }

  if (n == "challengeRating" && ns == "urn:rpg")
  {
    if (this->challengeRating_parser_)
      this->challengeRating (this->challengeRating_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "treasureModifier" && ns == "urn:rpg")
  {
    if (this->treasureModifier_parser_)
      this->treasureModifier (this->treasureModifier_parser_->post_unsigned_byte ());

    return true;
  }

  if (n == "alignment" && ns == "urn:rpg")
  {
    if (this->alignment_parser_)
      this->alignment (this->alignment_parser_->post_RPG_Character_Alignment_Type ());

    return true;
  }

  if (n == "advancements" && ns == "urn:rpg")
  {
    if (this->advancements_parser_)
      this->advancements (this->advancements_parser_->post_RPG_Monster_Advancement_Type ());

    return true;
  }

  if (n == "levelAdjustment" && ns == "urn:rpg")
  {
    if (this->levelAdjustment_parser_)
      this->levelAdjustment (this->levelAdjustment_parser_->post_unsigned_byte ());

    return true;
  }

  return false;
}

// RPG_Monster_Dictionary_Type_pskel
//

void RPG_Monster_Dictionary_Type_pskel::
monster (const RPG_Monster_PropertiesXML&)
{
}

void RPG_Monster_Dictionary_Type_pskel::
post_RPG_Monster_Dictionary_Type ()
{
}

bool RPG_Monster_Dictionary_Type_pskel::
_start_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n,
                     const ::xml_schema::ro_string* t)
{
  XSD_UNUSED (t);

  if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
    return true;

  if (n == "monster" && ns == "urn:rpg")
  {
    this->::xml_schema::complex_content::context_.top ().parser_ = this->monster_parser_;

    if (this->monster_parser_)
      this->monster_parser_->pre ();

    return true;
  }

  return false;
}

bool RPG_Monster_Dictionary_Type_pskel::
_end_element_impl (const ::xml_schema::ro_string& ns,
                   const ::xml_schema::ro_string& n)
{
  if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
    return true;

  if (n == "monster" && ns == "urn:rpg")
  {
    if (this->monster_parser_)
      this->monster (this->monster_parser_->post_RPG_Monster_PropertiesXML_Type ());

    return true;
  }

  return false;
}

// Begin epilogue.
//
//
// End epilogue.

