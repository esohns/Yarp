Welcome to the **Yarp** wiki!

**Some notes from the (only) contributor**

At this stage, the code really consists of some scaffolding - only the basics. This also means that - barring some unit-tests - there is currently not much to look at (more on this below). However, as this project develops, more and more features will see the light of day.

Currently, development is (unit-) test-driven and so evolution will happen likewise. This means that while there is little controversy over "design" issues (see an outline of some abstractions and tooling decisions below) right now, things may change in the future, as concepts like an "engine" (or "entity driver" ?) or similar "higher-level/server-side" logic evolves. ATM, bottom-up suits me just fine; other motivated contributors may follow this approach by:

* implementing a new feature and writing a testcase alongside to check whether it works as it should
* upgrading a feature and extending/updating any existing test code accordingly
* start a concept prototype/design discussion (on a branch/in this wiki ?) about what a missing feature could look like

Existing funcionality has been grouped into modules (directories) reflecting the intermediate project structure. In alphabetical order, these are:

* *chance*: anything to do with simulating dice and randomness
* *character*: low-level characteristics of player- (and non-player-) entities
* *client*: prototype of a (GNOME/SDL) client UI
* *combat*: anything to do with (round-based) melee simulation (includes concepts for damage, different forms of attack, ...)
* *common*: common concepts that have not been grouped yet (includes schemas for terrain, environment, climate and tools, ...)
* *engine*: some logic to define/handle the non-player entities in an area - the home for any future work in AI
* *graphics*: glue code (uses SDL) realizing surfaces, tiles, windows, cursors and other UI elements. Contains any artwork as well
* *item*: characteristics of material objects that may be manipulated by entities (e.g. tools, weapons and armor)
* *magic*: characteristics of non-material objects and attributes that may be manipulated by entities (i.e. things like spells and special abilities)
* *map*: structures and algorithms related to the generation and manipulation of area maps (currently 2D only). Contains path-finding logic as well
* *monster*: higher-level characteristics of potential adversaries
* *net*: base logic implementing client/server architecture and protocol design for networking
* *sound*: glue code (uses SDL) realizing audio playback. Contains any soundwork as well
* *stream*: lower-level implementation of the pipes-and-filters pattern, built ontop of the ACE framwork. Currently used by the *net* module to implement streamed messages (and should therefore really be a sub-module thereof)
* *test_u*: home to the unit- testcases and related code
* *Yarp*: meta-module combining all other modules, thereby facilitating higher level project work

**Overview of existing functionality**

The implemented unit test program names are self-describing:

* chance_dice: simulate rolling dice
* chance_rangeToRoll: convert a requested range of values (e.g. 2-12) to an (approximated) appropriate dice roll (e.g. 2d6)
* character_generator: generate a player character (text-based / UI)
* character_parser: load/store a player character to/from a file
* rpg_client_gui: client GUI (GNOME/SDL)
* combat_simulator: simulate auto-combat (ATM text-based only)
* graphics_parser: load graphics library
* SDL_gui: test SDL library integration
* item_parser: load item library
* magic_parser: load magic library
* map_generator: load/store area maps
* path_finder: find shortest path between map locations
* monster_parser: load monster library
* net_client: network client stub
* net_server: network server stub
* IRC_client_gui: IRC client UI
* sound_parser: load sound library

The current client UI can load/display an area map using tiles in an isometric ("2.5D") projection using a defined style for walls, floor and doors.
The screen can be scrolled with the mouse or the cursor keys. Using the cursor keys, a player character can be moved around the map. Doors can be opened by clicking on them.

**Some (early) design decisions**

* the (incomplete) ruleset is based on the d20 system reference (see [[http://www.d20srd.org/index.htm]])
* adapted some concepts and ripped some art/soundwork from the *vulture* nethack GUI (see [[http://www.darkarts.co.za/vulture]])
* support networked (client/server ?) multi-user functionality with protocols

**Some implementation decisions**

* C/C++ as primary language
* GNU g++ as primary compiler
* libc/libstdc++/STL to implement basic types/algorithms
* ACE to implement lowlevel patterns and OS abstraction (see [[http://www.cs.wustl.edu/~schmidt/ACE.html]])
* Xerces/XSD/XML is used as schema, entity model and bindings (see [[http://www.codesynthesis.com/products/xsd]])
* SDL is used to implement lowlevel graphics representation (see [[http://www.libsdl.org]])
* GLib/GTK+/libGlade is used to implement the current client prototype (see [[http://library.gnome.org/devel/references]])

**Other decisions**

* Linux as primary development platform
* configuration management through CMake and Autotools
* version management through Git
* KDevelop4 as IDE
